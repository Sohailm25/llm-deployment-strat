> **Navigation** | [← 12.2 SDK Design](12.2_sdk_client_library_guide.md) | [12.4 User Feedback →](12.4_user_feedback_iteration_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | Technical writing &#124; [12.2 SDK Design](12.2_sdk_client_library_guide.md) |
> | **Related** | [12.4 User Feedback](12.4_user_feedback_iteration_guide.md) &#124; [9.3 API Design](../09_inference_serving/9.3_api_design_llm_services_guide.md) |
> | **Next** | [12.4 User Feedback & Iteration](12.4_user_feedback_iteration_guide.md) |

# 12.3 Developer Documentation Guide

## Document Information
- **Version**: 1.0
- **Last Updated**: 2024
- **Owner**: Developer Experience Team
- **Classification**: Internal/External

## Purpose and Scope

This guide provides comprehensive frameworks for creating, maintaining, and evolving developer documentation for LLM platforms. Effective documentation reduces time-to-first-success, decreases support burden, and accelerates developer adoption.

## Prerequisites

- Understanding of technical writing principles
- Familiarity with documentation platforms (GitBook, ReadTheDocs, Docusaurus)
- Knowledge of API design patterns
- Access to code repositories and API specifications

---

## 1. Documentation Architecture

### 1.1 Documentation Types and Hierarchy

```python
"""
Documentation type definitions and organization framework.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any
from datetime import datetime
import json


class DocumentationType(Enum):
    """Types of documentation in the documentation system."""
    QUICKSTART = "quickstart"
    TUTORIAL = "tutorial"
    HOW_TO = "how_to"
    REFERENCE = "reference"
    EXPLANATION = "explanation"
    API_REFERENCE = "api_reference"
    SDK_REFERENCE = "sdk_reference"
    CHANGELOG = "changelog"
    MIGRATION_GUIDE = "migration_guide"
    TROUBLESHOOTING = "troubleshooting"
    FAQ = "faq"
    GLOSSARY = "glossary"


class AudienceLevel(Enum):
    """Target audience experience levels."""
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"


@dataclass
class DocumentMetadata:
    """Metadata for a documentation page."""
    title: str
    doc_type: DocumentationType
    audience_level: AudienceLevel
    description: str
    keywords: List[str]
    prerequisites: List[str] = field(default_factory=list)
    related_docs: List[str] = field(default_factory=list)
    estimated_read_time: int = 5  # minutes
    last_updated: datetime = field(default_factory=datetime.utcnow)
    last_reviewed: Optional[datetime] = None
    author: Optional[str] = None
    reviewers: List[str] = field(default_factory=list)
    version: str = "1.0"

    def to_frontmatter(self) -> str:
        """Convert metadata to YAML frontmatter."""
        return f"""---
title: "{self.title}"
type: {self.doc_type.value}
audience: {self.audience_level.value}
description: "{self.description}"
keywords: {json.dumps(self.keywords)}
prerequisites: {json.dumps(self.prerequisites)}
related_docs: {json.dumps(self.related_docs)}
read_time: {self.estimated_read_time}
last_updated: "{self.last_updated.isoformat()}"
version: "{self.version}"
---
"""


@dataclass
class DocumentationSection:
    """A section within a documentation page."""
    title: str
    content: str
    code_examples: List[Dict[str, str]] = field(default_factory=list)
    subsections: List['DocumentationSection'] = field(default_factory=list)
    callouts: List[Dict[str, str]] = field(default_factory=list)


class DocumentationArchitecture:
    """
    Defines the overall documentation structure and navigation.
    """

    def __init__(self):
        self.sections = self._define_sections()

    def _define_sections(self) -> Dict[str, Dict]:
        """Define the documentation structure."""
        return {
            "getting_started": {
                "title": "Getting Started",
                "order": 1,
                "pages": [
                    {
                        "slug": "introduction",
                        "title": "Introduction to the Platform",
                        "type": DocumentationType.EXPLANATION
                    },
                    {
                        "slug": "quickstart",
                        "title": "5-Minute Quickstart",
                        "type": DocumentationType.QUICKSTART
                    },
                    {
                        "slug": "authentication",
                        "title": "Authentication Setup",
                        "type": DocumentationType.HOW_TO
                    },
                    {
                        "slug": "first-request",
                        "title": "Making Your First Request",
                        "type": DocumentationType.TUTORIAL
                    }
                ]
            },
            "core_concepts": {
                "title": "Core Concepts",
                "order": 2,
                "pages": [
                    {
                        "slug": "models",
                        "title": "Understanding Models",
                        "type": DocumentationType.EXPLANATION
                    },
                    {
                        "slug": "tokens",
                        "title": "Tokens and Pricing",
                        "type": DocumentationType.EXPLANATION
                    },
                    {
                        "slug": "context-window",
                        "title": "Context Windows",
                        "type": DocumentationType.EXPLANATION
                    },
                    {
                        "slug": "embeddings",
                        "title": "Embeddings Overview",
                        "type": DocumentationType.EXPLANATION
                    }
                ]
            },
            "guides": {
                "title": "Guides",
                "order": 3,
                "pages": [
                    {
                        "slug": "chat-completions",
                        "title": "Chat Completions Guide",
                        "type": DocumentationType.TUTORIAL
                    },
                    {
                        "slug": "streaming",
                        "title": "Streaming Responses",
                        "type": DocumentationType.HOW_TO
                    },
                    {
                        "slug": "function-calling",
                        "title": "Function Calling",
                        "type": DocumentationType.TUTORIAL
                    },
                    {
                        "slug": "rag-implementation",
                        "title": "Building RAG Systems",
                        "type": DocumentationType.TUTORIAL
                    },
                    {
                        "slug": "fine-tuning",
                        "title": "Fine-Tuning Models",
                        "type": DocumentationType.TUTORIAL
                    }
                ]
            },
            "api_reference": {
                "title": "API Reference",
                "order": 4,
                "pages": [
                    {
                        "slug": "overview",
                        "title": "API Overview",
                        "type": DocumentationType.API_REFERENCE
                    },
                    {
                        "slug": "completions",
                        "title": "Completions API",
                        "type": DocumentationType.API_REFERENCE
                    },
                    {
                        "slug": "embeddings",
                        "title": "Embeddings API",
                        "type": DocumentationType.API_REFERENCE
                    },
                    {
                        "slug": "models",
                        "title": "Models API",
                        "type": DocumentationType.API_REFERENCE
                    },
                    {
                        "slug": "errors",
                        "title": "Error Reference",
                        "type": DocumentationType.API_REFERENCE
                    }
                ]
            },
            "sdks": {
                "title": "SDKs & Libraries",
                "order": 5,
                "pages": [
                    {
                        "slug": "python",
                        "title": "Python SDK",
                        "type": DocumentationType.SDK_REFERENCE
                    },
                    {
                        "slug": "typescript",
                        "title": "TypeScript SDK",
                        "type": DocumentationType.SDK_REFERENCE
                    },
                    {
                        "slug": "go",
                        "title": "Go SDK",
                        "type": DocumentationType.SDK_REFERENCE
                    },
                    {
                        "slug": "community",
                        "title": "Community Libraries",
                        "type": DocumentationType.REFERENCE
                    }
                ]
            },
            "best_practices": {
                "title": "Best Practices",
                "order": 6,
                "pages": [
                    {
                        "slug": "prompt-engineering",
                        "title": "Prompt Engineering",
                        "type": DocumentationType.HOW_TO
                    },
                    {
                        "slug": "error-handling",
                        "title": "Error Handling",
                        "type": DocumentationType.HOW_TO
                    },
                    {
                        "slug": "rate-limiting",
                        "title": "Managing Rate Limits",
                        "type": DocumentationType.HOW_TO
                    },
                    {
                        "slug": "production-readiness",
                        "title": "Production Checklist",
                        "type": DocumentationType.HOW_TO
                    }
                ]
            },
            "resources": {
                "title": "Resources",
                "order": 7,
                "pages": [
                    {
                        "slug": "changelog",
                        "title": "Changelog",
                        "type": DocumentationType.CHANGELOG
                    },
                    {
                        "slug": "migration",
                        "title": "Migration Guides",
                        "type": DocumentationType.MIGRATION_GUIDE
                    },
                    {
                        "slug": "troubleshooting",
                        "title": "Troubleshooting",
                        "type": DocumentationType.TROUBLESHOOTING
                    },
                    {
                        "slug": "faq",
                        "title": "FAQ",
                        "type": DocumentationType.FAQ
                    },
                    {
                        "slug": "glossary",
                        "title": "Glossary",
                        "type": DocumentationType.GLOSSARY
                    }
                ]
            }
        }

    def generate_sidebar_config(self) -> Dict:
        """Generate sidebar navigation configuration."""
        sidebar = {}
        for section_key, section in sorted(
            self.sections.items(),
            key=lambda x: x[1]["order"]
        ):
            sidebar[section_key] = {
                "title": section["title"],
                "items": [
                    {
                        "title": page["title"],
                        "href": f"/docs/{section_key}/{page['slug']}"
                    }
                    for page in section["pages"]
                ]
            }
        return sidebar

    def get_page_path(self, section: str, slug: str) -> str:
        """Get the file path for a documentation page."""
        return f"docs/{section}/{slug}.mdx"
```

### 1.2 Content Templates

```python
"""
Documentation content templates for consistent structure.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Optional
from dataclasses import dataclass


class DocumentTemplate(ABC):
    """Base class for documentation templates."""

    @abstractmethod
    def generate_structure(self) -> str:
        """Generate the document structure."""
        pass

    @abstractmethod
    def get_required_sections(self) -> List[str]:
        """Return list of required sections."""
        pass


class QuickstartTemplate(DocumentTemplate):
    """Template for quickstart guides."""

    def __init__(
        self,
        title: str,
        description: str,
        prerequisites: List[str],
        steps: List[Dict[str, str]],
        next_steps: List[Dict[str, str]]
    ):
        self.title = title
        self.description = description
        self.prerequisites = prerequisites
        self.steps = steps
        self.next_steps = next_steps

    def get_required_sections(self) -> List[str]:
        return [
            "overview",
            "prerequisites",
            "installation",
            "configuration",
            "first_example",
            "next_steps"
        ]

    def generate_structure(self) -> str:
        """Generate quickstart document structure."""
        doc = f"""# {self.title}

{self.description}

<Info>
**Time to complete**: ~5 minutes
</Info>

## Prerequisites

Before you begin, make sure you have:

"""
        for prereq in self.prerequisites:
            doc += f"- {prereq}\n"

        doc += "\n## Steps\n\n"

        for i, step in enumerate(self.steps, 1):
            doc += f"""### Step {i}: {step['title']}

{step['description']}

```{step.get('language', 'bash')}
{step['code']}
```

"""
            if step.get('note'):
                doc += f"""<Note>
{step['note']}
</Note>

"""

        doc += """## Next Steps

Now that you've completed the quickstart, explore these resources:

"""
        for next_step in self.next_steps:
            doc += f"- [{next_step['title']}]({next_step['url']}): {next_step['description']}\n"

        return doc


class TutorialTemplate(DocumentTemplate):
    """Template for in-depth tutorials."""

    def __init__(
        self,
        title: str,
        description: str,
        learning_objectives: List[str],
        prerequisites: List[str],
        sections: List[Dict],
        summary: str
    ):
        self.title = title
        self.description = description
        self.learning_objectives = learning_objectives
        self.prerequisites = prerequisites
        self.sections = sections
        self.summary = summary

    def get_required_sections(self) -> List[str]:
        return [
            "introduction",
            "learning_objectives",
            "prerequisites",
            "main_content",
            "exercises",
            "summary",
            "further_reading"
        ]

    def generate_structure(self) -> str:
        """Generate tutorial document structure."""
        doc = f"""# {self.title}

{self.description}

## What You'll Learn

"""
        for obj in self.learning_objectives:
            doc += f"- {obj}\n"

        doc += """
## Prerequisites

"""
        for prereq in self.prerequisites:
            doc += f"- {prereq}\n"

        doc += "\n---\n\n"

        for section in self.sections:
            doc += f"""## {section['title']}

{section['content']}

"""
            if section.get('code_example'):
                doc += f"""```{section.get('language', 'python')}
{section['code_example']}
```

"""
            if section.get('explanation'):
                doc += f"""{section['explanation']}

"""

        doc += f"""## Summary

{self.summary}

## Further Reading

- [Related Tutorial 1](/docs/guides/related-1)
- [API Reference](/docs/api-reference/overview)
- [Best Practices](/docs/best-practices/overview)
"""

        return doc


class APIReferenceTemplate(DocumentTemplate):
    """Template for API reference documentation."""

    def __init__(
        self,
        endpoint: str,
        method: str,
        description: str,
        parameters: List[Dict],
        request_body: Optional[Dict],
        responses: List[Dict],
        examples: List[Dict]
    ):
        self.endpoint = endpoint
        self.method = method
        self.description = description
        self.parameters = parameters
        self.request_body = request_body
        self.responses = responses
        self.examples = examples

    def get_required_sections(self) -> List[str]:
        return [
            "endpoint_info",
            "parameters",
            "request_body",
            "responses",
            "examples",
            "error_codes"
        ]

    def generate_structure(self) -> str:
        """Generate API reference document structure."""
        doc = f"""# {self.method.upper()} {self.endpoint}

{self.description}

## Endpoint

```
{self.method.upper()} {self.endpoint}
```

## Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
"""
        for param in self.parameters:
            required = "Yes" if param.get('required') else "No"
            doc += f"| `{param['name']}` | {param['type']} | {required} | {param['description']} |\n"

        if self.request_body:
            doc += f"""
## Request Body

```json
{self._format_json(self.request_body.get('schema', {}))}
```

### Fields

| Field | Type | Required | Description |
|-------|------|----------|-------------|
"""
            for field in self.request_body.get('fields', []):
                required = "Yes" if field.get('required') else "No"
                doc += f"| `{field['name']}` | {field['type']} | {required} | {field['description']} |\n"

        doc += """
## Responses

"""
        for response in self.responses:
            doc += f"""### {response['status_code']} {response['description']}

```json
{self._format_json(response.get('example', {}))}
```

"""

        doc += """## Examples

"""
        for example in self.examples:
            doc += f"""### {example['title']}

<CodeGroup>
```python Python
{example.get('python', '# Python example')}
```

```typescript TypeScript
{example.get('typescript', '// TypeScript example')}
```

```bash cURL
{example.get('curl', '# cURL example')}
```
</CodeGroup>

"""

        return doc

    def _format_json(self, obj: Dict) -> str:
        """Format dictionary as JSON string."""
        import json
        return json.dumps(obj, indent=2)


class HowToTemplate(DocumentTemplate):
    """Template for how-to guides."""

    def __init__(
        self,
        title: str,
        problem_statement: str,
        solution_overview: str,
        steps: List[Dict],
        troubleshooting: List[Dict]
    ):
        self.title = title
        self.problem_statement = problem_statement
        self.solution_overview = solution_overview
        self.steps = steps
        self.troubleshooting = troubleshooting

    def get_required_sections(self) -> List[str]:
        return [
            "problem",
            "solution_overview",
            "step_by_step",
            "verification",
            "troubleshooting"
        ]

    def generate_structure(self) -> str:
        """Generate how-to document structure."""
        doc = f"""# {self.title}

## The Problem

{self.problem_statement}

## Solution Overview

{self.solution_overview}

## Step-by-Step Guide

"""
        for i, step in enumerate(self.steps, 1):
            doc += f"""### {i}. {step['title']}

{step['description']}

"""
            if step.get('code'):
                doc += f"""```{step.get('language', 'python')}
{step['code']}
```

"""
            if step.get('warning'):
                doc += f"""<Warning>
{step['warning']}
</Warning>

"""

        doc += """## Verification

To verify the solution works:

1. Check that [expected outcome 1]
2. Verify [expected outcome 2]
3. Test [edge case]

## Troubleshooting

"""
        for issue in self.troubleshooting:
            doc += f"""### {issue['problem']}

**Cause**: {issue['cause']}

**Solution**: {issue['solution']}

"""

        return doc
```

---

## 2. API Documentation

### 2.1 OpenAPI Specification Management

```python
"""
OpenAPI specification management for API documentation.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import yaml
import json


class ParameterLocation(Enum):
    """OpenAPI parameter locations."""
    PATH = "path"
    QUERY = "query"
    HEADER = "header"
    COOKIE = "cookie"


@dataclass
class OpenAPIParameter:
    """OpenAPI parameter definition."""
    name: str
    location: ParameterLocation
    description: str
    required: bool = False
    schema: Dict[str, Any] = field(default_factory=dict)
    example: Any = None
    deprecated: bool = False

    def to_dict(self) -> Dict:
        """Convert to OpenAPI parameter object."""
        param = {
            "name": self.name,
            "in": self.location.value,
            "description": self.description,
            "required": self.required,
            "schema": self.schema
        }
        if self.example is not None:
            param["example"] = self.example
        if self.deprecated:
            param["deprecated"] = True
        return param


@dataclass
class OpenAPIRequestBody:
    """OpenAPI request body definition."""
    description: str
    content_type: str = "application/json"
    schema: Dict[str, Any] = field(default_factory=dict)
    required: bool = True
    examples: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict:
        """Convert to OpenAPI request body object."""
        body = {
            "description": self.description,
            "required": self.required,
            "content": {
                self.content_type: {
                    "schema": self.schema
                }
            }
        }
        if self.examples:
            body["content"][self.content_type]["examples"] = self.examples
        return body


@dataclass
class OpenAPIResponse:
    """OpenAPI response definition."""
    status_code: int
    description: str
    content_type: str = "application/json"
    schema: Dict[str, Any] = field(default_factory=dict)
    headers: Dict[str, Any] = field(default_factory=dict)
    example: Any = None

    def to_dict(self) -> Dict:
        """Convert to OpenAPI response object."""
        response = {
            "description": self.description
        }
        if self.schema:
            response["content"] = {
                self.content_type: {
                    "schema": self.schema
                }
            }
            if self.example is not None:
                response["content"][self.content_type]["example"] = self.example
        if self.headers:
            response["headers"] = self.headers
        return {str(self.status_code): response}


@dataclass
class OpenAPIEndpoint:
    """Complete OpenAPI endpoint definition."""
    path: str
    method: str
    operation_id: str
    summary: str
    description: str
    tags: List[str]
    parameters: List[OpenAPIParameter] = field(default_factory=list)
    request_body: Optional[OpenAPIRequestBody] = None
    responses: List[OpenAPIResponse] = field(default_factory=list)
    security: List[Dict[str, List[str]]] = field(default_factory=list)
    deprecated: bool = False

    def to_dict(self) -> Dict:
        """Convert to OpenAPI path item object."""
        operation = {
            "operationId": self.operation_id,
            "summary": self.summary,
            "description": self.description,
            "tags": self.tags,
            "parameters": [p.to_dict() for p in self.parameters],
            "responses": {}
        }

        for response in self.responses:
            operation["responses"].update(response.to_dict())

        if self.request_body:
            operation["requestBody"] = self.request_body.to_dict()

        if self.security:
            operation["security"] = self.security

        if self.deprecated:
            operation["deprecated"] = True

        return {self.path: {self.method.lower(): operation}}


class OpenAPISpecGenerator:
    """
    Generate and manage OpenAPI specifications.
    """

    def __init__(
        self,
        title: str,
        version: str,
        description: str,
        base_url: str
    ):
        self.title = title
        self.version = version
        self.description = description
        self.base_url = base_url
        self.endpoints: List[OpenAPIEndpoint] = []
        self.schemas: Dict[str, Any] = {}
        self.security_schemes: Dict[str, Any] = {}
        self.tags: List[Dict[str, str]] = []

    def add_endpoint(self, endpoint: OpenAPIEndpoint) -> None:
        """Add an endpoint to the specification."""
        self.endpoints.append(endpoint)

    def add_schema(self, name: str, schema: Dict[str, Any]) -> None:
        """Add a reusable schema."""
        self.schemas[name] = schema

    def add_security_scheme(
        self,
        name: str,
        scheme_type: str,
        **kwargs
    ) -> None:
        """Add a security scheme."""
        self.security_schemes[name] = {
            "type": scheme_type,
            **kwargs
        }

    def add_tag(self, name: str, description: str) -> None:
        """Add a tag for grouping endpoints."""
        self.tags.append({
            "name": name,
            "description": description
        })

    def generate_spec(self) -> Dict:
        """Generate the complete OpenAPI specification."""
        spec = {
            "openapi": "3.0.3",
            "info": {
                "title": self.title,
                "version": self.version,
                "description": self.description
            },
            "servers": [
                {"url": self.base_url, "description": "Production server"}
            ],
            "tags": self.tags,
            "paths": {},
            "components": {
                "schemas": self.schemas,
                "securitySchemes": self.security_schemes
            }
        }

        for endpoint in self.endpoints:
            endpoint_dict = endpoint.to_dict()
            for path, methods in endpoint_dict.items():
                if path not in spec["paths"]:
                    spec["paths"][path] = {}
                spec["paths"][path].update(methods)

        return spec

    def to_yaml(self) -> str:
        """Export specification as YAML."""
        return yaml.dump(
            self.generate_spec(),
            default_flow_style=False,
            sort_keys=False
        )

    def to_json(self) -> str:
        """Export specification as JSON."""
        return json.dumps(self.generate_spec(), indent=2)


# Example: LLM Platform API Specification
def create_llm_platform_spec() -> OpenAPISpecGenerator:
    """Create OpenAPI spec for LLM platform."""

    spec = OpenAPISpecGenerator(
        title="LLM Platform API",
        version="1.0.0",
        description="Multi-cloud LLM platform with RAG capabilities",
        base_url="https://api.llmplatform.com/v1"
    )

    # Add security schemes
    spec.add_security_scheme(
        "bearerAuth",
        "http",
        scheme="bearer",
        bearerFormat="JWT"
    )
    spec.add_security_scheme(
        "apiKey",
        "apiKey",
        **{"in": "header", "name": "X-API-Key"}
    )

    # Add tags
    spec.add_tag("Completions", "Text generation endpoints")
    spec.add_tag("Embeddings", "Vector embedding endpoints")
    spec.add_tag("Models", "Model management endpoints")

    # Add reusable schemas
    spec.add_schema("Message", {
        "type": "object",
        "required": ["role", "content"],
        "properties": {
            "role": {
                "type": "string",
                "enum": ["system", "user", "assistant"]
            },
            "content": {
                "type": "string"
            }
        }
    })

    spec.add_schema("CompletionRequest", {
        "type": "object",
        "required": ["model", "messages"],
        "properties": {
            "model": {
                "type": "string",
                "description": "Model identifier"
            },
            "messages": {
                "type": "array",
                "items": {"$ref": "#/components/schemas/Message"}
            },
            "temperature": {
                "type": "number",
                "minimum": 0,
                "maximum": 2,
                "default": 1.0
            },
            "max_tokens": {
                "type": "integer",
                "minimum": 1,
                "maximum": 128000
            },
            "stream": {
                "type": "boolean",
                "default": False
            }
        }
    })

    spec.add_schema("CompletionResponse", {
        "type": "object",
        "properties": {
            "id": {"type": "string"},
            "object": {"type": "string"},
            "created": {"type": "integer"},
            "model": {"type": "string"},
            "choices": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "index": {"type": "integer"},
                        "message": {"$ref": "#/components/schemas/Message"},
                        "finish_reason": {"type": "string"}
                    }
                }
            },
            "usage": {
                "type": "object",
                "properties": {
                    "prompt_tokens": {"type": "integer"},
                    "completion_tokens": {"type": "integer"},
                    "total_tokens": {"type": "integer"}
                }
            }
        }
    })

    # Add completions endpoint
    completions_endpoint = OpenAPIEndpoint(
        path="/chat/completions",
        method="POST",
        operation_id="createChatCompletion",
        summary="Create chat completion",
        description="Generate a completion for the provided messages",
        tags=["Completions"],
        request_body=OpenAPIRequestBody(
            description="Completion request parameters",
            schema={"$ref": "#/components/schemas/CompletionRequest"},
            examples={
                "basic": {
                    "summary": "Basic completion",
                    "value": {
                        "model": "gpt-4",
                        "messages": [
                            {"role": "user", "content": "Hello!"}
                        ]
                    }
                }
            }
        ),
        responses=[
            OpenAPIResponse(
                status_code=200,
                description="Successful completion",
                schema={"$ref": "#/components/schemas/CompletionResponse"}
            ),
            OpenAPIResponse(
                status_code=400,
                description="Bad request",
                schema={
                    "type": "object",
                    "properties": {
                        "error": {
                            "type": "object",
                            "properties": {
                                "message": {"type": "string"},
                                "type": {"type": "string"},
                                "code": {"type": "string"}
                            }
                        }
                    }
                }
            ),
            OpenAPIResponse(
                status_code=429,
                description="Rate limit exceeded"
            )
        ],
        security=[{"bearerAuth": []}, {"apiKey": []}]
    )
    spec.add_endpoint(completions_endpoint)

    return spec
```

### 2.2 Interactive API Documentation

```python
"""
Interactive API documentation components.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import json


@dataclass
class APIPlaygroundConfig:
    """Configuration for API playground."""
    endpoint: str
    method: str
    default_headers: Dict[str, str] = field(default_factory=dict)
    default_body: Dict[str, Any] = field(default_factory=dict)
    editable_fields: List[str] = field(default_factory=list)
    response_schema: Optional[Dict] = None


class InteractiveDocGenerator:
    """
    Generate interactive documentation components.
    """

    def __init__(self, base_url: str, api_key_header: str = "Authorization"):
        self.base_url = base_url
        self.api_key_header = api_key_header

    def generate_playground_component(
        self,
        config: APIPlaygroundConfig
    ) -> str:
        """Generate MDX component for API playground."""
        return f'''
<APIPlayground
  endpoint="{config.endpoint}"
  method="{config.method}"
  baseUrl="{self.base_url}"
  defaultHeaders={{{{
    {self._format_headers(config.default_headers)}
  }}}}
  defaultBody={{{{
    {json.dumps(config.default_body, indent=4)}
  }}}}
  editableFields={{{json.dumps(config.editable_fields)}}}
/>
'''

    def generate_code_samples(
        self,
        endpoint: str,
        method: str,
        body: Dict[str, Any],
        languages: List[str] = None
    ) -> str:
        """Generate code samples in multiple languages."""
        languages = languages or ["python", "typescript", "curl", "go"]

        samples = {
            "python": self._generate_python_sample(endpoint, method, body),
            "typescript": self._generate_typescript_sample(endpoint, method, body),
            "curl": self._generate_curl_sample(endpoint, method, body),
            "go": self._generate_go_sample(endpoint, method, body)
        }

        code_group = "<CodeGroup>\n"
        for lang in languages:
            if lang in samples:
                code_group += f"```{lang} {lang.title()}\n{samples[lang]}\n```\n\n"
        code_group += "</CodeGroup>"

        return code_group

    def _generate_python_sample(
        self,
        endpoint: str,
        method: str,
        body: Dict
    ) -> str:
        """Generate Python code sample."""
        return f'''import requests

url = "{self.base_url}{endpoint}"
headers = {{
    "Authorization": "Bearer YOUR_API_KEY",
    "Content-Type": "application/json"
}}
payload = {json.dumps(body, indent=4)}

response = requests.{method.lower()}(url, json=payload, headers=headers)
print(response.json())'''

    def _generate_typescript_sample(
        self,
        endpoint: str,
        method: str,
        body: Dict
    ) -> str:
        """Generate TypeScript code sample."""
        return f'''const response = await fetch("{self.base_url}{endpoint}", {{
  method: "{method.upper()}",
  headers: {{
    "Authorization": "Bearer YOUR_API_KEY",
    "Content-Type": "application/json"
  }},
  body: JSON.stringify({json.dumps(body, indent=4)})
}});

const data = await response.json();
console.log(data);'''

    def _generate_curl_sample(
        self,
        endpoint: str,
        method: str,
        body: Dict
    ) -> str:
        """Generate cURL code sample."""
        body_str = json.dumps(body)
        return f'''curl -X {method.upper()} "{self.base_url}{endpoint}" \\
  -H "Authorization: Bearer YOUR_API_KEY" \\
  -H "Content-Type: application/json" \\
  -d '{body_str}' '''

    def _generate_go_sample(
        self,
        endpoint: str,
        method: str,
        body: Dict
    ) -> str:
        """Generate Go code sample."""
        return f'''package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

func main() {{
    payload := map[string]interface{{}}{json.dumps(body)}
    jsonBody, _ := json.Marshal(payload)

    req, _ := http.NewRequest("{method.upper()}", "{self.base_url}{endpoint}", bytes.NewBuffer(jsonBody))
    req.Header.Set("Authorization", "Bearer YOUR_API_KEY")
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{{}}
    resp, _ := client.Do(req)
    defer resp.Body.Close()

    var result map[string]interface{{}}
    json.NewDecoder(resp.Body).Decode(&result)
    fmt.Println(result)
}}'''

    def _format_headers(self, headers: Dict[str, str]) -> str:
        """Format headers for JSX."""
        formatted = []
        for key, value in headers.items():
            formatted.append(f'"{key}": "{value}"')
        return ",\n    ".join(formatted)

    def generate_response_viewer(
        self,
        example_response: Dict,
        schema: Optional[Dict] = None
    ) -> str:
        """Generate response viewer component."""
        component = f'''
<ResponseViewer
  exampleResponse={{{{
    {json.dumps(example_response, indent=4)}
  }}}}
'''
        if schema:
            component += f'''  schema={{{{
    {json.dumps(schema, indent=4)}
  }}}}
'''
        component += "/>"
        return component
```

---

## 3. Code Examples and Snippets

### 3.1 Code Example Management

```python
"""
Code example management and validation system.
"""

from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import subprocess
import tempfile
import os
import re


class Language(Enum):
    """Supported programming languages."""
    PYTHON = "python"
    TYPESCRIPT = "typescript"
    JAVASCRIPT = "javascript"
    GO = "go"
    RUST = "rust"
    JAVA = "java"
    CSHARP = "csharp"
    RUBY = "ruby"
    PHP = "php"
    BASH = "bash"


@dataclass
class CodeExample:
    """A code example with metadata."""
    id: str
    title: str
    description: str
    language: Language
    code: str
    dependencies: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    runnable: bool = True
    expected_output: Optional[str] = None
    environment_variables: Dict[str, str] = field(default_factory=dict)
    prerequisites: List[str] = field(default_factory=list)


class CodeExampleRepository:
    """
    Repository for managing and organizing code examples.
    """

    def __init__(self):
        self.examples: Dict[str, CodeExample] = {}
        self.examples_by_tag: Dict[str, List[str]] = {}
        self.examples_by_language: Dict[Language, List[str]] = {}

    def add_example(self, example: CodeExample) -> None:
        """Add a code example to the repository."""
        self.examples[example.id] = example

        # Index by tags
        for tag in example.tags:
            if tag not in self.examples_by_tag:
                self.examples_by_tag[tag] = []
            self.examples_by_tag[tag].append(example.id)

        # Index by language
        if example.language not in self.examples_by_language:
            self.examples_by_language[example.language] = []
        self.examples_by_language[example.language].append(example.id)

    def get_example(self, example_id: str) -> Optional[CodeExample]:
        """Get an example by ID."""
        return self.examples.get(example_id)

    def get_examples_by_tag(self, tag: str) -> List[CodeExample]:
        """Get all examples with a specific tag."""
        example_ids = self.examples_by_tag.get(tag, [])
        return [self.examples[eid] for eid in example_ids]

    def get_examples_by_language(
        self,
        language: Language
    ) -> List[CodeExample]:
        """Get all examples in a specific language."""
        example_ids = self.examples_by_language.get(language, [])
        return [self.examples[eid] for eid in example_ids]

    def search_examples(
        self,
        query: str,
        language: Optional[Language] = None
    ) -> List[CodeExample]:
        """Search examples by title or description."""
        results = []
        query_lower = query.lower()

        for example in self.examples.values():
            if language and example.language != language:
                continue

            if (query_lower in example.title.lower() or
                query_lower in example.description.lower()):
                results.append(example)

        return results


class CodeExampleValidator:
    """
    Validate code examples for syntax and execution.
    """

    def __init__(self):
        self.validators: Dict[Language, Callable] = {
            Language.PYTHON: self._validate_python,
            Language.TYPESCRIPT: self._validate_typescript,
            Language.JAVASCRIPT: self._validate_javascript,
            Language.GO: self._validate_go,
            Language.BASH: self._validate_bash
        }

    def validate_syntax(self, example: CodeExample) -> Dict[str, Any]:
        """Validate code syntax."""
        validator = self.validators.get(example.language)
        if not validator:
            return {
                "valid": True,
                "message": f"No validator for {example.language.value}"
            }

        return validator(example.code, syntax_only=True)

    def validate_execution(
        self,
        example: CodeExample,
        timeout: int = 30
    ) -> Dict[str, Any]:
        """Validate code execution."""
        if not example.runnable:
            return {
                "valid": True,
                "message": "Example marked as not runnable"
            }

        validator = self.validators.get(example.language)
        if not validator:
            return {
                "valid": True,
                "message": f"No validator for {example.language.value}"
            }

        result = validator(
            example.code,
            syntax_only=False,
            timeout=timeout,
            env=example.environment_variables
        )

        # Check expected output if provided
        if example.expected_output and result.get("valid"):
            if example.expected_output not in result.get("output", ""):
                result["valid"] = False
                result["message"] = (
                    f"Output mismatch. Expected: {example.expected_output}"
                )

        return result

    def _validate_python(
        self,
        code: str,
        syntax_only: bool = True,
        timeout: int = 30,
        env: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """Validate Python code."""
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.py',
            delete=False
        ) as f:
            f.write(code)
            temp_file = f.name

        try:
            if syntax_only:
                result = subprocess.run(
                    ['python', '-m', 'py_compile', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                return {
                    "valid": result.returncode == 0,
                    "message": result.stderr if result.returncode != 0 else "Syntax valid"
                }
            else:
                environment = os.environ.copy()
                if env:
                    environment.update(env)

                result = subprocess.run(
                    ['python', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    env=environment
                )
                return {
                    "valid": result.returncode == 0,
                    "output": result.stdout,
                    "error": result.stderr,
                    "message": "Execution successful" if result.returncode == 0 else result.stderr
                }
        finally:
            os.unlink(temp_file)

    def _validate_typescript(
        self,
        code: str,
        syntax_only: bool = True,
        timeout: int = 30,
        env: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """Validate TypeScript code."""
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.ts',
            delete=False
        ) as f:
            f.write(code)
            temp_file = f.name

        try:
            result = subprocess.run(
                ['npx', 'tsc', '--noEmit', temp_file],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return {
                "valid": result.returncode == 0,
                "message": result.stderr if result.returncode != 0 else "Syntax valid"
            }
        finally:
            os.unlink(temp_file)

    def _validate_javascript(
        self,
        code: str,
        syntax_only: bool = True,
        timeout: int = 30,
        env: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """Validate JavaScript code."""
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.js',
            delete=False
        ) as f:
            f.write(code)
            temp_file = f.name

        try:
            if syntax_only:
                result = subprocess.run(
                    ['node', '--check', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            else:
                environment = os.environ.copy()
                if env:
                    environment.update(env)

                result = subprocess.run(
                    ['node', temp_file],
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    env=environment
                )

            return {
                "valid": result.returncode == 0,
                "output": result.stdout if not syntax_only else None,
                "message": result.stderr if result.returncode != 0 else "Valid"
            }
        finally:
            os.unlink(temp_file)

    def _validate_go(
        self,
        code: str,
        syntax_only: bool = True,
        timeout: int = 30,
        env: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """Validate Go code."""
        with tempfile.TemporaryDirectory() as tmpdir:
            go_file = os.path.join(tmpdir, 'main.go')
            with open(go_file, 'w') as f:
                f.write(code)

            result = subprocess.run(
                ['go', 'build', '-o', '/dev/null', go_file],
                capture_output=True,
                text=True,
                timeout=timeout
            )
            return {
                "valid": result.returncode == 0,
                "message": result.stderr if result.returncode != 0 else "Syntax valid"
            }

    def _validate_bash(
        self,
        code: str,
        syntax_only: bool = True,
        timeout: int = 30,
        env: Dict[str, str] = None
    ) -> Dict[str, Any]:
        """Validate Bash code."""
        result = subprocess.run(
            ['bash', '-n', '-c', code],
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return {
            "valid": result.returncode == 0,
            "message": result.stderr if result.returncode != 0 else "Syntax valid"
        }


class CodeSnippetFormatter:
    """
    Format code snippets for documentation.
    """

    def __init__(self):
        self.line_number_format = "{:4d} | {}"

    def format_with_line_numbers(self, code: str) -> str:
        """Add line numbers to code."""
        lines = code.split('\n')
        numbered_lines = [
            self.line_number_format.format(i + 1, line)
            for i, line in enumerate(lines)
        ]
        return '\n'.join(numbered_lines)

    def highlight_lines(
        self,
        code: str,
        highlight_lines: List[int]
    ) -> str:
        """Mark specific lines for highlighting."""
        lines = code.split('\n')
        result_lines = []

        for i, line in enumerate(lines, 1):
            if i in highlight_lines:
                result_lines.append(f">>> {line}")
            else:
                result_lines.append(f"    {line}")

        return '\n'.join(result_lines)

    def create_diff_view(
        self,
        before: str,
        after: str,
        context_lines: int = 3
    ) -> str:
        """Create a diff view between two code versions."""
        import difflib

        before_lines = before.splitlines(keepends=True)
        after_lines = after.splitlines(keepends=True)

        diff = difflib.unified_diff(
            before_lines,
            after_lines,
            fromfile='before',
            tofile='after',
            n=context_lines
        )

        return ''.join(diff)

    def extract_snippet(
        self,
        code: str,
        start_marker: str,
        end_marker: str
    ) -> str:
        """Extract a snippet between markers."""
        pattern = re.compile(
            rf'{re.escape(start_marker)}(.*?){re.escape(end_marker)}',
            re.DOTALL
        )
        match = pattern.search(code)

        if match:
            return match.group(1).strip()
        return code

    def format_for_markdown(
        self,
        example: CodeExample
    ) -> str:
        """Format code example for Markdown documentation."""
        markdown = f"""### {example.title}

{example.description}

"""
        if example.prerequisites:
            markdown += "**Prerequisites:**\n"
            for prereq in example.prerequisites:
                markdown += f"- {prereq}\n"
            markdown += "\n"

        if example.dependencies:
            markdown += "**Dependencies:**\n```bash\n"
            if example.language == Language.PYTHON:
                markdown += f"pip install {' '.join(example.dependencies)}\n"
            elif example.language in [Language.TYPESCRIPT, Language.JAVASCRIPT]:
                markdown += f"npm install {' '.join(example.dependencies)}\n"
            markdown += "```\n\n"

        markdown += f"""```{example.language.value}
{example.code}
```
"""

        if example.expected_output:
            markdown += f"""
**Expected Output:**
```
{example.expected_output}
```
"""

        return markdown
```

---

## 4. Documentation Platform Integration

### 4.1 Documentation Site Generator

```python
"""
Documentation site generation and deployment.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path
import json
import yaml
import shutil
import os


@dataclass
class SiteConfig:
    """Configuration for documentation site."""
    name: str
    base_url: str
    logo: str
    favicon: str
    primary_color: str
    navigation: Dict[str, Any]
    footer: Dict[str, Any]
    social_links: Dict[str, str] = field(default_factory=dict)
    analytics_id: Optional[str] = None
    search_enabled: bool = True
    version_selector: bool = True
    dark_mode: bool = True


class DocusaurusSiteGenerator:
    """
    Generate Docusaurus documentation site.
    """

    def __init__(self, output_dir: str, config: SiteConfig):
        self.output_dir = Path(output_dir)
        self.config = config

    def generate_docusaurus_config(self) -> Dict:
        """Generate docusaurus.config.js content."""
        return {
            "title": self.config.name,
            "url": self.config.base_url,
            "baseUrl": "/",
            "onBrokenLinks": "throw",
            "onBrokenMarkdownLinks": "warn",
            "favicon": self.config.favicon,
            "organizationName": "your-org",
            "projectName": "docs",
            "presets": [
                [
                    "@docusaurus/preset-classic",
                    {
                        "docs": {
                            "sidebarPath": "./sidebars.js",
                            "editUrl": "https://github.com/your-org/docs/edit/main/"
                        },
                        "blog": False,
                        "theme": {
                            "customCss": "./src/css/custom.css"
                        }
                    }
                ]
            ],
            "themeConfig": {
                "navbar": {
                    "title": self.config.name,
                    "logo": {
                        "alt": f"{self.config.name} Logo",
                        "src": self.config.logo
                    },
                    "items": self._generate_navbar_items()
                },
                "footer": {
                    "style": "dark",
                    "links": self._generate_footer_links(),
                    "copyright": f"Copyright © {2024} {self.config.name}"
                },
                "prism": {
                    "theme": "prismjs/themes/prism-tomorrow",
                    "additionalLanguages": [
                        "python", "go", "rust", "java", "bash"
                    ]
                },
                "colorMode": {
                    "defaultMode": "light",
                    "disableSwitch": not self.config.dark_mode
                }
            }
        }

    def _generate_navbar_items(self) -> List[Dict]:
        """Generate navbar items from configuration."""
        items = []
        for section, data in self.config.navigation.items():
            items.append({
                "type": "doc",
                "docId": f"{section}/index",
                "position": "left",
                "label": data.get("title", section.title())
            })

        if self.config.version_selector:
            items.append({
                "type": "docsVersionDropdown",
                "position": "right"
            })

        return items

    def _generate_footer_links(self) -> List[Dict]:
        """Generate footer links."""
        return [
            {
                "title": "Docs",
                "items": [
                    {"label": "Getting Started", "to": "/docs/intro"},
                    {"label": "API Reference", "to": "/docs/api-reference"}
                ]
            },
            {
                "title": "Community",
                "items": [
                    {"label": "Discord", "href": self.config.social_links.get("discord", "#")},
                    {"label": "GitHub", "href": self.config.social_links.get("github", "#")}
                ]
            },
            {
                "title": "More",
                "items": [
                    {"label": "Blog", "href": "/blog"},
                    {"label": "Status", "href": "https://status.example.com"}
                ]
            }
        ]

    def generate_sidebars(self) -> Dict:
        """Generate sidebars.js content."""
        sidebars = {}

        for section, data in self.config.navigation.items():
            sidebar_items = []

            for category in data.get("categories", []):
                sidebar_items.append({
                    "type": "category",
                    "label": category["title"],
                    "items": [
                        {
                            "type": "doc",
                            "id": f"{section}/{item['slug']}"
                        }
                        for item in category.get("items", [])
                    ]
                })

            sidebars[f"{section}Sidebar"] = sidebar_items

        return sidebars

    def generate_custom_css(self) -> str:
        """Generate custom CSS."""
        return f"""
:root {{
  --ifm-color-primary: {self.config.primary_color};
  --ifm-color-primary-dark: {self._darken_color(self.config.primary_color)};
  --ifm-color-primary-darker: {self._darken_color(self.config.primary_color, 0.2)};
  --ifm-color-primary-darkest: {self._darken_color(self.config.primary_color, 0.3)};
  --ifm-color-primary-light: {self._lighten_color(self.config.primary_color)};
  --ifm-color-primary-lighter: {self._lighten_color(self.config.primary_color, 0.2)};
  --ifm-color-primary-lightest: {self._lighten_color(self.config.primary_color, 0.3)};
  --ifm-code-font-size: 95%;
}}

.docusaurus-highlight-code-line {{
  background-color: rgba(0, 0, 0, 0.1);
  display: block;
  margin: 0 calc(-1 * var(--ifm-pre-padding));
  padding: 0 var(--ifm-pre-padding);
}}

html[data-theme='dark'] .docusaurus-highlight-code-line {{
  background-color: rgba(0, 0, 0, 0.3);
}}

/* API Playground Styles */
.api-playground {{
  border: 1px solid var(--ifm-color-emphasis-300);
  border-radius: 8px;
  padding: 1rem;
  margin: 1rem 0;
}}

.api-playground__header {{
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-bottom: 1rem;
}}

.api-playground__method {{
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.875rem;
}}

.api-playground__method--get {{
  background-color: #61affe;
  color: white;
}}

.api-playground__method--post {{
  background-color: #49cc90;
  color: white;
}}

.api-playground__method--put {{
  background-color: #fca130;
  color: white;
}}

.api-playground__method--delete {{
  background-color: #f93e3e;
  color: white;
}}
"""

    def _darken_color(self, hex_color: str, amount: float = 0.1) -> str:
        """Darken a hex color."""
        # Simplified implementation
        return hex_color

    def _lighten_color(self, hex_color: str, amount: float = 0.1) -> str:
        """Lighten a hex color."""
        # Simplified implementation
        return hex_color

    def build_site(self, docs_dir: str) -> None:
        """Build the complete documentation site."""
        # Create output directory structure
        self.output_dir.mkdir(parents=True, exist_ok=True)
        (self.output_dir / "docs").mkdir(exist_ok=True)
        (self.output_dir / "src" / "css").mkdir(parents=True, exist_ok=True)

        # Copy documentation files
        if os.path.exists(docs_dir):
            shutil.copytree(
                docs_dir,
                self.output_dir / "docs",
                dirs_exist_ok=True
            )

        # Generate configuration files
        config = self.generate_docusaurus_config()
        with open(self.output_dir / "docusaurus.config.js", "w") as f:
            f.write(f"module.exports = {json.dumps(config, indent=2)};")

        sidebars = self.generate_sidebars()
        with open(self.output_dir / "sidebars.js", "w") as f:
            f.write(f"module.exports = {json.dumps(sidebars, indent=2)};")

        css = self.generate_custom_css()
        with open(self.output_dir / "src" / "css" / "custom.css", "w") as f:
            f.write(css)

        # Generate package.json
        package_json = {
            "name": self.config.name.lower().replace(" ", "-"),
            "version": "1.0.0",
            "private": True,
            "scripts": {
                "docusaurus": "docusaurus",
                "start": "docusaurus start",
                "build": "docusaurus build",
                "serve": "docusaurus serve",
                "deploy": "docusaurus deploy"
            },
            "dependencies": {
                "@docusaurus/core": "^3.0.0",
                "@docusaurus/preset-classic": "^3.0.0",
                "prism-react-renderer": "^2.0.0",
                "react": "^18.2.0",
                "react-dom": "^18.2.0"
            }
        }
        with open(self.output_dir / "package.json", "w") as f:
            json.dump(package_json, f, indent=2)


class ReadTheDocsGenerator:
    """
    Generate ReadTheDocs/Sphinx documentation.
    """

    def __init__(self, output_dir: str, project_name: str):
        self.output_dir = Path(output_dir)
        self.project_name = project_name

    def generate_conf_py(self) -> str:
        """Generate Sphinx conf.py."""
        return f'''
# Configuration file for Sphinx documentation builder.

project = "{self.project_name}"
copyright = "2024, {self.project_name} Team"
author = "{self.project_name} Team"

extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.viewcode",
    "sphinx.ext.napoleon",
    "sphinx_rtd_theme",
    "myst_parser",
    "sphinx_copybutton",
    "sphinxcontrib.openapi"
]

templates_path = ["_templates"]
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]

html_theme = "sphinx_rtd_theme"
html_static_path = ["_static"]

# MyST Parser settings
myst_enable_extensions = [
    "colon_fence",
    "deflist",
    "html_admonition",
    "html_image",
    "smartquotes",
    "substitution",
    "tasklist"
]

# Napoleon settings for Google/NumPy style docstrings
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = True

# AutoDoc settings
autodoc_default_options = {{
    "members": True,
    "member-order": "bysource",
    "special-members": "__init__",
    "undoc-members": True,
    "exclude-members": "__weakref__"
}}
'''

    def generate_index_rst(self, sections: List[Dict]) -> str:
        """Generate index.rst."""
        rst = f"""
{self.project_name} Documentation
{"=" * (len(self.project_name) + 14)}

Welcome to the {self.project_name} documentation.

.. toctree::
   :maxdepth: 2
   :caption: Contents:

"""
        for section in sections:
            rst += f"   {section['path']}\n"

        rst += """

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
"""
        return rst

    def generate_readthedocs_yaml(self) -> Dict:
        """Generate .readthedocs.yaml configuration."""
        return {
            "version": 2,
            "build": {
                "os": "ubuntu-22.04",
                "tools": {
                    "python": "3.11"
                }
            },
            "sphinx": {
                "configuration": "docs/conf.py"
            },
            "python": {
                "install": [
                    {"requirements": "docs/requirements.txt"}
                ]
            }
        }

    def build_site(self, docs_content: Dict[str, str]) -> None:
        """Build the ReadTheDocs site structure."""
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Write conf.py
        with open(self.output_dir / "conf.py", "w") as f:
            f.write(self.generate_conf_py())

        # Write documentation files
        sections = []
        for path, content in docs_content.items():
            file_path = self.output_dir / path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, "w") as f:
                f.write(content)
            sections.append({"path": path.replace(".rst", "").replace(".md", "")})

        # Write index.rst
        with open(self.output_dir / "index.rst", "w") as f:
            f.write(self.generate_index_rst(sections))

        # Write requirements.txt
        requirements = [
            "sphinx>=7.0.0",
            "sphinx-rtd-theme>=2.0.0",
            "myst-parser>=2.0.0",
            "sphinx-copybutton>=0.5.0",
            "sphinxcontrib-openapi>=0.8.0"
        ]
        with open(self.output_dir / "requirements.txt", "w") as f:
            f.write("\n".join(requirements))

        # Write .readthedocs.yaml
        with open(self.output_dir.parent / ".readthedocs.yaml", "w") as f:
            yaml.dump(self.generate_readthedocs_yaml(), f)
```

### 4.2 Documentation Search

```python
"""
Documentation search implementation.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
import json
import re
from datetime import datetime


@dataclass
class SearchDocument:
    """A document indexed for search."""
    id: str
    title: str
    content: str
    url: str
    section: str
    tags: List[str] = field(default_factory=list)
    headings: List[str] = field(default_factory=list)
    last_updated: datetime = field(default_factory=datetime.utcnow)


@dataclass
class SearchResult:
    """A search result."""
    document: SearchDocument
    score: float
    highlights: List[str]
    matched_terms: List[str]


class DocumentationSearchIndex:
    """
    Search index for documentation.
    """

    def __init__(self):
        self.documents: Dict[str, SearchDocument] = {}
        self.inverted_index: Dict[str, List[str]] = {}
        self.stopwords = {
            "the", "a", "an", "and", "or", "but", "in", "on", "at",
            "to", "for", "of", "with", "by", "from", "is", "are",
            "was", "were", "be", "been", "being", "have", "has",
            "had", "do", "does", "did", "will", "would", "could",
            "should", "may", "might", "must", "shall", "can"
        }

    def add_document(self, doc: SearchDocument) -> None:
        """Add a document to the search index."""
        self.documents[doc.id] = doc

        # Tokenize and index content
        tokens = self._tokenize(
            f"{doc.title} {doc.content} {' '.join(doc.tags)} {' '.join(doc.headings)}"
        )

        for token in tokens:
            if token not in self.inverted_index:
                self.inverted_index[token] = []
            if doc.id not in self.inverted_index[token]:
                self.inverted_index[token].append(doc.id)

    def remove_document(self, doc_id: str) -> None:
        """Remove a document from the index."""
        if doc_id not in self.documents:
            return

        doc = self.documents[doc_id]
        tokens = self._tokenize(
            f"{doc.title} {doc.content} {' '.join(doc.tags)}"
        )

        for token in tokens:
            if token in self.inverted_index:
                self.inverted_index[token] = [
                    d for d in self.inverted_index[token] if d != doc_id
                ]

        del self.documents[doc_id]

    def search(
        self,
        query: str,
        limit: int = 10,
        section_filter: Optional[str] = None,
        tag_filter: Optional[List[str]] = None
    ) -> List[SearchResult]:
        """Search documents."""
        query_tokens = self._tokenize(query)

        if not query_tokens:
            return []

        # Find matching documents
        doc_scores: Dict[str, float] = {}
        doc_matched_terms: Dict[str, List[str]] = {}

        for token in query_tokens:
            matching_docs = self.inverted_index.get(token, [])

            for doc_id in matching_docs:
                if doc_id not in doc_scores:
                    doc_scores[doc_id] = 0
                    doc_matched_terms[doc_id] = []

                doc = self.documents[doc_id]

                # Calculate score with boosting
                score = 1.0

                # Title match boost
                if token.lower() in doc.title.lower():
                    score += 5.0

                # Heading match boost
                for heading in doc.headings:
                    if token.lower() in heading.lower():
                        score += 2.0
                        break

                # Tag match boost
                if token.lower() in [t.lower() for t in doc.tags]:
                    score += 3.0

                doc_scores[doc_id] += score
                doc_matched_terms[doc_id].append(token)

        # Apply filters
        filtered_docs = []
        for doc_id, score in doc_scores.items():
            doc = self.documents[doc_id]

            if section_filter and doc.section != section_filter:
                continue

            if tag_filter:
                doc_tags_lower = [t.lower() for t in doc.tags]
                if not any(t.lower() in doc_tags_lower for t in tag_filter):
                    continue

            filtered_docs.append((doc_id, score))

        # Sort by score
        filtered_docs.sort(key=lambda x: x[1], reverse=True)

        # Build results
        results = []
        for doc_id, score in filtered_docs[:limit]:
            doc = self.documents[doc_id]
            highlights = self._generate_highlights(
                doc.content,
                doc_matched_terms[doc_id]
            )

            results.append(SearchResult(
                document=doc,
                score=score,
                highlights=highlights,
                matched_terms=doc_matched_terms[doc_id]
            ))

        return results

    def suggest(self, prefix: str, limit: int = 5) -> List[str]:
        """Suggest completions for a search prefix."""
        prefix_lower = prefix.lower()
        suggestions = []

        for token in self.inverted_index.keys():
            if token.startswith(prefix_lower):
                suggestions.append(token)

        # Sort by frequency (number of documents)
        suggestions.sort(
            key=lambda t: len(self.inverted_index[t]),
            reverse=True
        )

        return suggestions[:limit]

    def _tokenize(self, text: str) -> List[str]:
        """Tokenize text for indexing/searching."""
        # Convert to lowercase and split on non-alphanumeric
        tokens = re.findall(r'\w+', text.lower())

        # Remove stopwords and short tokens
        tokens = [
            t for t in tokens
            if t not in self.stopwords and len(t) > 2
        ]

        return tokens

    def _generate_highlights(
        self,
        content: str,
        terms: List[str],
        context_length: int = 100
    ) -> List[str]:
        """Generate highlighted snippets showing matches."""
        highlights = []
        content_lower = content.lower()

        for term in terms:
            pos = content_lower.find(term.lower())

            if pos != -1:
                start = max(0, pos - context_length // 2)
                end = min(len(content), pos + len(term) + context_length // 2)

                snippet = content[start:end]

                # Add ellipsis if truncated
                if start > 0:
                    snippet = "..." + snippet
                if end < len(content):
                    snippet = snippet + "..."

                # Highlight the term
                snippet = re.sub(
                    f'({re.escape(term)})',
                    r'<mark>\1</mark>',
                    snippet,
                    flags=re.IGNORECASE
                )

                highlights.append(snippet)

        return highlights[:3]  # Return top 3 highlights

    def export_index(self) -> Dict:
        """Export search index for client-side search."""
        return {
            "documents": {
                doc_id: {
                    "id": doc.id,
                    "title": doc.title,
                    "url": doc.url,
                    "section": doc.section,
                    "tags": doc.tags,
                    "headings": doc.headings,
                    "content_preview": doc.content[:200] + "..."
                }
                for doc_id, doc in self.documents.items()
            },
            "index": self.inverted_index
        }
```

---

## 5. Documentation Lifecycle Management

### 5.1 Version Management

```python
"""
Documentation versioning and lifecycle management.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import json


class DocumentStatus(Enum):
    """Document lifecycle status."""
    DRAFT = "draft"
    REVIEW = "review"
    PUBLISHED = "published"
    DEPRECATED = "deprecated"
    ARCHIVED = "archived"


@dataclass
class DocumentVersion:
    """A version of a document."""
    version: str
    status: DocumentStatus
    content: str
    created_at: datetime
    published_at: Optional[datetime] = None
    deprecated_at: Optional[datetime] = None
    author: Optional[str] = None
    reviewers: List[str] = field(default_factory=list)
    changelog: str = ""


@dataclass
class VersionedDocument:
    """A document with version history."""
    id: str
    path: str
    title: str
    current_version: str
    versions: Dict[str, DocumentVersion] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)


class DocumentVersionManager:
    """
    Manage document versions and lifecycle.
    """

    def __init__(self):
        self.documents: Dict[str, VersionedDocument] = {}

    def create_document(
        self,
        doc_id: str,
        path: str,
        title: str,
        content: str,
        author: str
    ) -> VersionedDocument:
        """Create a new versioned document."""
        version = DocumentVersion(
            version="1.0.0",
            status=DocumentStatus.DRAFT,
            content=content,
            created_at=datetime.utcnow(),
            author=author
        )

        doc = VersionedDocument(
            id=doc_id,
            path=path,
            title=title,
            current_version="1.0.0",
            versions={"1.0.0": version}
        )

        self.documents[doc_id] = doc
        return doc

    def create_new_version(
        self,
        doc_id: str,
        content: str,
        version_type: str = "minor",
        author: str = None,
        changelog: str = ""
    ) -> DocumentVersion:
        """Create a new version of a document."""
        doc = self.documents.get(doc_id)
        if not doc:
            raise ValueError(f"Document {doc_id} not found")

        current = doc.versions[doc.current_version]
        new_version_str = self._increment_version(
            doc.current_version,
            version_type
        )

        new_version = DocumentVersion(
            version=new_version_str,
            status=DocumentStatus.DRAFT,
            content=content,
            created_at=datetime.utcnow(),
            author=author or current.author,
            changelog=changelog
        )

        doc.versions[new_version_str] = new_version
        doc.current_version = new_version_str

        return new_version

    def submit_for_review(
        self,
        doc_id: str,
        version: str,
        reviewers: List[str]
    ) -> None:
        """Submit a document version for review."""
        doc = self.documents.get(doc_id)
        if not doc:
            raise ValueError(f"Document {doc_id} not found")

        doc_version = doc.versions.get(version)
        if not doc_version:
            raise ValueError(f"Version {version} not found")

        if doc_version.status != DocumentStatus.DRAFT:
            raise ValueError("Only draft documents can be submitted for review")

        doc_version.status = DocumentStatus.REVIEW
        doc_version.reviewers = reviewers

    def publish_version(
        self,
        doc_id: str,
        version: str
    ) -> None:
        """Publish a document version."""
        doc = self.documents.get(doc_id)
        if not doc:
            raise ValueError(f"Document {doc_id} not found")

        doc_version = doc.versions.get(version)
        if not doc_version:
            raise ValueError(f"Version {version} not found")

        if doc_version.status not in [DocumentStatus.DRAFT, DocumentStatus.REVIEW]:
            raise ValueError("Only draft or review documents can be published")

        doc_version.status = DocumentStatus.PUBLISHED
        doc_version.published_at = datetime.utcnow()

    def deprecate_version(
        self,
        doc_id: str,
        version: str,
        replacement_version: Optional[str] = None
    ) -> None:
        """Deprecate a document version."""
        doc = self.documents.get(doc_id)
        if not doc:
            raise ValueError(f"Document {doc_id} not found")

        doc_version = doc.versions.get(version)
        if not doc_version:
            raise ValueError(f"Version {version} not found")

        doc_version.status = DocumentStatus.DEPRECATED
        doc_version.deprecated_at = datetime.utcnow()

        if replacement_version:
            doc.current_version = replacement_version

    def get_published_versions(
        self,
        doc_id: str
    ) -> List[DocumentVersion]:
        """Get all published versions of a document."""
        doc = self.documents.get(doc_id)
        if not doc:
            return []

        return [
            v for v in doc.versions.values()
            if v.status == DocumentStatus.PUBLISHED
        ]

    def _increment_version(
        self,
        version: str,
        version_type: str
    ) -> str:
        """Increment version number."""
        parts = version.split(".")
        major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2])

        if version_type == "major":
            major += 1
            minor = 0
            patch = 0
        elif version_type == "minor":
            minor += 1
            patch = 0
        else:  # patch
            patch += 1

        return f"{major}.{minor}.{patch}"


class DocumentReviewWorkflow:
    """
    Manage documentation review workflows.
    """

    def __init__(self, version_manager: DocumentVersionManager):
        self.version_manager = version_manager
        self.reviews: Dict[str, List[Dict]] = {}  # doc_id -> reviews

    def request_review(
        self,
        doc_id: str,
        version: str,
        reviewer: str,
        deadline: Optional[datetime] = None
    ) -> str:
        """Request a review for a document."""
        review_id = f"{doc_id}-{version}-{reviewer}"

        if doc_id not in self.reviews:
            self.reviews[doc_id] = []

        review = {
            "id": review_id,
            "version": version,
            "reviewer": reviewer,
            "status": "pending",
            "requested_at": datetime.utcnow().isoformat(),
            "deadline": deadline.isoformat() if deadline else None,
            "comments": []
        }

        self.reviews[doc_id].append(review)
        return review_id

    def add_review_comment(
        self,
        review_id: str,
        comment: str,
        line_number: Optional[int] = None,
        severity: str = "suggestion"
    ) -> None:
        """Add a comment to a review."""
        for doc_reviews in self.reviews.values():
            for review in doc_reviews:
                if review["id"] == review_id:
                    review["comments"].append({
                        "text": comment,
                        "line_number": line_number,
                        "severity": severity,
                        "created_at": datetime.utcnow().isoformat()
                    })
                    return

    def approve_review(
        self,
        review_id: str,
        notes: str = ""
    ) -> None:
        """Approve a review."""
        self._update_review_status(review_id, "approved", notes)

    def request_changes(
        self,
        review_id: str,
        notes: str
    ) -> None:
        """Request changes in a review."""
        self._update_review_status(review_id, "changes_requested", notes)

    def _update_review_status(
        self,
        review_id: str,
        status: str,
        notes: str
    ) -> None:
        """Update review status."""
        for doc_reviews in self.reviews.values():
            for review in doc_reviews:
                if review["id"] == review_id:
                    review["status"] = status
                    review["completed_at"] = datetime.utcnow().isoformat()
                    review["notes"] = notes
                    return

    def get_pending_reviews(
        self,
        reviewer: Optional[str] = None
    ) -> List[Dict]:
        """Get all pending reviews."""
        pending = []

        for doc_reviews in self.reviews.values():
            for review in doc_reviews:
                if review["status"] == "pending":
                    if reviewer is None or review["reviewer"] == reviewer:
                        pending.append(review)

        return pending
```

### 5.2 Documentation Quality Metrics

```python
"""
Documentation quality metrics and analytics.
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import defaultdict
import re


@dataclass
class PageAnalytics:
    """Analytics for a documentation page."""
    page_id: str
    page_views: int = 0
    unique_visitors: int = 0
    avg_time_on_page: float = 0.0  # seconds
    bounce_rate: float = 0.0
    scroll_depth: float = 0.0  # percentage
    search_appearances: int = 0
    search_click_rate: float = 0.0
    feedback_score: float = 0.0
    feedback_count: int = 0


@dataclass
class ContentQualityScore:
    """Quality score for documentation content."""
    readability_score: float  # Flesch-Kincaid or similar
    completeness_score: float  # Based on required sections
    code_coverage_score: float  # Percentage of concepts with examples
    freshness_score: float  # Based on last update
    link_health_score: float  # Percentage of working links
    overall_score: float


class DocumentationAnalytics:
    """
    Track and analyze documentation usage and quality.
    """

    def __init__(self):
        self.page_analytics: Dict[str, PageAnalytics] = {}
        self.search_queries: List[Dict] = []
        self.feedback: Dict[str, List[Dict]] = defaultdict(list)
        self.events: List[Dict] = []

    def track_page_view(
        self,
        page_id: str,
        visitor_id: str,
        time_on_page: float,
        scroll_depth: float,
        referrer: Optional[str] = None
    ) -> None:
        """Track a page view."""
        if page_id not in self.page_analytics:
            self.page_analytics[page_id] = PageAnalytics(page_id=page_id)

        analytics = self.page_analytics[page_id]
        analytics.page_views += 1

        # Update rolling averages
        n = analytics.page_views
        analytics.avg_time_on_page = (
            (analytics.avg_time_on_page * (n - 1) + time_on_page) / n
        )
        analytics.scroll_depth = (
            (analytics.scroll_depth * (n - 1) + scroll_depth) / n
        )

        self.events.append({
            "type": "page_view",
            "page_id": page_id,
            "visitor_id": visitor_id,
            "time_on_page": time_on_page,
            "scroll_depth": scroll_depth,
            "referrer": referrer,
            "timestamp": datetime.utcnow().isoformat()
        })

    def track_search(
        self,
        query: str,
        results_count: int,
        clicked_result: Optional[str] = None
    ) -> None:
        """Track a search query."""
        self.search_queries.append({
            "query": query,
            "results_count": results_count,
            "clicked_result": clicked_result,
            "timestamp": datetime.utcnow().isoformat()
        })

        if clicked_result:
            if clicked_result in self.page_analytics:
                self.page_analytics[clicked_result].search_appearances += 1

    def record_feedback(
        self,
        page_id: str,
        rating: int,  # 1-5
        comment: Optional[str] = None,
        category: Optional[str] = None
    ) -> None:
        """Record user feedback for a page."""
        self.feedback[page_id].append({
            "rating": rating,
            "comment": comment,
            "category": category,
            "timestamp": datetime.utcnow().isoformat()
        })

        # Update page analytics
        if page_id not in self.page_analytics:
            self.page_analytics[page_id] = PageAnalytics(page_id=page_id)

        analytics = self.page_analytics[page_id]
        total_rating = analytics.feedback_score * analytics.feedback_count + rating
        analytics.feedback_count += 1
        analytics.feedback_score = total_rating / analytics.feedback_count

    def get_top_pages(
        self,
        metric: str = "page_views",
        limit: int = 10
    ) -> List[Dict]:
        """Get top performing pages by metric."""
        pages = []

        for page_id, analytics in self.page_analytics.items():
            value = getattr(analytics, metric, 0)
            pages.append({
                "page_id": page_id,
                "value": value
            })

        pages.sort(key=lambda x: x["value"], reverse=True)
        return pages[:limit]

    def get_search_gaps(self, min_searches: int = 5) -> List[Dict]:
        """Find search queries with no or low click-through."""
        query_stats = defaultdict(lambda: {"count": 0, "clicks": 0, "no_results": 0})

        for search in self.search_queries:
            query = search["query"].lower()
            query_stats[query]["count"] += 1

            if search["clicked_result"]:
                query_stats[query]["clicks"] += 1

            if search["results_count"] == 0:
                query_stats[query]["no_results"] += 1

        gaps = []
        for query, stats in query_stats.items():
            if stats["count"] >= min_searches:
                ctr = stats["clicks"] / stats["count"]
                if ctr < 0.3 or stats["no_results"] > 0:  # Low CTR or no results
                    gaps.append({
                        "query": query,
                        "searches": stats["count"],
                        "click_through_rate": ctr,
                        "no_results_count": stats["no_results"]
                    })

        gaps.sort(key=lambda x: x["searches"], reverse=True)
        return gaps

    def get_feedback_summary(
        self,
        page_id: Optional[str] = None
    ) -> Dict:
        """Get feedback summary for a page or all pages."""
        if page_id:
            page_feedback = self.feedback.get(page_id, [])
            return self._summarize_feedback(page_feedback)

        all_feedback = []
        for fb_list in self.feedback.values():
            all_feedback.extend(fb_list)

        return self._summarize_feedback(all_feedback)

    def _summarize_feedback(self, feedback: List[Dict]) -> Dict:
        """Summarize feedback data."""
        if not feedback:
            return {
                "count": 0,
                "average_rating": 0,
                "rating_distribution": {},
                "categories": {}
            }

        ratings = [f["rating"] for f in feedback]
        categories = defaultdict(int)

        for f in feedback:
            if f.get("category"):
                categories[f["category"]] += 1

        return {
            "count": len(feedback),
            "average_rating": sum(ratings) / len(ratings),
            "rating_distribution": {
                i: ratings.count(i) for i in range(1, 6)
            },
            "categories": dict(categories)
        }


class ContentQualityAnalyzer:
    """
    Analyze documentation content quality.
    """

    def __init__(self):
        self.required_sections = [
            "overview",
            "prerequisites",
            "installation",
            "usage",
            "examples",
            "troubleshooting",
            "related"
        ]

    def analyze_content(
        self,
        content: str,
        last_updated: datetime
    ) -> ContentQualityScore:
        """Analyze content quality."""
        readability = self._calculate_readability(content)
        completeness = self._calculate_completeness(content)
        code_coverage = self._calculate_code_coverage(content)
        freshness = self._calculate_freshness(last_updated)
        link_health = self._calculate_link_health(content)

        # Weighted overall score
        overall = (
            readability * 0.2 +
            completeness * 0.25 +
            code_coverage * 0.25 +
            freshness * 0.15 +
            link_health * 0.15
        )

        return ContentQualityScore(
            readability_score=readability,
            completeness_score=completeness,
            code_coverage_score=code_coverage,
            freshness_score=freshness,
            link_health_score=link_health,
            overall_score=overall
        )

    def _calculate_readability(self, content: str) -> float:
        """Calculate readability score (simplified Flesch-Kincaid)."""
        sentences = re.split(r'[.!?]+', content)
        words = re.findall(r'\w+', content)

        if not sentences or not words:
            return 0.0

        avg_sentence_length = len(words) / len(sentences)

        # Syllable estimation (simplified)
        syllables = sum(max(1, len(re.findall(r'[aeiou]', w.lower()))) for w in words)
        avg_syllables = syllables / len(words) if words else 0

        # Simplified Flesch Reading Ease (0-100, higher is better)
        score = 206.835 - 1.015 * avg_sentence_length - 84.6 * avg_syllables

        # Normalize to 0-1
        return max(0, min(1, score / 100))

    def _calculate_completeness(self, content: str) -> float:
        """Calculate section completeness score."""
        content_lower = content.lower()
        found_sections = 0

        for section in self.required_sections:
            # Check for section headers
            patterns = [
                f"# {section}",
                f"## {section}",
                f"### {section}",
                f"**{section}**"
            ]

            for pattern in patterns:
                if pattern in content_lower:
                    found_sections += 1
                    break

        return found_sections / len(self.required_sections)

    def _calculate_code_coverage(self, content: str) -> float:
        """Calculate code example coverage."""
        # Count code blocks
        code_blocks = re.findall(r'```[\s\S]*?```', content)

        # Count key concepts (headers)
        headers = re.findall(r'^#+\s+.+$', content, re.MULTILINE)

        if not headers:
            return 1.0 if code_blocks else 0.0

        # Aim for at least one code block per two headers
        target_blocks = len(headers) / 2
        coverage = len(code_blocks) / target_blocks if target_blocks > 0 else 1.0

        return min(1.0, coverage)

    def _calculate_freshness(self, last_updated: datetime) -> float:
        """Calculate content freshness score."""
        days_old = (datetime.utcnow() - last_updated).days

        # Score decreases over 180 days
        if days_old <= 30:
            return 1.0
        elif days_old <= 90:
            return 0.8
        elif days_old <= 180:
            return 0.6
        elif days_old <= 365:
            return 0.4
        else:
            return 0.2

    def _calculate_link_health(self, content: str) -> float:
        """Calculate link health (placeholder - would need HTTP checks)."""
        # Find all links
        links = re.findall(r'\[([^\]]+)\]\(([^)]+)\)', content)

        if not links:
            return 1.0

        # In production, would verify each link
        # For now, assume all links are valid
        return 1.0

    def get_improvement_suggestions(
        self,
        score: ContentQualityScore
    ) -> List[str]:
        """Get suggestions for improving content quality."""
        suggestions = []

        if score.readability_score < 0.6:
            suggestions.append(
                "Improve readability: Use shorter sentences and simpler words"
            )

        if score.completeness_score < 0.8:
            suggestions.append(
                "Add missing sections: Ensure all standard sections are present"
            )

        if score.code_coverage_score < 0.7:
            suggestions.append(
                "Add more code examples: Include practical examples for key concepts"
            )

        if score.freshness_score < 0.6:
            suggestions.append(
                "Update content: Review and refresh outdated information"
            )

        if score.link_health_score < 0.9:
            suggestions.append(
                "Fix broken links: Verify and update all internal and external links"
            )

        return suggestions
```

---

## 6. Documentation Automation

### 6.1 Auto-generation from Code

```python
"""
Automatic documentation generation from code.
"""

from typing import Dict, List, Optional, Any, Type
from dataclasses import dataclass, field
import inspect
import ast
import re


@dataclass
class ExtractedDocstring:
    """Extracted docstring information."""
    summary: str
    description: str
    parameters: List[Dict[str, str]]
    returns: Optional[Dict[str, str]]
    raises: List[Dict[str, str]]
    examples: List[str]
    notes: List[str]


class DocstringParser:
    """
    Parse docstrings in various formats.
    """

    def parse_google_style(self, docstring: str) -> ExtractedDocstring:
        """Parse Google-style docstrings."""
        if not docstring:
            return ExtractedDocstring(
                summary="",
                description="",
                parameters=[],
                returns=None,
                raises=[],
                examples=[],
                notes=[]
            )

        lines = docstring.strip().split('\n')

        # Extract summary (first paragraph)
        summary_lines = []
        description_lines = []
        current_section = "summary"

        parameters = []
        returns = None
        raises = []
        examples = []
        notes = []

        i = 0
        while i < len(lines):
            line = lines[i].strip()

            if not line:
                if current_section == "summary":
                    current_section = "description"
                i += 1
                continue

            # Check for section headers
            if line.endswith(':') and line[:-1] in [
                'Args', 'Arguments', 'Parameters',
                'Returns', 'Return', 'Yields',
                'Raises', 'Exceptions',
                'Examples', 'Example',
                'Notes', 'Note'
            ]:
                section_name = line[:-1].lower()
                if section_name in ['args', 'arguments', 'parameters']:
                    current_section = "parameters"
                elif section_name in ['returns', 'return', 'yields']:
                    current_section = "returns"
                elif section_name in ['raises', 'exceptions']:
                    current_section = "raises"
                elif section_name in ['examples', 'example']:
                    current_section = "examples"
                elif section_name in ['notes', 'note']:
                    current_section = "notes"
                i += 1
                continue

            if current_section == "summary":
                summary_lines.append(line)
            elif current_section == "description":
                description_lines.append(line)
            elif current_section == "parameters":
                param = self._parse_parameter_line(line, lines, i)
                if param:
                    parameters.append(param)
            elif current_section == "returns":
                returns = self._parse_return_line(line)
            elif current_section == "raises":
                exc = self._parse_raises_line(line)
                if exc:
                    raises.append(exc)
            elif current_section == "examples":
                if line.startswith('>>>') or line.startswith('```'):
                    examples.append(line)
            elif current_section == "notes":
                notes.append(line)

            i += 1

        return ExtractedDocstring(
            summary=' '.join(summary_lines),
            description=' '.join(description_lines),
            parameters=parameters,
            returns=returns,
            raises=raises,
            examples=examples,
            notes=notes
        )

    def _parse_parameter_line(
        self,
        line: str,
        lines: List[str],
        index: int
    ) -> Optional[Dict[str, str]]:
        """Parse a parameter line."""
        match = re.match(r'(\w+)\s*(?:\(([^)]+)\))?\s*:\s*(.+)', line)
        if match:
            return {
                "name": match.group(1),
                "type": match.group(2) or "",
                "description": match.group(3)
            }
        return None

    def _parse_return_line(self, line: str) -> Optional[Dict[str, str]]:
        """Parse a return line."""
        match = re.match(r'(?:(\w+)\s*:\s*)?(.+)', line)
        if match:
            return {
                "type": match.group(1) or "",
                "description": match.group(2)
            }
        return None

    def _parse_raises_line(self, line: str) -> Optional[Dict[str, str]]:
        """Parse a raises line."""
        match = re.match(r'(\w+)\s*:\s*(.+)', line)
        if match:
            return {
                "exception": match.group(1),
                "description": match.group(2)
            }
        return None


class AutoDocGenerator:
    """
    Generate documentation from Python code.
    """

    def __init__(self):
        self.parser = DocstringParser()

    def generate_module_docs(
        self,
        module: Any,
        include_private: bool = False
    ) -> str:
        """Generate documentation for a module."""
        doc = f"# {module.__name__}\n\n"

        if module.__doc__:
            doc += f"{module.__doc__}\n\n"

        # Document classes
        classes = inspect.getmembers(module, inspect.isclass)
        for name, cls in classes:
            if not include_private and name.startswith('_'):
                continue
            if cls.__module__ != module.__name__:
                continue

            doc += self.generate_class_docs(cls)

        # Document functions
        functions = inspect.getmembers(module, inspect.isfunction)
        for name, func in functions:
            if not include_private and name.startswith('_'):
                continue
            if func.__module__ != module.__name__:
                continue

            doc += self.generate_function_docs(func)

        return doc

    def generate_class_docs(self, cls: Type) -> str:
        """Generate documentation for a class."""
        doc = f"## class {cls.__name__}\n\n"

        # Class docstring
        if cls.__doc__:
            parsed = self.parser.parse_google_style(cls.__doc__)
            doc += f"{parsed.summary}\n\n"
            if parsed.description:
                doc += f"{parsed.description}\n\n"

        # Document methods
        methods = inspect.getmembers(cls, predicate=inspect.isfunction)

        for name, method in methods:
            if name.startswith('_') and name != '__init__':
                continue

            doc += self.generate_method_docs(name, method)

        return doc

    def generate_method_docs(self, name: str, method: Any) -> str:
        """Generate documentation for a method."""
        doc = f"### {name}\n\n"

        # Signature
        try:
            sig = inspect.signature(method)
            doc += f"```python\n{name}{sig}\n```\n\n"
        except (ValueError, TypeError):
            pass

        # Docstring
        if method.__doc__:
            parsed = self.parser.parse_google_style(method.__doc__)
            doc += f"{parsed.summary}\n\n"

            if parsed.parameters:
                doc += "**Parameters:**\n\n"
                for param in parsed.parameters:
                    type_str = f" ({param['type']})" if param['type'] else ""
                    doc += f"- `{param['name']}`{type_str}: {param['description']}\n"
                doc += "\n"

            if parsed.returns:
                doc += f"**Returns:** {parsed.returns['description']}\n\n"

            if parsed.raises:
                doc += "**Raises:**\n\n"
                for exc in parsed.raises:
                    doc += f"- `{exc['exception']}`: {exc['description']}\n"
                doc += "\n"

            if parsed.examples:
                doc += "**Example:**\n\n```python\n"
                doc += '\n'.join(parsed.examples)
                doc += "\n```\n\n"

        return doc

    def generate_function_docs(self, func: Any) -> str:
        """Generate documentation for a function."""
        return self.generate_method_docs(func.__name__, func)


class OpenAPIDocGenerator:
    """
    Generate documentation from OpenAPI specifications.
    """

    def __init__(self, spec: Dict):
        self.spec = spec

    def generate_endpoint_docs(self, path: str, method: str) -> str:
        """Generate documentation for an API endpoint."""
        endpoint = self.spec.get("paths", {}).get(path, {}).get(method, {})

        if not endpoint:
            return ""

        doc = f"## {method.upper()} {path}\n\n"
        doc += f"{endpoint.get('summary', '')}\n\n"
        doc += f"{endpoint.get('description', '')}\n\n"

        # Parameters
        params = endpoint.get("parameters", [])
        if params:
            doc += "### Parameters\n\n"
            doc += "| Name | In | Type | Required | Description |\n"
            doc += "|------|-----|------|----------|-------------|\n"

            for param in params:
                required = "Yes" if param.get("required") else "No"
                schema = param.get("schema", {})
                param_type = schema.get("type", "any")

                doc += f"| `{param['name']}` | {param['in']} | "
                doc += f"{param_type} | {required} | {param.get('description', '')} |\n"

            doc += "\n"

        # Request body
        request_body = endpoint.get("requestBody", {})
        if request_body:
            doc += "### Request Body\n\n"

            content = request_body.get("content", {})
            for content_type, content_spec in content.items():
                doc += f"**Content-Type:** `{content_type}`\n\n"

                schema = content_spec.get("schema", {})
                if "$ref" in schema:
                    ref_name = schema["$ref"].split("/")[-1]
                    doc += f"Schema: [{ref_name}](#{ref_name.lower()})\n\n"
                else:
                    doc += f"```json\n{self._format_schema(schema)}\n```\n\n"

        # Responses
        responses = endpoint.get("responses", {})
        if responses:
            doc += "### Responses\n\n"

            for status_code, response in responses.items():
                doc += f"#### {status_code} {response.get('description', '')}\n\n"

                content = response.get("content", {})
                for content_type, content_spec in content.items():
                    schema = content_spec.get("schema", {})
                    example = content_spec.get("example")

                    if example:
                        doc += f"```json\n{self._format_json(example)}\n```\n\n"

        return doc

    def generate_full_docs(self) -> str:
        """Generate complete API documentation."""
        info = self.spec.get("info", {})

        doc = f"# {info.get('title', 'API Documentation')}\n\n"
        doc += f"{info.get('description', '')}\n\n"
        doc += f"**Version:** {info.get('version', '1.0.0')}\n\n"

        # Servers
        servers = self.spec.get("servers", [])
        if servers:
            doc += "## Base URLs\n\n"
            for server in servers:
                doc += f"- {server.get('url')} - {server.get('description', '')}\n"
            doc += "\n"

        # Authentication
        security_schemes = self.spec.get("components", {}).get("securitySchemes", {})
        if security_schemes:
            doc += "## Authentication\n\n"
            for name, scheme in security_schemes.items():
                doc += f"### {name}\n\n"
                doc += f"- **Type:** {scheme.get('type')}\n"
                if scheme.get("scheme"):
                    doc += f"- **Scheme:** {scheme.get('scheme')}\n"
                if scheme.get("bearerFormat"):
                    doc += f"- **Format:** {scheme.get('bearerFormat')}\n"
                doc += "\n"

        # Endpoints by tag
        paths = self.spec.get("paths", {})
        tags = self.spec.get("tags", [])

        for tag in tags:
            doc += f"## {tag.get('name')}\n\n"
            doc += f"{tag.get('description', '')}\n\n"

            for path, methods in paths.items():
                for method, endpoint in methods.items():
                    if tag.get("name") in endpoint.get("tags", []):
                        doc += self.generate_endpoint_docs(path, method)

        # Schemas
        schemas = self.spec.get("components", {}).get("schemas", {})
        if schemas:
            doc += "## Schemas\n\n"
            for name, schema in schemas.items():
                doc += f"### {name}\n\n"
                doc += f"```json\n{self._format_schema(schema)}\n```\n\n"

        return doc

    def _format_schema(self, schema: Dict) -> str:
        """Format a JSON schema for display."""
        import json
        return json.dumps(schema, indent=2)

    def _format_json(self, obj: Any) -> str:
        """Format an object as JSON."""
        import json
        return json.dumps(obj, indent=2)
```

---

## 7. Best Practices and Patterns

### 7.1 Documentation Style Guide

```yaml
# Documentation Style Guide

writing_principles:
  clarity:
    - Use simple, direct language
    - Avoid jargon unless necessary (define it when used)
    - One idea per sentence
    - Active voice preferred

  consistency:
    - Follow established terminology
    - Use consistent formatting throughout
    - Maintain uniform code style in examples
    - Standard section ordering

formatting_standards:
  headings:
    - Use sentence case for headings
    - Maximum 3 levels of nesting
    - Descriptive, action-oriented titles

  code_blocks:
    - Always specify language
    - Include necessary imports
    - Add comments for complex logic
    - Test all examples before publishing

  links:
    - Use descriptive link text (not "click here")
    - Link to most specific relevant page
    - Check links regularly
    - Prefer relative links for internal docs

content_structure:
  every_page:
    - Clear title
    - Brief introduction (2-3 sentences)
    - Prerequisites (if applicable)
    - Main content
    - Related resources

  tutorials:
    - Learning objectives upfront
    - Step-by-step instructions
    - Code examples for each step
    - Verification steps
    - Complete working example

  api_reference:
    - Method signature
    - Parameter descriptions
    - Return value description
    - Error codes
    - Multiple code examples

code_examples:
  requirements:
    - Complete and runnable
    - Realistic use cases
    - Error handling included
    - Best practices demonstrated

  structure:
    - Minimal dependencies
    - Clear variable names
    - Appropriate comments
    - Expected output shown

versioning:
  api_versions:
    - Document all supported versions
    - Clear migration guides
    - Deprecation warnings
    - Version-specific examples

  content_versions:
    - Last updated date
    - Version compatibility
    - Change history

accessibility:
  - Alt text for images
  - Color-blind friendly diagrams
  - Screen reader compatible
  - Keyboard navigable examples
```

### 7.2 Documentation Checklist

```python
"""
Documentation quality checklist.
"""

from dataclasses import dataclass
from typing import List, Dict


@dataclass
class ChecklistItem:
    """A checklist item."""
    category: str
    item: str
    required: bool
    description: str


DOCUMENTATION_CHECKLIST = [
    # Content completeness
    ChecklistItem(
        category="Content",
        item="Clear title",
        required=True,
        description="Page has a clear, descriptive title"
    ),
    ChecklistItem(
        category="Content",
        item="Introduction",
        required=True,
        description="Brief introduction explaining what the page covers"
    ),
    ChecklistItem(
        category="Content",
        item="Prerequisites",
        required=False,
        description="List of prerequisites if applicable"
    ),
    ChecklistItem(
        category="Content",
        item="Step-by-step instructions",
        required=True,
        description="Clear, numbered steps for tutorials/guides"
    ),
    ChecklistItem(
        category="Content",
        item="Code examples",
        required=True,
        description="Relevant, working code examples"
    ),
    ChecklistItem(
        category="Content",
        item="Expected outcomes",
        required=True,
        description="Clear description of expected results"
    ),
    ChecklistItem(
        category="Content",
        item="Troubleshooting section",
        required=False,
        description="Common issues and solutions"
    ),
    ChecklistItem(
        category="Content",
        item="Related resources",
        required=True,
        description="Links to related documentation"
    ),

    # Technical accuracy
    ChecklistItem(
        category="Technical",
        item="Code tested",
        required=True,
        description="All code examples have been tested and work"
    ),
    ChecklistItem(
        category="Technical",
        item="Version correct",
        required=True,
        description="Version numbers and requirements are accurate"
    ),
    ChecklistItem(
        category="Technical",
        item="API accuracy",
        required=True,
        description="API parameters and responses are accurate"
    ),
    ChecklistItem(
        category="Technical",
        item="Links verified",
        required=True,
        description="All links have been verified to work"
    ),

    # Style and formatting
    ChecklistItem(
        category="Style",
        item="Consistent terminology",
        required=True,
        description="Uses consistent terms throughout"
    ),
    ChecklistItem(
        category="Style",
        item="Proper formatting",
        required=True,
        description="Follows formatting guidelines"
    ),
    ChecklistItem(
        category="Style",
        item="Grammar and spelling",
        required=True,
        description="No grammatical or spelling errors"
    ),
    ChecklistItem(
        category="Style",
        item="Active voice",
        required=False,
        description="Uses active voice where appropriate"
    ),

    # Accessibility
    ChecklistItem(
        category="Accessibility",
        item="Image alt text",
        required=True,
        description="All images have descriptive alt text"
    ),
    ChecklistItem(
        category="Accessibility",
        item="Code block labels",
        required=True,
        description="Code blocks have language labels"
    ),
    ChecklistItem(
        category="Accessibility",
        item="Heading hierarchy",
        required=True,
        description="Proper heading hierarchy (h1 > h2 > h3)"
    ),

    # Metadata
    ChecklistItem(
        category="Metadata",
        item="Last updated date",
        required=True,
        description="Document has accurate last updated date"
    ),
    ChecklistItem(
        category="Metadata",
        item="Author/owner",
        required=False,
        description="Document has assigned owner"
    ),
    ChecklistItem(
        category="Metadata",
        item="Keywords",
        required=True,
        description="Relevant keywords for search"
    )
]


def evaluate_documentation(
    content: str,
    metadata: Dict
) -> Dict[str, List[Dict]]:
    """Evaluate documentation against checklist."""
    results = {
        "passed": [],
        "failed": [],
        "warnings": []
    }

    for item in DOCUMENTATION_CHECKLIST:
        status = _check_item(item, content, metadata)

        if status == "pass":
            results["passed"].append({
                "category": item.category,
                "item": item.item
            })
        elif status == "fail" and item.required:
            results["failed"].append({
                "category": item.category,
                "item": item.item,
                "description": item.description
            })
        elif status == "fail":
            results["warnings"].append({
                "category": item.category,
                "item": item.item,
                "description": item.description
            })

    return results


def _check_item(
    item: ChecklistItem,
    content: str,
    metadata: Dict
) -> str:
    """Check a single checklist item."""
    # Simplified checks - in production would be more sophisticated

    content_lower = content.lower()

    checks = {
        "Clear title": lambda: bool(metadata.get("title")),
        "Introduction": lambda: len(content) > 100,
        "Prerequisites": lambda: "prerequisite" in content_lower or "before you begin" in content_lower,
        "Step-by-step instructions": lambda: any(
            f"step {i}" in content_lower or f"{i}." in content
            for i in range(1, 6)
        ),
        "Code examples": lambda: "```" in content,
        "Expected outcomes": lambda: "expect" in content_lower or "result" in content_lower,
        "Troubleshooting section": lambda: "troubleshoot" in content_lower or "common issues" in content_lower,
        "Related resources": lambda: "related" in content_lower or "see also" in content_lower,
        "Code tested": lambda: True,  # Would need external verification
        "Version correct": lambda: True,  # Would need external verification
        "API accuracy": lambda: True,  # Would need external verification
        "Links verified": lambda: True,  # Would need external verification
        "Consistent terminology": lambda: True,  # Would need NLP analysis
        "Proper formatting": lambda: "#" in content,  # Has headers
        "Grammar and spelling": lambda: True,  # Would need spellcheck
        "Active voice": lambda: True,  # Would need NLP analysis
        "Image alt text": lambda: "![" not in content or "![" in content and "](" in content,
        "Code block labels": lambda: "```" not in content or "```python" in content or "```javascript" in content,
        "Heading hierarchy": lambda: "# " in content,
        "Last updated date": lambda: bool(metadata.get("last_updated")),
        "Author/owner": lambda: bool(metadata.get("author")),
        "Keywords": lambda: bool(metadata.get("keywords"))
    }

    check_func = checks.get(item.item, lambda: True)

    try:
        return "pass" if check_func() else "fail"
    except Exception:
        return "fail"
```

---

## Summary

This Developer Documentation Guide provides comprehensive frameworks for:

1. **Documentation Architecture** - Structured approach to organizing documentation with clear type definitions and content templates

2. **API Documentation** - OpenAPI specification management and interactive documentation components

3. **Code Examples** - Repository, validation, and formatting systems for maintaining high-quality code examples

4. **Platform Integration** - Generators for Docusaurus and ReadTheDocs with search functionality

5. **Lifecycle Management** - Version control, review workflows, and deprecation management

6. **Quality Metrics** - Analytics, quality scoring, and improvement tracking

7. **Automation** - Auto-generation from code and OpenAPI specifications

Key principles:
- **Developer-first**: Write for the developer experience
- **Consistency**: Maintain uniform style and structure
- **Testability**: Validate all code examples
- **Discoverability**: Enable efficient search and navigation
- **Freshness**: Keep documentation up-to-date with code changes

---

> **Navigation**
> [← 12.2 SDK Design](12.2_sdk_client_library_guide.md) | **[Index](../README.md#15-repository-structure)** | [12.4 User Feedback →](12.4_user_feedback_iteration_guide.md)
