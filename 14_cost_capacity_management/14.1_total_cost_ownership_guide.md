> **Navigation** | [← 13.5 Runbooks](../13_operations_reliability/13.5_operational_runbooks_guide.md) | [14.2 Cloud Cost Optimization →](14.2_cloud_cost_optimization_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | Cloud billing access &#124; Platform architecture &#124; Financial planning |
> | **Related** | [14.2 Cloud Cost Optimization](14.2_cloud_cost_optimization_guide.md) &#124; [10.4 Cost Monitoring](../10_monitoring_observability/10.4_cost_monitoring_optimization_guide.md) |
> | **Next** | [14.2 Cloud Cost Optimization](14.2_cloud_cost_optimization_guide.md) |

# 14.1 Total Cost of Ownership (TCO) Guide

## Document Information
- **Version**: 1.0
- **Last Updated**: 2024-01-15
- **Owner**: Finance and Platform Engineering Teams
- **Classification**: Internal

## Purpose and Scope

This guide provides a comprehensive framework for calculating, tracking, and optimizing the Total Cost of Ownership for the Multi-Cloud RAG Platform. It covers infrastructure costs, LLM API expenses, operational overhead, and cost allocation methodologies.

## Prerequisites

- Access to cloud billing consoles (AWS, GCP, Azure)
- Access to LLM provider billing dashboards
- Understanding of platform architecture
- Financial planning access

## 1. TCO Framework

### 1.1 Cost Categories and Model

```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Union
from enum import Enum
from datetime import datetime, timedelta
from decimal import Decimal
import json


class CostCategory(Enum):
    """High-level cost categories."""
    INFRASTRUCTURE = "infrastructure"
    LLM_API = "llm_api"
    DATA_STORAGE = "data_storage"
    NETWORKING = "networking"
    PERSONNEL = "personnel"
    SOFTWARE_LICENSES = "software_licenses"
    SUPPORT_MAINTENANCE = "support_maintenance"
    SECURITY_COMPLIANCE = "security_compliance"


class CostType(Enum):
    """Types of costs."""
    FIXED = "fixed"           # Monthly fixed costs
    VARIABLE = "variable"     # Usage-based costs
    SEMI_VARIABLE = "semi_variable"  # Base + usage
    ONE_TIME = "one_time"     # Initial setup costs


class CloudProvider(Enum):
    """Cloud providers."""
    AWS = "aws"
    GCP = "gcp"
    AZURE = "azure"
    ON_PREMISE = "on_premise"


@dataclass
class CostItem:
    """Individual cost line item."""
    item_id: str
    name: str
    category: CostCategory
    cost_type: CostType
    provider: Optional[CloudProvider]
    amount: Decimal
    currency: str = "USD"
    period: str = "monthly"  # monthly, yearly, one-time
    quantity: float = 1.0
    unit: str = "unit"
    tags: Dict[str, str] = field(default_factory=dict)
    notes: str = ""

    @property
    def total_amount(self) -> Decimal:
        return self.amount * Decimal(str(self.quantity))


@dataclass
class CostAllocation:
    """Cost allocation to teams/projects."""
    allocation_id: str
    cost_item_id: str
    allocated_to: str  # team, project, or cost center
    percentage: float
    amount: Decimal
    allocation_method: str  # direct, proportional, fixed


class TCOModel:
    """Total Cost of Ownership calculation model."""

    def __init__(self):
        self.cost_items: Dict[str, CostItem] = {}
        self.allocations: List[CostAllocation] = []
        self.amortization_periods: Dict[str, int] = {}  # item_id -> months

    def add_cost_item(self, item: CostItem):
        """Add a cost item to the model."""
        self.cost_items[item.item_id] = item

    def set_amortization(self, item_id: str, months: int):
        """Set amortization period for one-time costs."""
        self.amortization_periods[item_id] = months

    def calculate_monthly_cost(self, category: Optional[CostCategory] = None) -> Decimal:
        """Calculate total monthly cost."""
        total = Decimal("0")

        for item in self.cost_items.values():
            if category and item.category != category:
                continue

            if item.period == "monthly":
                total += item.total_amount
            elif item.period == "yearly":
                total += item.total_amount / 12
            elif item.period == "one-time":
                months = self.amortization_periods.get(item.item_id, 36)
                total += item.total_amount / months

        return total

    def calculate_annual_cost(self, category: Optional[CostCategory] = None) -> Decimal:
        """Calculate total annual cost."""
        return self.calculate_monthly_cost(category) * 12

    def get_cost_breakdown(self) -> Dict[str, Decimal]:
        """Get cost breakdown by category."""
        breakdown = {}
        for category in CostCategory:
            breakdown[category.value] = self.calculate_monthly_cost(category)
        return breakdown

    def get_provider_breakdown(self) -> Dict[str, Decimal]:
        """Get cost breakdown by cloud provider."""
        breakdown: Dict[str, Decimal] = {}

        for item in self.cost_items.values():
            provider = item.provider.value if item.provider else "other"
            if provider not in breakdown:
                breakdown[provider] = Decimal("0")

            if item.period == "monthly":
                breakdown[provider] += item.total_amount
            elif item.period == "yearly":
                breakdown[provider] += item.total_amount / 12

        return breakdown

    def allocate_cost(
        self,
        item_id: str,
        allocations: Dict[str, float]
    ):
        """Allocate a cost item to multiple cost centers."""
        item = self.cost_items.get(item_id)
        if not item:
            raise ValueError(f"Cost item {item_id} not found")

        total_percentage = sum(allocations.values())
        if abs(total_percentage - 100) > 0.01:
            raise ValueError(f"Allocations must sum to 100%, got {total_percentage}%")

        for allocated_to, percentage in allocations.items():
            amount = item.total_amount * Decimal(str(percentage / 100))
            self.allocations.append(CostAllocation(
                allocation_id=f"{item_id}-{allocated_to}",
                cost_item_id=item_id,
                allocated_to=allocated_to,
                percentage=percentage,
                amount=amount,
                allocation_method="proportional"
            ))

    def get_allocation_summary(self) -> Dict[str, Decimal]:
        """Get cost summary by allocation target."""
        summary: Dict[str, Decimal] = {}

        for allocation in self.allocations:
            if allocation.allocated_to not in summary:
                summary[allocation.allocated_to] = Decimal("0")
            summary[allocation.allocated_to] += allocation.amount

        return summary


class TCOCalculator:
    """Calculator for comprehensive TCO analysis."""

    def __init__(self, model: TCOModel):
        self.model = model

    def calculate_unit_economics(
        self,
        monthly_queries: int,
        monthly_documents_processed: int
    ) -> Dict:
        """Calculate unit economics."""
        total_monthly = self.model.calculate_monthly_cost()

        return {
            "total_monthly_cost": float(total_monthly),
            "cost_per_query": float(total_monthly / monthly_queries) if monthly_queries else 0,
            "cost_per_document": float(total_monthly / monthly_documents_processed) if monthly_documents_processed else 0,
            "cost_per_1k_queries": float(total_monthly / monthly_queries * 1000) if monthly_queries else 0
        }

    def calculate_roi(
        self,
        revenue_per_month: Decimal,
        initial_investment: Decimal,
        growth_rate: float = 0.05
    ) -> Dict:
        """Calculate return on investment metrics."""
        monthly_cost = self.model.calculate_monthly_cost()
        monthly_profit = revenue_per_month - monthly_cost

        # Simple payback period
        if monthly_profit > 0:
            payback_months = int(initial_investment / monthly_profit)
        else:
            payback_months = -1  # Never pays back

        # Annual metrics
        annual_cost = monthly_cost * 12
        annual_revenue = revenue_per_month * 12
        annual_profit = monthly_profit * 12

        # 3-year projection with growth
        projected_profit_3y = Decimal("0")
        current_revenue = annual_revenue
        for year in range(3):
            projected_profit_3y += current_revenue - annual_cost
            current_revenue *= Decimal(str(1 + growth_rate))

        roi_3y = ((projected_profit_3y - initial_investment) / initial_investment * 100
                  if initial_investment > 0 else Decimal("0"))

        return {
            "monthly_cost": float(monthly_cost),
            "monthly_profit": float(monthly_profit),
            "payback_period_months": payback_months,
            "annual_roi": float((annual_profit / annual_cost * 100) if annual_cost > 0 else 0),
            "3_year_roi": float(roi_3y),
            "break_even_queries": int(monthly_cost / (revenue_per_month / 1000000))
        }

    def project_costs(
        self,
        months: int,
        growth_rate: float = 0.1,
        efficiency_improvement: float = 0.02
    ) -> List[Dict]:
        """Project costs over time."""
        projections = []
        base_cost = self.model.calculate_monthly_cost()

        for month in range(months):
            # Apply growth to variable costs
            growth_factor = Decimal(str((1 + growth_rate) ** (month / 12)))
            # Apply efficiency improvements
            efficiency_factor = Decimal(str((1 - efficiency_improvement) ** (month / 12)))

            fixed_cost = Decimal("0")
            variable_cost = Decimal("0")

            for item in self.model.cost_items.values():
                monthly_amount = item.total_amount
                if item.period == "yearly":
                    monthly_amount = item.total_amount / 12

                if item.cost_type == CostType.FIXED:
                    fixed_cost += monthly_amount
                elif item.cost_type == CostType.VARIABLE:
                    variable_cost += monthly_amount * growth_factor * efficiency_factor
                elif item.cost_type == CostType.SEMI_VARIABLE:
                    # 60% fixed, 40% variable
                    fixed_cost += monthly_amount * Decimal("0.6")
                    variable_cost += monthly_amount * Decimal("0.4") * growth_factor * efficiency_factor

            total = fixed_cost + variable_cost

            projections.append({
                "month": month + 1,
                "fixed_cost": float(fixed_cost),
                "variable_cost": float(variable_cost),
                "total_cost": float(total),
                "growth_factor": float(growth_factor),
                "efficiency_factor": float(efficiency_factor)
            })

        return projections

    def compare_scenarios(
        self,
        scenarios: Dict[str, TCOModel]
    ) -> Dict:
        """Compare TCO across different scenarios."""
        comparison = {}

        for name, model in scenarios.items():
            monthly = model.calculate_monthly_cost()
            annual = model.calculate_annual_cost()

            comparison[name] = {
                "monthly_cost": float(monthly),
                "annual_cost": float(annual),
                "breakdown": {k: float(v) for k, v in model.get_cost_breakdown().items()},
                "provider_breakdown": {k: float(v) for k, v in model.get_provider_breakdown().items()}
            }

        # Calculate differences from baseline
        if "baseline" in comparison:
            baseline = comparison["baseline"]["annual_cost"]
            for name, data in comparison.items():
                if name != "baseline":
                    data["difference_from_baseline"] = data["annual_cost"] - baseline
                    data["percentage_difference"] = (
                        (data["annual_cost"] - baseline) / baseline * 100
                        if baseline > 0 else 0
                    )

        return comparison
```

### 1.2 Infrastructure Cost Tracking

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from decimal import Decimal
import boto3


@dataclass
class ComputeCost:
    """Compute resource cost."""
    instance_type: str
    count: int
    hourly_rate: Decimal
    utilization: float
    reserved: bool = False
    spot: bool = False

    @property
    def monthly_cost(self) -> Decimal:
        hours_per_month = 730
        base_cost = self.hourly_rate * self.count * hours_per_month
        if self.reserved:
            return base_cost * Decimal("0.6")  # 40% savings
        if self.spot:
            return base_cost * Decimal("0.3")  # 70% savings
        return base_cost


@dataclass
class StorageCost:
    """Storage cost."""
    storage_type: str
    size_gb: float
    rate_per_gb: Decimal
    iops: Optional[int] = None
    iops_rate: Optional[Decimal] = None

    @property
    def monthly_cost(self) -> Decimal:
        base = Decimal(str(self.size_gb)) * self.rate_per_gb
        if self.iops and self.iops_rate:
            base += self.iops * self.iops_rate
        return base


class InfrastructureCostTracker:
    """Track infrastructure costs across clouds."""

    def __init__(self):
        self.compute_costs: List[ComputeCost] = []
        self.storage_costs: List[StorageCost] = []
        self.network_costs: Dict[str, Decimal] = {}
        self.managed_service_costs: Dict[str, Decimal] = {}

    def add_compute(self, compute: ComputeCost):
        self.compute_costs.append(compute)

    def add_storage(self, storage: StorageCost):
        self.storage_costs.append(storage)

    def add_network_cost(self, name: str, monthly_cost: Decimal):
        self.network_costs[name] = monthly_cost

    def add_managed_service(self, name: str, monthly_cost: Decimal):
        self.managed_service_costs[name] = monthly_cost

    def get_total_compute_cost(self) -> Decimal:
        return sum(c.monthly_cost for c in self.compute_costs)

    def get_total_storage_cost(self) -> Decimal:
        return sum(s.monthly_cost for s in self.storage_costs)

    def get_total_network_cost(self) -> Decimal:
        return sum(self.network_costs.values())

    def get_total_managed_services_cost(self) -> Decimal:
        return sum(self.managed_service_costs.values())

    def get_infrastructure_summary(self) -> Dict:
        """Get infrastructure cost summary."""
        compute = self.get_total_compute_cost()
        storage = self.get_total_storage_cost()
        network = self.get_total_network_cost()
        managed = self.get_total_managed_services_cost()
        total = compute + storage + network + managed

        return {
            "compute": {
                "total": float(compute),
                "percentage": float(compute / total * 100) if total else 0,
                "instances": len(self.compute_costs),
                "reserved_percentage": sum(
                    1 for c in self.compute_costs if c.reserved
                ) / len(self.compute_costs) * 100 if self.compute_costs else 0
            },
            "storage": {
                "total": float(storage),
                "percentage": float(storage / total * 100) if total else 0,
                "total_size_tb": sum(s.size_gb for s in self.storage_costs) / 1024
            },
            "network": {
                "total": float(network),
                "percentage": float(network / total * 100) if total else 0
            },
            "managed_services": {
                "total": float(managed),
                "percentage": float(managed / total * 100) if total else 0,
                "services": list(self.managed_service_costs.keys())
            },
            "total_monthly": float(total)
        }


class AWSCostExplorer:
    """Fetch costs from AWS Cost Explorer."""

    def __init__(self, region: str = "us-east-1"):
        self.client = boto3.client("ce", region_name=region)

    def get_monthly_costs(
        self,
        start_date: datetime,
        end_date: datetime,
        granularity: str = "MONTHLY"
    ) -> List[Dict]:
        """Get monthly costs from AWS."""
        response = self.client.get_cost_and_usage(
            TimePeriod={
                "Start": start_date.strftime("%Y-%m-%d"),
                "End": end_date.strftime("%Y-%m-%d")
            },
            Granularity=granularity,
            Metrics=["BlendedCost", "UnblendedCost", "UsageQuantity"],
            GroupBy=[
                {"Type": "DIMENSION", "Key": "SERVICE"}
            ]
        )

        costs = []
        for result in response["ResultsByTime"]:
            period_start = result["TimePeriod"]["Start"]
            for group in result["Groups"]:
                service = group["Keys"][0]
                amount = Decimal(group["Metrics"]["BlendedCost"]["Amount"])
                costs.append({
                    "period": period_start,
                    "service": service,
                    "amount": float(amount),
                    "currency": group["Metrics"]["BlendedCost"]["Unit"]
                })

        return costs

    def get_cost_forecast(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> Dict:
        """Get cost forecast from AWS."""
        response = self.client.get_cost_forecast(
            TimePeriod={
                "Start": start_date.strftime("%Y-%m-%d"),
                "End": end_date.strftime("%Y-%m-%d")
            },
            Metric="BLENDED_COST",
            Granularity="MONTHLY"
        )

        return {
            "total_forecast": float(response["Total"]["Amount"]),
            "currency": response["Total"]["Unit"],
            "forecast_by_period": [
                {
                    "period": f["TimePeriod"]["Start"],
                    "mean": float(f["MeanValue"]),
                    "lower_bound": float(f.get("PredictionIntervalLowerBound", f["MeanValue"])),
                    "upper_bound": float(f.get("PredictionIntervalUpperBound", f["MeanValue"]))
                }
                for f in response["ForecastResultsByTime"]
            ]
        }

    def get_cost_by_tag(
        self,
        tag_key: str,
        start_date: datetime,
        end_date: datetime
    ) -> Dict[str, Decimal]:
        """Get costs grouped by a specific tag."""
        response = self.client.get_cost_and_usage(
            TimePeriod={
                "Start": start_date.strftime("%Y-%m-%d"),
                "End": end_date.strftime("%Y-%m-%d")
            },
            Granularity="MONTHLY",
            Metrics=["BlendedCost"],
            GroupBy=[
                {"Type": "TAG", "Key": tag_key}
            ]
        )

        costs_by_tag = {}
        for result in response["ResultsByTime"]:
            for group in result["Groups"]:
                tag_value = group["Keys"][0].split("$")[-1] or "untagged"
                amount = Decimal(group["Metrics"]["BlendedCost"]["Amount"])
                if tag_value in costs_by_tag:
                    costs_by_tag[tag_value] += amount
                else:
                    costs_by_tag[tag_value] = amount

        return costs_by_tag
```

## 2. LLM API Cost Tracking

### 2.1 Token-Based Cost Calculation

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime


@dataclass
class LLMPricing:
    """LLM provider pricing structure."""
    provider: str
    model: str
    input_price_per_1k: Decimal
    output_price_per_1k: Decimal
    embedding_price_per_1k: Optional[Decimal] = None
    cached_input_price_per_1k: Optional[Decimal] = None
    fine_tuning_price_per_1k: Optional[Decimal] = None


class LLMPricingRegistry:
    """Registry of LLM pricing across providers."""

    def __init__(self):
        self.pricing = self._initialize_pricing()

    def _initialize_pricing(self) -> Dict[str, LLMPricing]:
        return {
            "openai/gpt-4-turbo": LLMPricing(
                provider="openai",
                model="gpt-4-turbo",
                input_price_per_1k=Decimal("0.01"),
                output_price_per_1k=Decimal("0.03"),
                cached_input_price_per_1k=Decimal("0.005")
            ),
            "openai/gpt-4o": LLMPricing(
                provider="openai",
                model="gpt-4o",
                input_price_per_1k=Decimal("0.005"),
                output_price_per_1k=Decimal("0.015"),
                cached_input_price_per_1k=Decimal("0.0025")
            ),
            "openai/gpt-4o-mini": LLMPricing(
                provider="openai",
                model="gpt-4o-mini",
                input_price_per_1k=Decimal("0.00015"),
                output_price_per_1k=Decimal("0.0006")
            ),
            "anthropic/claude-3-opus": LLMPricing(
                provider="anthropic",
                model="claude-3-opus",
                input_price_per_1k=Decimal("0.015"),
                output_price_per_1k=Decimal("0.075")
            ),
            "anthropic/claude-3-sonnet": LLMPricing(
                provider="anthropic",
                model="claude-3-sonnet",
                input_price_per_1k=Decimal("0.003"),
                output_price_per_1k=Decimal("0.015")
            ),
            "anthropic/claude-3-haiku": LLMPricing(
                provider="anthropic",
                model="claude-3-haiku",
                input_price_per_1k=Decimal("0.00025"),
                output_price_per_1k=Decimal("0.00125")
            ),
            "openai/text-embedding-3-large": LLMPricing(
                provider="openai",
                model="text-embedding-3-large",
                input_price_per_1k=Decimal("0.00013"),
                output_price_per_1k=Decimal("0"),
                embedding_price_per_1k=Decimal("0.00013")
            ),
            "openai/text-embedding-3-small": LLMPricing(
                provider="openai",
                model="text-embedding-3-small",
                input_price_per_1k=Decimal("0.00002"),
                output_price_per_1k=Decimal("0"),
                embedding_price_per_1k=Decimal("0.00002")
            )
        }

    def get_pricing(self, provider: str, model: str) -> Optional[LLMPricing]:
        key = f"{provider}/{model}"
        return self.pricing.get(key)

    def calculate_cost(
        self,
        provider: str,
        model: str,
        input_tokens: int,
        output_tokens: int,
        cached_tokens: int = 0
    ) -> Decimal:
        """Calculate cost for a request."""
        pricing = self.get_pricing(provider, model)
        if not pricing:
            raise ValueError(f"Unknown model: {provider}/{model}")

        input_cost = (input_tokens - cached_tokens) / 1000 * pricing.input_price_per_1k
        cached_cost = (
            cached_tokens / 1000 * pricing.cached_input_price_per_1k
            if pricing.cached_input_price_per_1k else Decimal("0")
        )
        output_cost = output_tokens / 1000 * pricing.output_price_per_1k

        return Decimal(str(input_cost)) + Decimal(str(cached_cost)) + Decimal(str(output_cost))


@dataclass
class LLMUsageRecord:
    """Record of LLM API usage."""
    timestamp: datetime
    provider: str
    model: str
    request_id: str
    input_tokens: int
    output_tokens: int
    cached_tokens: int = 0
    latency_ms: int = 0
    cost: Decimal = Decimal("0")
    user_id: Optional[str] = None
    team_id: Optional[str] = None
    use_case: Optional[str] = None


class LLMCostTracker:
    """Track LLM API costs in detail."""

    def __init__(self, pricing_registry: LLMPricingRegistry):
        self.pricing = pricing_registry
        self.usage_records: List[LLMUsageRecord] = []

    def record_usage(
        self,
        provider: str,
        model: str,
        request_id: str,
        input_tokens: int,
        output_tokens: int,
        cached_tokens: int = 0,
        latency_ms: int = 0,
        user_id: Optional[str] = None,
        team_id: Optional[str] = None,
        use_case: Optional[str] = None
    ) -> LLMUsageRecord:
        """Record a usage event."""
        cost = self.pricing.calculate_cost(
            provider, model, input_tokens, output_tokens, cached_tokens
        )

        record = LLMUsageRecord(
            timestamp=datetime.utcnow(),
            provider=provider,
            model=model,
            request_id=request_id,
            input_tokens=input_tokens,
            output_tokens=output_tokens,
            cached_tokens=cached_tokens,
            latency_ms=latency_ms,
            cost=cost,
            user_id=user_id,
            team_id=team_id,
            use_case=use_case
        )

        self.usage_records.append(record)
        return record

    def get_cost_by_period(
        self,
        start: datetime,
        end: datetime
    ) -> Dict:
        """Get costs for a time period."""
        filtered = [
            r for r in self.usage_records
            if start <= r.timestamp <= end
        ]

        total_cost = sum(r.cost for r in filtered)
        total_input = sum(r.input_tokens for r in filtered)
        total_output = sum(r.output_tokens for r in filtered)
        total_cached = sum(r.cached_tokens for r in filtered)

        by_model: Dict[str, Decimal] = {}
        by_team: Dict[str, Decimal] = {}
        by_use_case: Dict[str, Decimal] = {}

        for r in filtered:
            model_key = f"{r.provider}/{r.model}"
            by_model[model_key] = by_model.get(model_key, Decimal("0")) + r.cost

            if r.team_id:
                by_team[r.team_id] = by_team.get(r.team_id, Decimal("0")) + r.cost

            if r.use_case:
                by_use_case[r.use_case] = by_use_case.get(r.use_case, Decimal("0")) + r.cost

        return {
            "period": {
                "start": start.isoformat(),
                "end": end.isoformat()
            },
            "total_cost": float(total_cost),
            "total_requests": len(filtered),
            "total_tokens": {
                "input": total_input,
                "output": total_output,
                "cached": total_cached,
                "total": total_input + total_output
            },
            "cost_by_model": {k: float(v) for k, v in by_model.items()},
            "cost_by_team": {k: float(v) for k, v in by_team.items()},
            "cost_by_use_case": {k: float(v) for k, v in by_use_case.items()},
            "average_cost_per_request": float(total_cost / len(filtered)) if filtered else 0,
            "cache_hit_rate": total_cached / total_input if total_input else 0
        }

    def get_daily_trends(self, days: int = 30) -> List[Dict]:
        """Get daily cost trends."""
        now = datetime.utcnow()
        trends = []

        for i in range(days):
            day_end = now - timedelta(days=i)
            day_start = day_end - timedelta(days=1)

            day_records = [
                r for r in self.usage_records
                if day_start <= r.timestamp <= day_end
            ]

            trends.append({
                "date": day_start.strftime("%Y-%m-%d"),
                "cost": float(sum(r.cost for r in day_records)),
                "requests": len(day_records),
                "tokens": sum(r.input_tokens + r.output_tokens for r in day_records)
            })

        return list(reversed(trends))

    def get_cost_anomalies(
        self,
        threshold_multiplier: float = 2.0
    ) -> List[Dict]:
        """Detect cost anomalies."""
        daily_trends = self.get_daily_trends(30)

        if len(daily_trends) < 7:
            return []

        costs = [d["cost"] for d in daily_trends]
        avg_cost = sum(costs) / len(costs)
        std_dev = (sum((c - avg_cost) ** 2 for c in costs) / len(costs)) ** 0.5

        anomalies = []
        for day in daily_trends:
            if day["cost"] > avg_cost + (std_dev * threshold_multiplier):
                anomalies.append({
                    "date": day["date"],
                    "cost": day["cost"],
                    "expected": avg_cost,
                    "deviation": (day["cost"] - avg_cost) / std_dev if std_dev > 0 else 0,
                    "type": "spike"
                })

        return anomalies

    def estimate_monthly_cost(self, days_sample: int = 7) -> Dict:
        """Estimate monthly cost based on recent usage."""
        now = datetime.utcnow()
        sample_start = now - timedelta(days=days_sample)

        recent = [
            r for r in self.usage_records
            if r.timestamp >= sample_start
        ]

        if not recent:
            return {"estimated_monthly": 0, "confidence": "low"}

        daily_cost = sum(r.cost for r in recent) / days_sample
        monthly_estimate = daily_cost * 30

        return {
            "estimated_monthly": float(monthly_estimate),
            "daily_average": float(daily_cost),
            "sample_days": days_sample,
            "confidence": "high" if days_sample >= 7 else "medium"
        }
```

### 2.2 LLM Cost Optimization Analyzer

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal


@dataclass
class OptimizationRecommendation:
    """A cost optimization recommendation."""
    category: str
    title: str
    description: str
    estimated_savings: Decimal
    implementation_effort: str  # low, medium, high
    priority: int  # 1-5, 1 being highest


class LLMCostOptimizer:
    """Analyze and recommend LLM cost optimizations."""

    def __init__(
        self,
        cost_tracker: LLMCostTracker,
        pricing_registry: LLMPricingRegistry
    ):
        self.tracker = cost_tracker
        self.pricing = pricing_registry

    def analyze_model_selection(
        self,
        start: datetime,
        end: datetime
    ) -> List[OptimizationRecommendation]:
        """Analyze if cheaper models could be used."""
        recommendations = []
        cost_data = self.tracker.get_cost_by_period(start, end)

        # Check for expensive model usage
        model_costs = cost_data.get("cost_by_model", {})

        for model, cost in model_costs.items():
            provider, model_name = model.split("/")

            # Check if a cheaper alternative exists
            if "gpt-4" in model_name and "mini" not in model_name:
                # Could potentially use gpt-4o-mini for some tasks
                potential_savings = Decimal(str(cost)) * Decimal("0.7")
                recommendations.append(OptimizationRecommendation(
                    category="model_selection",
                    title=f"Consider GPT-4o-mini for {model}",
                    description=f"Some {model} requests may work well with gpt-4o-mini. "
                                f"Review use cases and test with smaller model.",
                    estimated_savings=potential_savings,
                    implementation_effort="medium",
                    priority=2
                ))

            if "claude-3-opus" in model_name:
                potential_savings = Decimal(str(cost)) * Decimal("0.6")
                recommendations.append(OptimizationRecommendation(
                    category="model_selection",
                    title="Consider Claude 3 Sonnet for some Opus usage",
                    description="Claude 3 Sonnet provides 80% of Opus quality at 20% cost. "
                                "Review complex reasoning vs standard tasks.",
                    estimated_savings=potential_savings,
                    implementation_effort="medium",
                    priority=2
                ))

        return recommendations

    def analyze_caching_opportunity(
        self,
        start: datetime,
        end: datetime
    ) -> List[OptimizationRecommendation]:
        """Analyze caching opportunities."""
        recommendations = []

        records = [
            r for r in self.tracker.usage_records
            if start <= r.timestamp <= end
        ]

        if not records:
            return recommendations

        total_input = sum(r.input_tokens for r in records)
        total_cached = sum(r.cached_tokens for r in records)
        cache_rate = total_cached / total_input if total_input else 0

        if cache_rate < 0.3:
            # Low cache hit rate
            potential_savings = Decimal(str(total_input * 0.003 * 0.5))  # Assume 50% cacheable
            recommendations.append(OptimizationRecommendation(
                category="caching",
                title="Implement prompt caching",
                description=f"Current cache hit rate is {cache_rate*100:.1f}%. "
                            f"Implementing prompt caching could reduce input token costs by up to 50%.",
                estimated_savings=potential_savings,
                implementation_effort="medium",
                priority=1
            ))

        # Check for repeated system prompts
        use_case_counts: Dict[str, int] = {}
        for r in records:
            if r.use_case:
                use_case_counts[r.use_case] = use_case_counts.get(r.use_case, 0) + 1

        high_volume_cases = [uc for uc, count in use_case_counts.items() if count > 100]
        if high_volume_cases and cache_rate < 0.5:
            recommendations.append(OptimizationRecommendation(
                category="caching",
                title="Enable caching for high-volume use cases",
                description=f"Use cases {', '.join(high_volume_cases)} have high volume. "
                            f"Ensure system prompts are cached.",
                estimated_savings=Decimal("500"),  # Estimated
                implementation_effort="low",
                priority=1
            ))

        return recommendations

    def analyze_batching_opportunity(
        self,
        start: datetime,
        end: datetime
    ) -> List[OptimizationRecommendation]:
        """Analyze batching opportunities."""
        recommendations = []

        records = [
            r for r in self.tracker.usage_records
            if start <= r.timestamp <= end
        ]

        # Check for high request volume with small payloads
        small_requests = [r for r in records if r.input_tokens < 500]
        if len(small_requests) > len(records) * 0.5:
            potential_savings = Decimal(str(len(small_requests) * 0.001 * 0.3))
            recommendations.append(OptimizationRecommendation(
                category="batching",
                title="Batch small requests",
                description=f"{len(small_requests)} requests ({len(small_requests)/len(records)*100:.0f}%) "
                            f"have fewer than 500 tokens. Batching could reduce overhead.",
                estimated_savings=potential_savings,
                implementation_effort="high",
                priority=3
            ))

        return recommendations

    def analyze_provider_arbitrage(
        self,
        start: datetime,
        end: datetime
    ) -> List[OptimizationRecommendation]:
        """Analyze multi-provider cost optimization."""
        recommendations = []
        cost_data = self.tracker.get_cost_by_period(start, end)

        model_costs = cost_data.get("cost_by_model", {})

        # Check if using single provider
        providers = set(m.split("/")[0] for m in model_costs.keys())
        if len(providers) == 1:
            recommendations.append(OptimizationRecommendation(
                category="provider_arbitrage",
                title="Consider multi-provider strategy",
                description="Using a single provider limits negotiating leverage and fallback options. "
                            "Consider adding a secondary provider for redundancy and cost negotiation.",
                estimated_savings=Decimal(str(sum(float(v) for v in model_costs.values()) * 0.1)),
                implementation_effort="high",
                priority=3
            ))

        return recommendations

    def get_all_recommendations(
        self,
        start: datetime,
        end: datetime
    ) -> Dict:
        """Get all optimization recommendations."""
        all_recs = []

        all_recs.extend(self.analyze_model_selection(start, end))
        all_recs.extend(self.analyze_caching_opportunity(start, end))
        all_recs.extend(self.analyze_batching_opportunity(start, end))
        all_recs.extend(self.analyze_provider_arbitrage(start, end))

        # Sort by priority and savings
        all_recs.sort(key=lambda r: (r.priority, -float(r.estimated_savings)))

        total_potential_savings = sum(r.estimated_savings for r in all_recs)

        return {
            "recommendations": [
                {
                    "category": r.category,
                    "title": r.title,
                    "description": r.description,
                    "estimated_monthly_savings": float(r.estimated_savings),
                    "implementation_effort": r.implementation_effort,
                    "priority": r.priority
                }
                for r in all_recs
            ],
            "total_potential_monthly_savings": float(total_potential_savings),
            "recommendation_count": len(all_recs)
        }
```

## 3. Personnel and Operational Costs

### 3.1 Personnel Cost Calculator

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal
from enum import Enum


class RoleType(Enum):
    """Types of roles."""
    ENGINEERING = "engineering"
    OPERATIONS = "operations"
    MANAGEMENT = "management"
    SUPPORT = "support"


@dataclass
class RoleCost:
    """Cost of a role."""
    role_name: str
    role_type: RoleType
    base_salary: Decimal
    benefits_multiplier: float = 1.3  # Benefits typically add 30%
    headcount: float = 1.0  # Can be fractional for shared roles
    allocation_percentage: float = 100  # Percentage allocated to this project

    @property
    def fully_loaded_cost(self) -> Decimal:
        return self.base_salary * Decimal(str(self.benefits_multiplier))

    @property
    def allocated_cost(self) -> Decimal:
        return self.fully_loaded_cost * Decimal(str(self.allocation_percentage / 100)) * Decimal(str(self.headcount))


class PersonnelCostCalculator:
    """Calculate personnel costs."""

    def __init__(self):
        self.roles: List[RoleCost] = []

    def add_role(self, role: RoleCost):
        self.roles.append(role)

    def get_total_annual_cost(self) -> Decimal:
        return sum(r.allocated_cost for r in self.roles)

    def get_monthly_cost(self) -> Decimal:
        return self.get_total_annual_cost() / 12

    def get_cost_by_type(self) -> Dict[str, Decimal]:
        by_type: Dict[str, Decimal] = {}
        for role in self.roles:
            type_name = role.role_type.value
            by_type[type_name] = by_type.get(type_name, Decimal("0")) + role.allocated_cost
        return by_type

    def get_breakdown(self) -> Dict:
        """Get detailed personnel cost breakdown."""
        by_type = self.get_cost_by_type()
        total = self.get_total_annual_cost()

        return {
            "total_annual": float(total),
            "total_monthly": float(total / 12),
            "by_role_type": {k: float(v) for k, v in by_type.items()},
            "headcount": {
                "total": sum(r.headcount for r in self.roles),
                "by_type": {
                    rt.value: sum(r.headcount for r in self.roles if r.role_type == rt)
                    for rt in RoleType
                }
            },
            "roles": [
                {
                    "name": r.role_name,
                    "type": r.role_type.value,
                    "headcount": r.headcount,
                    "allocation": r.allocation_percentage,
                    "annual_cost": float(r.allocated_cost)
                }
                for r in self.roles
            ]
        }

    @classmethod
    def create_typical_team(cls) -> 'PersonnelCostCalculator':
        """Create a calculator with typical RAG platform team."""
        calc = cls()

        calc.add_role(RoleCost(
            role_name="Engineering Manager",
            role_type=RoleType.MANAGEMENT,
            base_salary=Decimal("200000"),
            headcount=0.5,
            allocation_percentage=50
        ))

        calc.add_role(RoleCost(
            role_name="Senior ML Engineer",
            role_type=RoleType.ENGINEERING,
            base_salary=Decimal("200000"),
            headcount=2
        ))

        calc.add_role(RoleCost(
            role_name="Backend Engineer",
            role_type=RoleType.ENGINEERING,
            base_salary=Decimal("170000"),
            headcount=3
        ))

        calc.add_role(RoleCost(
            role_name="Platform/DevOps Engineer",
            role_type=RoleType.ENGINEERING,
            base_salary=Decimal("175000"),
            headcount=2
        ))

        calc.add_role(RoleCost(
            role_name="SRE",
            role_type=RoleType.OPERATIONS,
            base_salary=Decimal("180000"),
            headcount=1.5
        ))

        calc.add_role(RoleCost(
            role_name="Data Engineer",
            role_type=RoleType.ENGINEERING,
            base_salary=Decimal("165000"),
            headcount=1
        ))

        calc.add_role(RoleCost(
            role_name="Technical Support",
            role_type=RoleType.SUPPORT,
            base_salary=Decimal("90000"),
            headcount=2
        ))

        return calc


class OperationalOverheadCalculator:
    """Calculate operational overhead costs."""

    def __init__(self):
        self.overhead_items: Dict[str, Decimal] = {}

    def add_overhead(self, name: str, monthly_cost: Decimal):
        self.overhead_items[name] = monthly_cost

    def get_monthly_total(self) -> Decimal:
        return sum(self.overhead_items.values())

    def get_annual_total(self) -> Decimal:
        return self.get_monthly_total() * 12

    @classmethod
    def create_typical_overhead(cls) -> 'OperationalOverheadCalculator':
        """Create calculator with typical operational overhead."""
        calc = cls()

        # Software licenses
        calc.add_overhead("Datadog/Monitoring", Decimal("5000"))
        calc.add_overhead("PagerDuty", Decimal("500"))
        calc.add_overhead("GitHub Enterprise", Decimal("2000"))
        calc.add_overhead("Slack", Decimal("1000"))
        calc.add_overhead("Security Tools", Decimal("3000"))
        calc.add_overhead("Development Tools", Decimal("2000"))

        # Support contracts
        calc.add_overhead("AWS Support", Decimal("3000"))
        calc.add_overhead("Database Support", Decimal("1500"))

        # Compliance
        calc.add_overhead("SOC 2 Audit", Decimal("2500"))
        calc.add_overhead("Security Assessments", Decimal("1000"))

        # Training
        calc.add_overhead("Training Budget", Decimal("2000"))

        return calc

    def get_breakdown(self) -> Dict:
        return {
            "monthly_total": float(self.get_monthly_total()),
            "annual_total": float(self.get_annual_total()),
            "items": {k: float(v) for k, v in self.overhead_items.items()}
        }
```

## 4. Cost Dashboards and Reporting

### 4.1 Executive Cost Dashboard

```python
from dataclasses import dataclass
from typing import Dict, List
from datetime import datetime, timedelta
from decimal import Decimal


class ExecutiveCostDashboard:
    """Executive-level cost dashboard."""

    def __init__(
        self,
        tco_model: TCOModel,
        llm_tracker: LLMCostTracker,
        infra_tracker: InfrastructureCostTracker,
        personnel_calc: PersonnelCostCalculator,
        overhead_calc: OperationalOverheadCalculator
    ):
        self.tco = tco_model
        self.llm = llm_tracker
        self.infra = infra_tracker
        self.personnel = personnel_calc
        self.overhead = overhead_calc

    def generate_monthly_summary(self, month: datetime) -> Dict:
        """Generate monthly cost summary for executives."""
        # Get monthly costs from each component
        infra_summary = self.infra.get_infrastructure_summary()
        llm_estimate = self.llm.estimate_monthly_cost()
        personnel = self.personnel.get_monthly_cost()
        overhead = self.overhead.get_monthly_total()

        total = (
            Decimal(str(infra_summary["total_monthly"])) +
            Decimal(str(llm_estimate["estimated_monthly"])) +
            personnel +
            overhead
        )

        return {
            "month": month.strftime("%Y-%m"),
            "summary": {
                "total_cost": float(total),
                "infrastructure": float(infra_summary["total_monthly"]),
                "llm_api": float(llm_estimate["estimated_monthly"]),
                "personnel": float(personnel),
                "overhead": float(overhead)
            },
            "cost_breakdown_percentage": {
                "infrastructure": float(Decimal(str(infra_summary["total_monthly"])) / total * 100),
                "llm_api": float(Decimal(str(llm_estimate["estimated_monthly"])) / total * 100),
                "personnel": float(personnel / total * 100),
                "overhead": float(overhead / total * 100)
            },
            "highlights": self._generate_highlights(infra_summary, llm_estimate),
            "trend": self._calculate_trend(month)
        }

    def _generate_highlights(
        self,
        infra_summary: Dict,
        llm_estimate: Dict
    ) -> List[str]:
        """Generate key highlights for the dashboard."""
        highlights = []

        # Infrastructure highlights
        reserved = infra_summary["compute"].get("reserved_percentage", 0)
        if reserved < 50:
            highlights.append(
                f"Only {reserved:.0f}% of compute is reserved. "
                f"Consider increasing reserved instances for savings."
            )

        # LLM highlights
        cache_rate = 0.3  # Would come from actual data
        if cache_rate < 0.4:
            highlights.append(
                f"LLM cache hit rate is {cache_rate*100:.0f}%. "
                f"Improving caching could reduce API costs."
            )

        return highlights

    def _calculate_trend(self, month: datetime) -> Dict:
        """Calculate cost trend vs previous period."""
        # Would compare to previous month's actual data
        return {
            "vs_previous_month": 5.2,  # Percentage change
            "vs_budget": -3.1,  # Percentage vs budget
            "projection_accuracy": 92.5  # How accurate last month's projection was
        }

    def generate_cost_report(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> str:
        """Generate detailed cost report."""
        report = f"""
# Cost Report
**Period**: {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}
**Generated**: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}

## Executive Summary

"""
        summary = self.generate_monthly_summary(start_date)

        report += f"""
### Total Monthly Cost: ${summary['summary']['total_cost']:,.2f}

| Category | Cost | % of Total |
|----------|------|------------|
| Infrastructure | ${summary['summary']['infrastructure']:,.2f} | {summary['cost_breakdown_percentage']['infrastructure']:.1f}% |
| LLM API | ${summary['summary']['llm_api']:,.2f} | {summary['cost_breakdown_percentage']['llm_api']:.1f}% |
| Personnel | ${summary['summary']['personnel']:,.2f} | {summary['cost_breakdown_percentage']['personnel']:.1f}% |
| Overhead | ${summary['summary']['overhead']:,.2f} | {summary['cost_breakdown_percentage']['overhead']:.1f}% |

## Key Highlights

"""
        for highlight in summary['highlights']:
            report += f"- {highlight}\n"

        report += """

## Infrastructure Details

"""
        infra = self.infra.get_infrastructure_summary()
        report += f"""
- **Compute**: ${infra['compute']['total']:,.2f} ({infra['compute']['instances']} instances)
- **Storage**: ${infra['storage']['total']:,.2f} ({infra['storage']['total_size_tb']:.1f} TB)
- **Network**: ${infra['network']['total']:,.2f}
- **Managed Services**: ${infra['managed_services']['total']:,.2f}

## LLM API Usage

"""
        llm_data = self.llm.get_cost_by_period(start_date, end_date)
        report += f"""
- **Total Requests**: {llm_data['total_requests']:,}
- **Total Tokens**: {llm_data['total_tokens']['total']:,}
- **Average Cost per Request**: ${llm_data['average_cost_per_request']:.4f}
- **Cache Hit Rate**: {llm_data['cache_hit_rate']*100:.1f}%

### Cost by Model

| Model | Cost |
|-------|------|
"""
        for model, cost in llm_data['cost_by_model'].items():
            report += f"| {model} | ${cost:,.2f} |\n"

        report += """

## Recommendations

"""
        # Would include actual recommendations
        report += """
1. Increase reserved instance coverage to 70% for estimated $X,XXX monthly savings
2. Implement prompt caching for high-volume use cases
3. Review GPT-4 usage for tasks that could use smaller models

"""
        return report


class CostAlertManager:
    """Manage cost alerts and notifications."""

    def __init__(self):
        self.thresholds: Dict[str, Dict] = {}
        self.alerts: List[Dict] = []

    def set_threshold(
        self,
        name: str,
        category: str,
        warning_threshold: Decimal,
        critical_threshold: Decimal
    ):
        """Set a cost threshold for alerting."""
        self.thresholds[name] = {
            "category": category,
            "warning": warning_threshold,
            "critical": critical_threshold
        }

    def check_thresholds(
        self,
        current_costs: Dict[str, Decimal]
    ) -> List[Dict]:
        """Check current costs against thresholds."""
        alerts = []

        for name, threshold in self.thresholds.items():
            category = threshold["category"]
            current = current_costs.get(category, Decimal("0"))

            if current >= threshold["critical"]:
                alerts.append({
                    "severity": "critical",
                    "threshold_name": name,
                    "category": category,
                    "current_value": float(current),
                    "threshold_value": float(threshold["critical"]),
                    "message": f"CRITICAL: {category} cost (${current:,.2f}) exceeds critical threshold (${threshold['critical']:,.2f})"
                })
            elif current >= threshold["warning"]:
                alerts.append({
                    "severity": "warning",
                    "threshold_name": name,
                    "category": category,
                    "current_value": float(current),
                    "threshold_value": float(threshold["warning"]),
                    "message": f"WARNING: {category} cost (${current:,.2f}) exceeds warning threshold (${threshold['warning']:,.2f})"
                })

        self.alerts.extend(alerts)
        return alerts

    def get_budget_status(
        self,
        budget: Decimal,
        current_spend: Decimal,
        days_elapsed: int,
        days_in_month: int
    ) -> Dict:
        """Calculate budget status and projections."""
        daily_rate = current_spend / days_elapsed if days_elapsed > 0 else Decimal("0")
        projected_spend = daily_rate * days_in_month
        remaining_budget = budget - current_spend
        remaining_days = days_in_month - days_elapsed

        if remaining_days > 0:
            daily_budget_remaining = remaining_budget / remaining_days
        else:
            daily_budget_remaining = Decimal("0")

        return {
            "budget": float(budget),
            "current_spend": float(current_spend),
            "remaining_budget": float(remaining_budget),
            "projected_spend": float(projected_spend),
            "budget_utilization_percent": float(current_spend / budget * 100) if budget > 0 else 0,
            "projected_utilization_percent": float(projected_spend / budget * 100) if budget > 0 else 0,
            "daily_rate": float(daily_rate),
            "daily_budget_remaining": float(daily_budget_remaining),
            "status": self._get_budget_status(current_spend, projected_spend, budget)
        }

    def _get_budget_status(
        self,
        current: Decimal,
        projected: Decimal,
        budget: Decimal
    ) -> str:
        """Determine budget status."""
        if current > budget:
            return "over_budget"
        if projected > budget * Decimal("1.1"):
            return "projected_over"
        if projected > budget:
            return "at_risk"
        if projected > budget * Decimal("0.9"):
            return "on_track"
        return "under_budget"
```

### 4.2 Cost Allocation and Chargeback

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime


class CostAllocationEngine:
    """Engine for allocating costs to teams and projects."""

    def __init__(self):
        self.allocation_rules: Dict[str, Dict] = {}
        self.cost_centers: Dict[str, Dict] = {}

    def define_cost_center(
        self,
        cost_center_id: str,
        name: str,
        budget: Decimal,
        owner: str
    ):
        """Define a cost center."""
        self.cost_centers[cost_center_id] = {
            "name": name,
            "budget": budget,
            "owner": owner,
            "allocated_costs": Decimal("0")
        }

    def add_allocation_rule(
        self,
        rule_id: str,
        cost_category: str,
        allocation_method: str,
        allocations: Dict[str, float]
    ):
        """Add a cost allocation rule."""
        self.allocation_rules[rule_id] = {
            "cost_category": cost_category,
            "method": allocation_method,
            "allocations": allocations
        }

    def allocate_costs(
        self,
        costs: Dict[str, Decimal]
    ) -> Dict[str, Dict]:
        """Allocate costs based on rules."""
        allocations: Dict[str, Dict] = {
            cc_id: {"name": cc["name"], "costs": {}, "total": Decimal("0")}
            for cc_id, cc in self.cost_centers.items()
        }

        for rule_id, rule in self.allocation_rules.items():
            category = rule["cost_category"]
            if category not in costs:
                continue

            cost_amount = costs[category]

            for cc_id, percentage in rule["allocations"].items():
                if cc_id not in allocations:
                    continue

                allocated_amount = cost_amount * Decimal(str(percentage / 100))
                allocations[cc_id]["costs"][category] = allocated_amount
                allocations[cc_id]["total"] += allocated_amount

        return allocations

    def generate_chargeback_report(
        self,
        period: str,
        costs: Dict[str, Decimal]
    ) -> str:
        """Generate chargeback report for billing."""
        allocations = self.allocate_costs(costs)

        report = f"""
# Chargeback Report - {period}

## Summary by Cost Center

| Cost Center | Owner | Allocated Cost | Budget | Utilization |
|-------------|-------|----------------|--------|-------------|
"""
        for cc_id, alloc in allocations.items():
            cc = self.cost_centers[cc_id]
            utilization = float(alloc["total"] / cc["budget"] * 100) if cc["budget"] > 0 else 0
            report += f"| {alloc['name']} | {cc['owner']} | ${float(alloc['total']):,.2f} | ${float(cc['budget']):,.2f} | {utilization:.1f}% |\n"

        report += "\n## Detailed Breakdown\n\n"

        for cc_id, alloc in allocations.items():
            report += f"### {alloc['name']}\n\n"
            report += "| Category | Amount |\n|----------|--------|\n"
            for category, amount in alloc["costs"].items():
                report += f"| {category} | ${float(amount):,.2f} |\n"
            report += f"| **Total** | **${float(alloc['total']):,.2f}** |\n\n"

        return report


class UsageBasedAllocation:
    """Allocate costs based on actual usage metrics."""

    def __init__(self):
        self.usage_metrics: Dict[str, Dict[str, float]] = {}

    def record_usage(
        self,
        cost_center_id: str,
        metric_name: str,
        value: float
    ):
        """Record usage for a cost center."""
        if cost_center_id not in self.usage_metrics:
            self.usage_metrics[cost_center_id] = {}
        self.usage_metrics[cost_center_id][metric_name] = value

    def calculate_proportional_allocation(
        self,
        metric_name: str,
        total_cost: Decimal
    ) -> Dict[str, Decimal]:
        """Calculate allocation based on usage proportion."""
        total_usage = sum(
            m.get(metric_name, 0)
            for m in self.usage_metrics.values()
        )

        if total_usage == 0:
            return {}

        allocations = {}
        for cc_id, metrics in self.usage_metrics.items():
            usage = metrics.get(metric_name, 0)
            proportion = usage / total_usage
            allocations[cc_id] = total_cost * Decimal(str(proportion))

        return allocations

    def get_usage_summary(self) -> Dict:
        """Get usage summary across all cost centers."""
        # Aggregate all metric names
        all_metrics = set()
        for metrics in self.usage_metrics.values():
            all_metrics.update(metrics.keys())

        summary = {
            "cost_centers": self.usage_metrics,
            "totals": {}
        }

        for metric in all_metrics:
            summary["totals"][metric] = sum(
                m.get(metric, 0)
                for m in self.usage_metrics.values()
            )

        return summary
```

## 5. Cost Optimization Strategies

### 5.1 Reserved Capacity Optimizer

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal


@dataclass
class ReservationRecommendation:
    """Recommendation for reserved capacity."""
    resource_type: str
    current_on_demand_cost: Decimal
    recommended_reserved_count: int
    reservation_term: str  # 1-year, 3-year
    estimated_savings: Decimal
    break_even_months: int
    upfront_cost: Decimal
    effective_hourly_rate: Decimal


class ReservedCapacityOptimizer:
    """Optimize reserved capacity purchases."""

    def __init__(self):
        self.usage_history: Dict[str, List[float]] = {}
        self.reservation_pricing: Dict[str, Dict] = {}

    def set_reservation_pricing(
        self,
        resource_type: str,
        on_demand_hourly: Decimal,
        reserved_1yr_hourly: Decimal,
        reserved_3yr_hourly: Decimal,
        reserved_1yr_upfront: Decimal = Decimal("0"),
        reserved_3yr_upfront: Decimal = Decimal("0")
    ):
        """Set pricing for reservation calculations."""
        self.reservation_pricing[resource_type] = {
            "on_demand": on_demand_hourly,
            "1yr_hourly": reserved_1yr_hourly,
            "1yr_upfront": reserved_1yr_upfront,
            "3yr_hourly": reserved_3yr_hourly,
            "3yr_upfront": reserved_3yr_upfront
        }

    def record_usage(self, resource_type: str, hourly_usage: List[float]):
        """Record historical usage for analysis."""
        self.usage_history[resource_type] = hourly_usage

    def analyze_reservation_opportunity(
        self,
        resource_type: str
    ) -> Optional[ReservationRecommendation]:
        """Analyze reservation opportunity for a resource type."""
        if resource_type not in self.usage_history:
            return None
        if resource_type not in self.reservation_pricing:
            return None

        usage = self.usage_history[resource_type]
        pricing = self.reservation_pricing[resource_type]

        # Calculate baseline (p10 usage - what's always running)
        sorted_usage = sorted(usage)
        baseline_idx = int(len(sorted_usage) * 0.1)
        baseline_usage = sorted_usage[baseline_idx] if baseline_idx < len(sorted_usage) else 0

        # Recommend reserving the baseline
        recommended_count = int(baseline_usage)
        if recommended_count == 0:
            return None

        hours_per_month = 730
        on_demand_monthly = pricing["on_demand"] * recommended_count * hours_per_month

        # Calculate 1-year reservation cost
        reserved_1yr_monthly = pricing["1yr_hourly"] * recommended_count * hours_per_month
        reserved_1yr_monthly += pricing["1yr_upfront"] / 12

        savings_1yr = on_demand_monthly - reserved_1yr_monthly

        return ReservationRecommendation(
            resource_type=resource_type,
            current_on_demand_cost=on_demand_monthly,
            recommended_reserved_count=recommended_count,
            reservation_term="1-year",
            estimated_savings=savings_1yr,
            break_even_months=int(pricing["1yr_upfront"] / savings_1yr) if savings_1yr > 0 else 999,
            upfront_cost=pricing["1yr_upfront"] * recommended_count,
            effective_hourly_rate=pricing["1yr_hourly"]
        )

    def get_all_recommendations(self) -> List[ReservationRecommendation]:
        """Get recommendations for all resource types."""
        recommendations = []
        for resource_type in self.usage_history:
            rec = self.analyze_reservation_opportunity(resource_type)
            if rec:
                recommendations.append(rec)
        return recommendations


class SpotInstanceOptimizer:
    """Optimize spot instance usage."""

    def __init__(self):
        self.spot_pricing_history: Dict[str, List[Decimal]] = {}
        self.interruption_rates: Dict[str, float] = {}

    def record_spot_pricing(
        self,
        instance_type: str,
        prices: List[Decimal]
    ):
        """Record spot pricing history."""
        self.spot_pricing_history[instance_type] = prices

    def set_interruption_rate(
        self,
        instance_type: str,
        rate: float
    ):
        """Set historical interruption rate."""
        self.interruption_rates[instance_type] = rate

    def analyze_spot_opportunity(
        self,
        instance_type: str,
        on_demand_price: Decimal,
        workload_type: str  # stateless, stateful, batch
    ) -> Dict:
        """Analyze opportunity for spot instances."""
        if instance_type not in self.spot_pricing_history:
            return {"suitable": False, "reason": "No pricing history"}

        prices = self.spot_pricing_history[instance_type]
        avg_spot = sum(prices) / len(prices)
        max_spot = max(prices)
        interruption_rate = self.interruption_rates.get(instance_type, 0.05)

        # Calculate savings
        savings_percent = (on_demand_price - avg_spot) / on_demand_price * 100

        # Determine suitability based on workload
        suitable = False
        if workload_type == "batch":
            suitable = True  # Batch workloads can handle interruptions
        elif workload_type == "stateless":
            suitable = interruption_rate < 0.1  # Low interruption rate acceptable
        elif workload_type == "stateful":
            suitable = False  # Generally not recommended for stateful

        return {
            "suitable": suitable,
            "instance_type": instance_type,
            "on_demand_price": float(on_demand_price),
            "average_spot_price": float(avg_spot),
            "max_spot_price": float(max_spot),
            "savings_percent": float(savings_percent),
            "interruption_rate": interruption_rate,
            "recommendation": "Use spot" if suitable else "Use on-demand or reserved",
            "max_bid_recommendation": float(max_spot * Decimal("1.1"))  # 10% above max historical
        }
```

## Troubleshooting

### Common Cost Issues

| Issue | Symptoms | Resolution |
|-------|----------|------------|
| Unexpected cost spike | Budget alerts triggered | Check for resource leaks, unusual usage patterns |
| LLM costs too high | API bills exceeding forecast | Review model selection, implement caching |
| Storage costs growing | Increasing storage bills | Implement lifecycle policies, archive old data |
| Underutilized resources | Low utilization metrics | Rightsize or terminate unused resources |
| Missing cost allocation | Untagged resources | Enforce tagging policies |

### Cost Investigation Checklist

1. Check for recent deployments or configuration changes
2. Review usage metrics for anomalies
3. Verify all resources are properly tagged
4. Check for orphaned or unused resources
5. Review LLM usage patterns and model selection

## Related Documentation

- [14.2 Cloud Cost Optimization Guide](14.2_cloud_cost_optimization_guide.md)
- [14.3 GPU Infrastructure Optimization Guide](14.3_gpu_infrastructure_optimization_guide.md)
- [13.3 Capacity Planning Guide](../13_operations_reliability/13.3_capacity_planning_guide.md)

## Version History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2024-01-15 | Finance Team | Initial release |
