> **Navigation** | [← 12.4 User Feedback](../12_user_developer_experience/12.4_user_feedback_iteration_guide.md) | [13.2 Disaster Recovery →](13.2_disaster_recovery_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | Distributed systems &#124; Monitoring/alerting &#124; LLM platform architecture |
> | **Related** | [10.1 Monitoring](../10_monitoring_observability/10.1_llm_monitoring_strategy_guide.md) &#124; [13.4 On-Call](13.4_on_call_practices_guide.md) &#124; [13.5 Runbooks](13.5_operational_runbooks_guide.md) |
> | **Next** | [13.2 Disaster Recovery](13.2_disaster_recovery_guide.md) |

# 13.1 Incident Response Guide

## Document Information
- **Version**: 1.0
- **Last Updated**: 2024
- **Owner**: Site Reliability Engineering Team
- **Classification**: Internal

## Purpose and Scope

This guide provides comprehensive frameworks for detecting, responding to, and recovering from incidents in LLM platform operations. Effective incident response minimizes user impact, reduces mean time to recovery (MTTR), and drives continuous improvement.

## Prerequisites

- Understanding of distributed systems
- Familiarity with monitoring and alerting systems
- Access to incident management tools
- Knowledge of LLM platform architecture

---

## 1. Incident Classification and Severity

### 1.1 Severity Level Definitions

```python
"""
Incident severity classification system.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta


class IncidentSeverity(Enum):
    """Incident severity levels."""
    SEV1 = "sev1"  # Critical - Complete outage
    SEV2 = "sev2"  # Major - Significant degradation
    SEV3 = "sev3"  # Minor - Partial impact
    SEV4 = "sev4"  # Low - Minimal impact
    SEV5 = "sev5"  # Informational


class IncidentCategory(Enum):
    """Categories of incidents."""
    AVAILABILITY = "availability"
    PERFORMANCE = "performance"
    DATA_INTEGRITY = "data_integrity"
    SECURITY = "security"
    CAPACITY = "capacity"
    DEPENDENCY = "dependency"
    CONFIGURATION = "configuration"
    MODEL = "model"


@dataclass
class SeverityDefinition:
    """Definition of a severity level."""
    level: IncidentSeverity
    name: str
    description: str
    user_impact: str
    response_time_minutes: int
    update_frequency_minutes: int
    escalation_threshold_minutes: int
    requires_incident_commander: bool
    requires_executive_notification: bool
    examples: List[str] = field(default_factory=list)


class SeverityMatrix:
    """
    Define and manage incident severity levels.
    """

    def __init__(self):
        self.definitions = self._load_definitions()

    def _load_definitions(self) -> Dict[IncidentSeverity, SeverityDefinition]:
        """Load severity level definitions."""
        return {
            IncidentSeverity.SEV1: SeverityDefinition(
                level=IncidentSeverity.SEV1,
                name="Critical",
                description="Complete service outage or critical security breach",
                user_impact="All users unable to access core functionality",
                response_time_minutes=5,
                update_frequency_minutes=15,
                escalation_threshold_minutes=30,
                requires_incident_commander=True,
                requires_executive_notification=True,
                examples=[
                    "Complete API unavailability",
                    "All models returning errors",
                    "Data breach affecting user data",
                    "Critical security vulnerability actively exploited",
                    "Database corruption affecting all users"
                ]
            ),
            IncidentSeverity.SEV2: SeverityDefinition(
                level=IncidentSeverity.SEV2,
                name="Major",
                description="Significant service degradation or partial outage",
                user_impact=">50% of users affected or critical feature unavailable",
                response_time_minutes=15,
                update_frequency_minutes=30,
                escalation_threshold_minutes=60,
                requires_incident_commander=True,
                requires_executive_notification=True,
                examples=[
                    "Primary model provider unavailable",
                    "Latency >5x normal affecting majority of requests",
                    "Authentication system partially down",
                    "Major region unavailable",
                    "Billing system failures"
                ]
            ),
            IncidentSeverity.SEV3: SeverityDefinition(
                level=IncidentSeverity.SEV3,
                name="Minor",
                description="Partial service impact or degraded performance",
                user_impact="<50% of users affected or non-critical feature impacted",
                response_time_minutes=30,
                update_frequency_minutes=60,
                escalation_threshold_minutes=120,
                requires_incident_commander=False,
                requires_executive_notification=False,
                examples=[
                    "Single model/provider unavailable",
                    "Secondary region degraded",
                    "API latency 2-5x normal",
                    "Dashboard unavailable",
                    "Webhook delivery delayed"
                ]
            ),
            IncidentSeverity.SEV4: SeverityDefinition(
                level=IncidentSeverity.SEV4,
                name="Low",
                description="Minimal impact, workaround available",
                user_impact="Small subset of users affected, workaround exists",
                response_time_minutes=60,
                update_frequency_minutes=120,
                escalation_threshold_minutes=240,
                requires_incident_commander=False,
                requires_executive_notification=False,
                examples=[
                    "Minor UI issues",
                    "Single customer impacted",
                    "Non-critical feature bug",
                    "Documentation errors",
                    "Intermittent minor errors"
                ]
            ),
            IncidentSeverity.SEV5: SeverityDefinition(
                level=IncidentSeverity.SEV5,
                name="Informational",
                description="No immediate user impact, potential future issue",
                user_impact="No current user impact",
                response_time_minutes=480,
                update_frequency_minutes=1440,
                escalation_threshold_minutes=2880,
                requires_incident_commander=False,
                requires_executive_notification=False,
                examples=[
                    "Approaching capacity limits",
                    "Security scan findings",
                    "Performance optimization opportunities",
                    "Dependency updates needed"
                ]
            )
        }

    def classify_incident(
        self,
        user_impact_percentage: float,
        is_core_functionality: bool,
        is_security_related: bool,
        error_rate: float,
        latency_multiplier: float
    ) -> IncidentSeverity:
        """Automatically classify incident severity."""
        # Security breaches are always high severity
        if is_security_related and user_impact_percentage > 0:
            return IncidentSeverity.SEV1

        # Complete outage
        if error_rate >= 0.95 or user_impact_percentage >= 95:
            return IncidentSeverity.SEV1

        # Major impact
        if (error_rate >= 0.50 or
            user_impact_percentage >= 50 or
            (is_core_functionality and error_rate >= 0.25)):
            return IncidentSeverity.SEV2

        # Moderate impact
        if (error_rate >= 0.10 or
            user_impact_percentage >= 10 or
            latency_multiplier >= 5):
            return IncidentSeverity.SEV3

        # Minor impact
        if (error_rate >= 0.01 or
            user_impact_percentage >= 1 or
            latency_multiplier >= 2):
            return IncidentSeverity.SEV4

        return IncidentSeverity.SEV5

    def get_definition(
        self,
        severity: IncidentSeverity
    ) -> SeverityDefinition:
        """Get severity level definition."""
        return self.definitions[severity]

    def get_sla_targets(
        self,
        severity: IncidentSeverity
    ) -> Dict[str, int]:
        """Get SLA targets for severity level."""
        definition = self.definitions[severity]
        return {
            "response_time_minutes": definition.response_time_minutes,
            "update_frequency_minutes": definition.update_frequency_minutes,
            "escalation_threshold_minutes": definition.escalation_threshold_minutes
        }
```

### 1.2 Incident Data Model

```python
"""
Incident data model and lifecycle management.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum
import uuid


class IncidentStatus(Enum):
    """Incident lifecycle status."""
    DETECTED = "detected"
    ACKNOWLEDGED = "acknowledged"
    INVESTIGATING = "investigating"
    IDENTIFIED = "identified"
    MITIGATING = "mitigating"
    MONITORING = "monitoring"
    RESOLVED = "resolved"
    CLOSED = "closed"


@dataclass
class IncidentTimeline:
    """Timeline entry for incident."""
    timestamp: datetime
    event_type: str
    description: str
    author: str
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class IncidentImpact:
    """Impact assessment for incident."""
    affected_services: List[str]
    affected_users_estimate: int
    affected_regions: List[str]
    revenue_impact_estimate: Optional[float] = None
    sla_breach: bool = False
    customer_notifications_sent: int = 0


@dataclass
class Incident:
    """Complete incident record."""
    id: str
    title: str
    severity: IncidentSeverity
    category: IncidentCategory
    status: IncidentStatus
    description: str
    impact: IncidentImpact
    created_at: datetime
    detected_at: datetime
    acknowledged_at: Optional[datetime] = None
    identified_at: Optional[datetime] = None
    mitigated_at: Optional[datetime] = None
    resolved_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    incident_commander: Optional[str] = None
    responders: List[str] = field(default_factory=list)
    timeline: List[IncidentTimeline] = field(default_factory=list)
    root_cause: Optional[str] = None
    contributing_factors: List[str] = field(default_factory=list)
    action_items: List[Dict[str, Any]] = field(default_factory=list)
    related_incidents: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    external_ticket_id: Optional[str] = None
    postmortem_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def add_timeline_entry(
        self,
        event_type: str,
        description: str,
        author: str,
        metadata: Optional[Dict] = None
    ) -> None:
        """Add entry to incident timeline."""
        self.timeline.append(IncidentTimeline(
            timestamp=datetime.utcnow(),
            event_type=event_type,
            description=description,
            author=author,
            metadata=metadata or {}
        ))

    def calculate_mttr(self) -> Optional[float]:
        """Calculate mean time to resolution in minutes."""
        if not self.resolved_at:
            return None

        delta = self.resolved_at - self.detected_at
        return delta.total_seconds() / 60

    def calculate_mtta(self) -> Optional[float]:
        """Calculate mean time to acknowledge in minutes."""
        if not self.acknowledged_at:
            return None

        delta = self.acknowledged_at - self.detected_at
        return delta.total_seconds() / 60

    def calculate_mtti(self) -> Optional[float]:
        """Calculate mean time to identify in minutes."""
        if not self.identified_at:
            return None

        delta = self.identified_at - self.detected_at
        return delta.total_seconds() / 60


class IncidentManager:
    """
    Manage incident lifecycle and operations.
    """

    def __init__(self):
        self.incidents: Dict[str, Incident] = {}
        self.severity_matrix = SeverityMatrix()
        self.active_incidents: List[str] = []

    def create_incident(
        self,
        title: str,
        severity: IncidentSeverity,
        category: IncidentCategory,
        description: str,
        affected_services: List[str],
        affected_regions: List[str] = None,
        reporter: str = "system"
    ) -> Incident:
        """Create a new incident."""
        incident_id = f"INC-{datetime.utcnow().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8]}"

        incident = Incident(
            id=incident_id,
            title=title,
            severity=severity,
            category=category,
            status=IncidentStatus.DETECTED,
            description=description,
            impact=IncidentImpact(
                affected_services=affected_services,
                affected_users_estimate=0,
                affected_regions=affected_regions or ["all"]
            ),
            created_at=datetime.utcnow(),
            detected_at=datetime.utcnow()
        )

        incident.add_timeline_entry(
            event_type="created",
            description=f"Incident created: {title}",
            author=reporter
        )

        self.incidents[incident_id] = incident
        self.active_incidents.append(incident_id)

        return incident

    def acknowledge_incident(
        self,
        incident_id: str,
        responder: str
    ) -> None:
        """Acknowledge an incident."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        incident.status = IncidentStatus.ACKNOWLEDGED
        incident.acknowledged_at = datetime.utcnow()
        incident.responders.append(responder)

        incident.add_timeline_entry(
            event_type="acknowledged",
            description=f"Incident acknowledged by {responder}",
            author=responder
        )

    def assign_incident_commander(
        self,
        incident_id: str,
        commander: str
    ) -> None:
        """Assign incident commander."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        incident.incident_commander = commander
        if commander not in incident.responders:
            incident.responders.append(commander)

        incident.add_timeline_entry(
            event_type="ic_assigned",
            description=f"Incident commander assigned: {commander}",
            author=commander
        )

    def update_status(
        self,
        incident_id: str,
        status: IncidentStatus,
        updater: str,
        notes: str = ""
    ) -> None:
        """Update incident status."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        old_status = incident.status
        incident.status = status

        # Update timestamps
        if status == IncidentStatus.IDENTIFIED and not incident.identified_at:
            incident.identified_at = datetime.utcnow()
        elif status == IncidentStatus.MITIGATING and not incident.mitigated_at:
            incident.mitigated_at = datetime.utcnow()
        elif status == IncidentStatus.RESOLVED and not incident.resolved_at:
            incident.resolved_at = datetime.utcnow()
            if incident_id in self.active_incidents:
                self.active_incidents.remove(incident_id)
        elif status == IncidentStatus.CLOSED and not incident.closed_at:
            incident.closed_at = datetime.utcnow()

        incident.add_timeline_entry(
            event_type="status_change",
            description=f"Status changed: {old_status.value} -> {status.value}. {notes}",
            author=updater
        )

    def update_severity(
        self,
        incident_id: str,
        severity: IncidentSeverity,
        updater: str,
        reason: str
    ) -> None:
        """Update incident severity."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        old_severity = incident.severity
        incident.severity = severity

        incident.add_timeline_entry(
            event_type="severity_change",
            description=f"Severity changed: {old_severity.value} -> {severity.value}. Reason: {reason}",
            author=updater
        )

    def add_responder(
        self,
        incident_id: str,
        responder: str,
        role: str = "responder"
    ) -> None:
        """Add responder to incident."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        if responder not in incident.responders:
            incident.responders.append(responder)
            incident.add_timeline_entry(
                event_type="responder_joined",
                description=f"{responder} joined as {role}",
                author=responder
            )

    def set_root_cause(
        self,
        incident_id: str,
        root_cause: str,
        contributing_factors: List[str],
        updater: str
    ) -> None:
        """Set root cause analysis results."""
        incident = self.incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Incident {incident_id} not found")

        incident.root_cause = root_cause
        incident.contributing_factors = contributing_factors

        incident.add_timeline_entry(
            event_type="root_cause_identified",
            description=f"Root cause identified: {root_cause}",
            author=updater
        )

    def get_active_incidents(
        self,
        severity_filter: Optional[IncidentSeverity] = None
    ) -> List[Incident]:
        """Get all active incidents."""
        active = [
            self.incidents[id] for id in self.active_incidents
            if id in self.incidents
        ]

        if severity_filter:
            active = [i for i in active if i.severity == severity_filter]

        return sorted(active, key=lambda i: list(IncidentSeverity).index(i.severity))

    def get_incident_metrics(
        self,
        start_date: datetime,
        end_date: datetime
    ) -> Dict[str, Any]:
        """Get incident metrics for a period."""
        period_incidents = [
            i for i in self.incidents.values()
            if start_date <= i.created_at <= end_date
        ]

        if not period_incidents:
            return {"no_data": True}

        resolved = [i for i in period_incidents if i.resolved_at]
        mttr_values = [i.calculate_mttr() for i in resolved if i.calculate_mttr()]
        mtta_values = [i.calculate_mtta() for i in resolved if i.calculate_mtta()]

        by_severity = {}
        for sev in IncidentSeverity:
            sev_incidents = [i for i in period_incidents if i.severity == sev]
            by_severity[sev.value] = len(sev_incidents)

        by_category = {}
        for cat in IncidentCategory:
            cat_incidents = [i for i in period_incidents if i.category == cat]
            by_category[cat.value] = len(cat_incidents)

        return {
            "total_incidents": len(period_incidents),
            "by_severity": by_severity,
            "by_category": by_category,
            "resolved_count": len(resolved),
            "avg_mttr_minutes": sum(mttr_values) / len(mttr_values) if mttr_values else None,
            "avg_mtta_minutes": sum(mtta_values) / len(mtta_values) if mtta_values else None,
            "sla_breaches": len([i for i in period_incidents if i.impact.sla_breach])
        }
```

---

## 2. Detection and Alerting

### 2.1 Alert Configuration

```python
"""
Alert configuration and management for incident detection.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta
from enum import Enum
import re


class AlertConditionType(Enum):
    """Types of alert conditions."""
    THRESHOLD = "threshold"
    RATE_OF_CHANGE = "rate_of_change"
    ANOMALY = "anomaly"
    ABSENCE = "absence"
    COMPOSITE = "composite"


class AlertChannel(Enum):
    """Alert notification channels."""
    PAGERDUTY = "pagerduty"
    SLACK = "slack"
    EMAIL = "email"
    SMS = "sms"
    WEBHOOK = "webhook"


@dataclass
class AlertCondition:
    """Condition that triggers an alert."""
    condition_type: AlertConditionType
    metric: str
    operator: str  # gt, lt, eq, gte, lte
    threshold: float
    duration_seconds: int = 60
    aggregation: str = "avg"  # avg, max, min, sum, count


@dataclass
class AlertEscalation:
    """Escalation policy for alerts."""
    delay_minutes: int
    channels: List[AlertChannel]
    recipients: List[str]
    repeat: bool = False
    repeat_interval_minutes: int = 30


@dataclass
class AlertRule:
    """Complete alert rule configuration."""
    id: str
    name: str
    description: str
    severity: IncidentSeverity
    category: IncidentCategory
    conditions: List[AlertCondition]
    condition_logic: str  # "and" or "or"
    escalations: List[AlertEscalation]
    enabled: bool = True
    auto_resolve: bool = True
    auto_resolve_duration_seconds: int = 300
    tags: List[str] = field(default_factory=list)
    runbook_url: Optional[str] = None
    labels: Dict[str, str] = field(default_factory=dict)


class AlertRuleManager:
    """
    Manage alert rules for the platform.
    """

    def __init__(self):
        self.rules: Dict[str, AlertRule] = {}
        self._load_default_rules()

    def _load_default_rules(self) -> None:
        """Load default alert rules for LLM platform."""
        default_rules = [
            # API Availability
            AlertRule(
                id="api-error-rate-critical",
                name="API Error Rate Critical",
                description="API error rate exceeds critical threshold",
                severity=IncidentSeverity.SEV1,
                category=IncidentCategory.AVAILABILITY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="api.error_rate",
                        operator="gt",
                        threshold=0.50,
                        duration_seconds=120
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.PAGERDUTY, AlertChannel.SLACK],
                        recipients=["oncall-primary", "#incidents"]
                    ),
                    AlertEscalation(
                        delay_minutes=5,
                        channels=[AlertChannel.PAGERDUTY],
                        recipients=["oncall-secondary", "engineering-manager"]
                    )
                ],
                runbook_url="https://runbooks.internal/api-errors"
            ),
            AlertRule(
                id="api-error-rate-high",
                name="API Error Rate High",
                description="API error rate exceeds warning threshold",
                severity=IncidentSeverity.SEV2,
                category=IncidentCategory.AVAILABILITY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="api.error_rate",
                        operator="gt",
                        threshold=0.10,
                        duration_seconds=300
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.SLACK],
                        recipients=["#incidents"]
                    ),
                    AlertEscalation(
                        delay_minutes=10,
                        channels=[AlertChannel.PAGERDUTY],
                        recipients=["oncall-primary"]
                    )
                ],
                runbook_url="https://runbooks.internal/api-errors"
            ),

            # Latency
            AlertRule(
                id="api-latency-critical",
                name="API Latency Critical",
                description="API p99 latency exceeds critical threshold",
                severity=IncidentSeverity.SEV2,
                category=IncidentCategory.PERFORMANCE,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="api.latency_p99_ms",
                        operator="gt",
                        threshold=10000,  # 10 seconds
                        duration_seconds=180
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.PAGERDUTY, AlertChannel.SLACK],
                        recipients=["oncall-primary", "#incidents"]
                    )
                ],
                runbook_url="https://runbooks.internal/latency-issues"
            ),

            # Model Provider Health
            AlertRule(
                id="model-provider-down",
                name="Model Provider Unavailable",
                description="Model provider returning errors",
                severity=IncidentSeverity.SEV2,
                category=IncidentCategory.DEPENDENCY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="provider.error_rate",
                        operator="gt",
                        threshold=0.80,
                        duration_seconds=120
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.SLACK],
                        recipients=["#incidents", "#ml-platform"]
                    ),
                    AlertEscalation(
                        delay_minutes=5,
                        channels=[AlertChannel.PAGERDUTY],
                        recipients=["oncall-primary"]
                    )
                ],
                runbook_url="https://runbooks.internal/provider-failover",
                labels={"provider": "{{provider_name}}"}
            ),

            # Rate Limiting
            AlertRule(
                id="rate-limit-exhaustion",
                name="Rate Limit Approaching Exhaustion",
                description="Provider rate limits nearly exhausted",
                severity=IncidentSeverity.SEV3,
                category=IncidentCategory.CAPACITY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="provider.rate_limit_remaining_percent",
                        operator="lt",
                        threshold=10,
                        duration_seconds=60
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.SLACK],
                        recipients=["#incidents"]
                    )
                ],
                runbook_url="https://runbooks.internal/rate-limits"
            ),

            # Database Health
            AlertRule(
                id="database-connection-pool-exhaustion",
                name="Database Connection Pool Exhaustion",
                description="Database connection pool running low",
                severity=IncidentSeverity.SEV2,
                category=IncidentCategory.CAPACITY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="database.connection_pool_available_percent",
                        operator="lt",
                        threshold=20,
                        duration_seconds=120
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.PAGERDUTY, AlertChannel.SLACK],
                        recipients=["oncall-primary", "#incidents"]
                    )
                ],
                runbook_url="https://runbooks.internal/database-connections"
            ),

            # Security Alerts
            AlertRule(
                id="security-anomaly-detected",
                name="Security Anomaly Detected",
                description="Unusual security-related activity detected",
                severity=IncidentSeverity.SEV1,
                category=IncidentCategory.SECURITY,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.ANOMALY,
                        metric="security.anomaly_score",
                        operator="gt",
                        threshold=0.9,
                        duration_seconds=60
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.PAGERDUTY, AlertChannel.SLACK, AlertChannel.SMS],
                        recipients=["security-oncall", "#security-incidents"]
                    ),
                    AlertEscalation(
                        delay_minutes=5,
                        channels=[AlertChannel.PAGERDUTY],
                        recipients=["security-manager", "ciso"]
                    )
                ],
                auto_resolve=False,
                runbook_url="https://runbooks.internal/security-incidents"
            ),

            # Model Quality
            AlertRule(
                id="model-quality-degradation",
                name="Model Quality Degradation",
                description="Model response quality metrics degraded",
                severity=IncidentSeverity.SEV3,
                category=IncidentCategory.MODEL,
                conditions=[
                    AlertCondition(
                        condition_type=AlertConditionType.THRESHOLD,
                        metric="model.quality_score",
                        operator="lt",
                        threshold=0.7,
                        duration_seconds=600
                    )
                ],
                condition_logic="and",
                escalations=[
                    AlertEscalation(
                        delay_minutes=0,
                        channels=[AlertChannel.SLACK],
                        recipients=["#ml-platform", "#incidents"]
                    )
                ],
                runbook_url="https://runbooks.internal/model-quality"
            )
        ]

        for rule in default_rules:
            self.rules[rule.id] = rule

    def add_rule(self, rule: AlertRule) -> None:
        """Add or update an alert rule."""
        self.rules[rule.id] = rule

    def get_rule(self, rule_id: str) -> Optional[AlertRule]:
        """Get an alert rule by ID."""
        return self.rules.get(rule_id)

    def enable_rule(self, rule_id: str) -> None:
        """Enable an alert rule."""
        if rule_id in self.rules:
            self.rules[rule_id].enabled = True

    def disable_rule(self, rule_id: str) -> None:
        """Disable an alert rule."""
        if rule_id in self.rules:
            self.rules[rule_id].enabled = False

    def get_rules_for_category(
        self,
        category: IncidentCategory
    ) -> List[AlertRule]:
        """Get all rules for a category."""
        return [
            r for r in self.rules.values()
            if r.category == category and r.enabled
        ]

    def export_rules(self) -> Dict[str, Any]:
        """Export all rules as configuration."""
        return {
            "rules": [
                {
                    "id": r.id,
                    "name": r.name,
                    "description": r.description,
                    "severity": r.severity.value,
                    "category": r.category.value,
                    "enabled": r.enabled
                }
                for r in self.rules.values()
            ]
        }
```

### 2.2 Alert Evaluation Engine

```python
"""
Alert evaluation and firing engine.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
import asyncio


@dataclass
class AlertState:
    """Current state of an alert."""
    rule_id: str
    status: str  # pending, firing, resolved
    first_triggered: Optional[datetime] = None
    last_triggered: Optional[datetime] = None
    value: Optional[float] = None
    labels: Dict[str, str] = field(default_factory=dict)
    annotations: Dict[str, str] = field(default_factory=dict)


@dataclass
class FiredAlert:
    """A fired alert."""
    id: str
    rule_id: str
    rule_name: str
    severity: IncidentSeverity
    category: IncidentCategory
    status: str
    value: float
    threshold: float
    message: str
    fired_at: datetime
    resolved_at: Optional[datetime] = None
    labels: Dict[str, str] = field(default_factory=dict)
    fingerprint: str = ""


class AlertEvaluator:
    """
    Evaluate alert conditions and fire alerts.
    """

    def __init__(
        self,
        rule_manager: AlertRuleManager,
        metric_fetcher: Callable[[str, int], float]
    ):
        self.rule_manager = rule_manager
        self.metric_fetcher = metric_fetcher
        self.alert_states: Dict[str, AlertState] = {}
        self.fired_alerts: Dict[str, FiredAlert] = {}
        self.alert_history: List[FiredAlert] = []

    async def evaluate_all(self) -> List[FiredAlert]:
        """Evaluate all enabled alert rules."""
        new_alerts = []

        for rule_id, rule in self.rule_manager.rules.items():
            if not rule.enabled:
                continue

            try:
                should_fire, value = await self._evaluate_rule(rule)

                if should_fire:
                    alert = self._fire_alert(rule, value)
                    if alert:
                        new_alerts.append(alert)
                else:
                    self._maybe_resolve_alert(rule_id)

            except Exception as e:
                print(f"Error evaluating rule {rule_id}: {e}")

        return new_alerts

    async def _evaluate_rule(
        self,
        rule: AlertRule
    ) -> tuple[bool, float]:
        """Evaluate a single alert rule."""
        condition_results = []

        for condition in rule.conditions:
            result, value = await self._evaluate_condition(condition)
            condition_results.append((result, value))

        if rule.condition_logic == "and":
            should_fire = all(r[0] for r in condition_results)
        else:  # "or"
            should_fire = any(r[0] for r in condition_results)

        # Use the first condition's value for reporting
        return should_fire, condition_results[0][1] if condition_results else 0

    async def _evaluate_condition(
        self,
        condition: AlertCondition
    ) -> tuple[bool, float]:
        """Evaluate a single condition."""
        # Fetch metric value
        value = self.metric_fetcher(
            condition.metric,
            condition.duration_seconds
        )

        # Apply operator
        operators = {
            "gt": lambda v, t: v > t,
            "lt": lambda v, t: v < t,
            "gte": lambda v, t: v >= t,
            "lte": lambda v, t: v <= t,
            "eq": lambda v, t: v == t
        }

        operator_func = operators.get(condition.operator, operators["gt"])
        result = operator_func(value, condition.threshold)

        return result, value

    def _fire_alert(
        self,
        rule: AlertRule,
        value: float
    ) -> Optional[FiredAlert]:
        """Fire an alert for a rule."""
        fingerprint = self._generate_fingerprint(rule)

        # Check if already firing
        if fingerprint in self.fired_alerts:
            existing = self.fired_alerts[fingerprint]
            if existing.status == "firing":
                return None  # Already firing

        alert = FiredAlert(
            id=f"alert-{datetime.utcnow().timestamp()}",
            rule_id=rule.id,
            rule_name=rule.name,
            severity=rule.severity,
            category=rule.category,
            status="firing",
            value=value,
            threshold=rule.conditions[0].threshold if rule.conditions else 0,
            message=self._generate_message(rule, value),
            fired_at=datetime.utcnow(),
            labels=rule.labels,
            fingerprint=fingerprint
        )

        self.fired_alerts[fingerprint] = alert
        self.alert_history.append(alert)

        # Update state
        self.alert_states[rule.id] = AlertState(
            rule_id=rule.id,
            status="firing",
            first_triggered=datetime.utcnow(),
            last_triggered=datetime.utcnow(),
            value=value
        )

        return alert

    def _maybe_resolve_alert(self, rule_id: str) -> None:
        """Check if an alert should be resolved."""
        rule = self.rule_manager.get_rule(rule_id)
        if not rule or not rule.auto_resolve:
            return

        fingerprint = self._generate_fingerprint(rule)

        if fingerprint in self.fired_alerts:
            alert = self.fired_alerts[fingerprint]
            if alert.status == "firing":
                state = self.alert_states.get(rule_id)
                if state and state.last_triggered:
                    time_since = (datetime.utcnow() - state.last_triggered).total_seconds()
                    if time_since >= rule.auto_resolve_duration_seconds:
                        alert.status = "resolved"
                        alert.resolved_at = datetime.utcnow()
                        state.status = "resolved"

    def _generate_fingerprint(self, rule: AlertRule) -> str:
        """Generate unique fingerprint for an alert."""
        label_str = "_".join(f"{k}={v}" for k, v in sorted(rule.labels.items()))
        return f"{rule.id}_{label_str}"

    def _generate_message(self, rule: AlertRule, value: float) -> str:
        """Generate alert message."""
        if rule.conditions:
            condition = rule.conditions[0]
            return (
                f"{rule.name}: {condition.metric} is {value:.2f} "
                f"({condition.operator} {condition.threshold})"
            )
        return rule.description

    def get_firing_alerts(self) -> List[FiredAlert]:
        """Get all currently firing alerts."""
        return [
            a for a in self.fired_alerts.values()
            if a.status == "firing"
        ]

    def get_alert_history(
        self,
        since: Optional[datetime] = None,
        rule_id: Optional[str] = None
    ) -> List[FiredAlert]:
        """Get alert history."""
        history = self.alert_history

        if since:
            history = [a for a in history if a.fired_at >= since]

        if rule_id:
            history = [a for a in history if a.rule_id == rule_id]

        return history
```

---

## 3. Response Procedures

### 3.1 Incident Response Roles

```python
"""
Incident response roles and responsibilities.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from enum import Enum


class IncidentRole(Enum):
    """Roles in incident response."""
    INCIDENT_COMMANDER = "incident_commander"
    TECHNICAL_LEAD = "technical_lead"
    COMMUNICATIONS_LEAD = "communications_lead"
    SCRIBE = "scribe"
    SUBJECT_MATTER_EXPERT = "subject_matter_expert"
    RESPONDER = "responder"


@dataclass
class RoleDefinition:
    """Definition of an incident response role."""
    role: IncidentRole
    title: str
    description: str
    responsibilities: List[str]
    required_for_severity: List[IncidentSeverity]
    backup_escalation: Optional[str] = None


class IncidentRoles:
    """
    Define and manage incident response roles.
    """

    def __init__(self):
        self.role_definitions = self._load_role_definitions()

    def _load_role_definitions(self) -> Dict[IncidentRole, RoleDefinition]:
        """Load role definitions."""
        return {
            IncidentRole.INCIDENT_COMMANDER: RoleDefinition(
                role=IncidentRole.INCIDENT_COMMANDER,
                title="Incident Commander (IC)",
                description="Overall coordination and decision-making authority",
                responsibilities=[
                    "Declare incident severity and coordinate response",
                    "Assign roles and delegate tasks",
                    "Make critical decisions during the incident",
                    "Coordinate with stakeholders and leadership",
                    "Authorize mitigation actions",
                    "Determine when incident is resolved",
                    "Ensure proper documentation and handoffs",
                    "Schedule post-incident review"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2
                ],
                backup_escalation="engineering_manager"
            ),
            IncidentRole.TECHNICAL_LEAD: RoleDefinition(
                role=IncidentRole.TECHNICAL_LEAD,
                title="Technical Lead",
                description="Lead technical investigation and remediation",
                responsibilities=[
                    "Lead technical investigation",
                    "Coordinate with subject matter experts",
                    "Propose and implement technical solutions",
                    "Assess impact and risk of proposed actions",
                    "Communicate technical status to IC",
                    "Document technical timeline and decisions",
                    "Validate resolution and stability"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2,
                    IncidentSeverity.SEV3
                ]
            ),
            IncidentRole.COMMUNICATIONS_LEAD: RoleDefinition(
                role=IncidentRole.COMMUNICATIONS_LEAD,
                title="Communications Lead",
                description="Manage all internal and external communications",
                responsibilities=[
                    "Draft and send status updates to stakeholders",
                    "Update status page and public communications",
                    "Coordinate customer communications",
                    "Manage executive communications",
                    "Track and respond to customer inquiries",
                    "Maintain communication timeline"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2
                ]
            ),
            IncidentRole.SCRIBE: RoleDefinition(
                role=IncidentRole.SCRIBE,
                title="Scribe",
                description="Document incident timeline and decisions",
                responsibilities=[
                    "Maintain incident timeline",
                    "Document key decisions and rationale",
                    "Record action items and owners",
                    "Capture technical findings",
                    "Prepare initial post-incident report",
                    "Track metrics (MTTA, MTTI, MTTR)"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2
                ]
            ),
            IncidentRole.SUBJECT_MATTER_EXPERT: RoleDefinition(
                role=IncidentRole.SUBJECT_MATTER_EXPERT,
                title="Subject Matter Expert (SME)",
                description="Provide specialized technical expertise",
                responsibilities=[
                    "Provide expert knowledge in specific domain",
                    "Assist with diagnosis and root cause analysis",
                    "Recommend remediation approaches",
                    "Implement specialized fixes",
                    "Validate fixes within expertise area"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2,
                    IncidentSeverity.SEV3
                ]
            ),
            IncidentRole.RESPONDER: RoleDefinition(
                role=IncidentRole.RESPONDER,
                title="Responder",
                description="Execute assigned tasks during incident",
                responsibilities=[
                    "Execute assigned investigation tasks",
                    "Implement directed fixes",
                    "Report findings to technical lead",
                    "Monitor systems as directed",
                    "Assist with documentation"
                ],
                required_for_severity=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2,
                    IncidentSeverity.SEV3,
                    IncidentSeverity.SEV4
                ]
            )
        }

    def get_required_roles(
        self,
        severity: IncidentSeverity
    ) -> List[IncidentRole]:
        """Get required roles for a severity level."""
        return [
            role for role, definition in self.role_definitions.items()
            if severity in definition.required_for_severity
        ]

    def get_role_definition(
        self,
        role: IncidentRole
    ) -> RoleDefinition:
        """Get definition for a role."""
        return self.role_definitions[role]


@dataclass
class OnCallSchedule:
    """On-call schedule entry."""
    team: str
    primary: str
    secondary: str
    start_time: str
    end_time: str
    timezone: str
    escalation_policy: str


class OnCallManager:
    """
    Manage on-call schedules and escalations.
    """

    def __init__(self):
        self.schedules: Dict[str, List[OnCallSchedule]] = {}
        self.escalation_policies: Dict[str, List[str]] = {}

    def get_current_oncall(self, team: str) -> Optional[str]:
        """Get current on-call person for a team."""
        # In production, would check schedule against current time
        schedules = self.schedules.get(team, [])
        if schedules:
            return schedules[0].primary
        return None

    def get_escalation_chain(
        self,
        team: str,
        severity: IncidentSeverity
    ) -> List[str]:
        """Get escalation chain for a team and severity."""
        chain = []

        # Primary on-call
        primary = self.get_current_oncall(team)
        if primary:
            chain.append(primary)

        # Secondary on-call for SEV1/SEV2
        if severity in [IncidentSeverity.SEV1, IncidentSeverity.SEV2]:
            schedules = self.schedules.get(team, [])
            if schedules:
                chain.append(schedules[0].secondary)

        # Manager for SEV1
        if severity == IncidentSeverity.SEV1:
            chain.append(f"{team}_manager")

        return chain
```

### 3.2 Response Playbooks

```python
"""
Incident response playbooks and procedures.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any


@dataclass
class PlaybookStep:
    """A step in a response playbook."""
    order: int
    title: str
    description: str
    commands: List[str] = field(default_factory=list)
    verification: Optional[str] = None
    rollback: Optional[str] = None
    timeout_minutes: int = 10
    requires_approval: bool = False


@dataclass
class ResponsePlaybook:
    """Complete response playbook."""
    id: str
    name: str
    description: str
    category: IncidentCategory
    applicable_severities: List[IncidentSeverity]
    symptoms: List[str]
    prerequisites: List[str]
    steps: List[PlaybookStep]
    escalation_criteria: List[str]
    related_playbooks: List[str] = field(default_factory=list)
    last_updated: str = ""
    owner: str = ""


class PlaybookLibrary:
    """
    Library of incident response playbooks.
    """

    def __init__(self):
        self.playbooks: Dict[str, ResponsePlaybook] = {}
        self._load_default_playbooks()

    def _load_default_playbooks(self) -> None:
        """Load default playbooks for common incidents."""
        default_playbooks = [
            ResponsePlaybook(
                id="api-high-error-rate",
                name="API High Error Rate Response",
                description="Respond to elevated API error rates",
                category=IncidentCategory.AVAILABILITY,
                applicable_severities=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2,
                    IncidentSeverity.SEV3
                ],
                symptoms=[
                    "Error rate above threshold",
                    "5xx errors increasing",
                    "Customer reports of failures"
                ],
                prerequisites=[
                    "Access to monitoring dashboards",
                    "Access to API logs",
                    "Ability to modify load balancer configuration"
                ],
                steps=[
                    PlaybookStep(
                        order=1,
                        title="Assess Impact",
                        description="Determine scope and impact of errors",
                        commands=[
                            "# Check error rate by endpoint",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (endpoint)'",
                            "",
                            "# Check error rate by region",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(http_requests_total{status=~\"5..\"}[5m])) by (region)'"
                        ],
                        verification="Identify affected endpoints and regions"
                    ),
                    PlaybookStep(
                        order=2,
                        title="Check Recent Deployments",
                        description="Identify any recent changes that could cause errors",
                        commands=[
                            "# Check recent deployments",
                            "kubectl get deployments -n production -o wide --sort-by=.metadata.creationTimestamp | tail -10",
                            "",
                            "# Check deployment history",
                            "kubectl rollout history deployment/api-gateway -n production"
                        ],
                        verification="Note any deployments in last 2 hours"
                    ),
                    PlaybookStep(
                        order=3,
                        title="Check Dependencies",
                        description="Verify health of dependent services",
                        commands=[
                            "# Check provider status",
                            "curl -s https://status.openai.com/api/v2/status.json | jq '.status'",
                            "curl -s https://status.anthropic.com/api/v2/status.json | jq '.status'",
                            "",
                            "# Check database health",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- pg_isready"
                        ],
                        verification="All dependencies healthy or identify failed dependency"
                    ),
                    PlaybookStep(
                        order=4,
                        title="Review Error Logs",
                        description="Analyze error patterns in logs",
                        commands=[
                            "# Get recent error logs",
                            "kubectl logs -n production -l app=api-gateway --since=10m | grep -i error | tail -50",
                            "",
                            "# Search for specific error patterns",
                            "kubectl logs -n production -l app=api-gateway --since=10m | grep -E '(timeout|connection refused|5[0-9]{2})'"
                        ],
                        verification="Identify error pattern or root cause"
                    ),
                    PlaybookStep(
                        order=5,
                        title="Mitigate - Rollback if Deployment Related",
                        description="Roll back recent deployment if identified as cause",
                        commands=[
                            "# Rollback to previous revision",
                            "kubectl rollout undo deployment/api-gateway -n production",
                            "",
                            "# Verify rollback",
                            "kubectl rollout status deployment/api-gateway -n production"
                        ],
                        requires_approval=True,
                        rollback="kubectl rollout undo deployment/api-gateway -n production"
                    ),
                    PlaybookStep(
                        order=6,
                        title="Mitigate - Enable Circuit Breaker",
                        description="Enable circuit breaker for failing dependency",
                        commands=[
                            "# Enable circuit breaker for provider",
                            "kubectl set env deployment/api-gateway -n production CIRCUIT_BREAKER_ENABLED=true",
                            "",
                            "# Verify circuit breaker status",
                            "curl -s http://api-gateway.production.svc.cluster.local:8080/health/circuit-breakers | jq"
                        ],
                        requires_approval=True
                    ),
                    PlaybookStep(
                        order=7,
                        title="Verify Resolution",
                        description="Confirm error rate has returned to normal",
                        commands=[
                            "# Check current error rate",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(http_requests_total{status=~\"5..\"}[1m]))/sum(rate(http_requests_total[1m]))'",
                            "",
                            "# Monitor for stability (5 minutes)",
                            "watch -n 30 'curl -s \"https://metrics.internal/api/v1/query?query=sum(rate(http_requests_total{status=~\\\"5..\\\"\\}[1m]))\" | jq .data.result[0].value[1]'"
                        ],
                        verification="Error rate below threshold for 5 minutes"
                    )
                ],
                escalation_criteria=[
                    "Error rate not decreasing after 15 minutes",
                    "Root cause not identified after 30 minutes",
                    "Multiple dependencies affected",
                    "Customer impact reported by support"
                ],
                related_playbooks=[
                    "provider-failover",
                    "database-connection-issues",
                    "deployment-rollback"
                ]
            ),

            ResponsePlaybook(
                id="provider-failover",
                name="Model Provider Failover",
                description="Failover to backup model provider",
                category=IncidentCategory.DEPENDENCY,
                applicable_severities=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2
                ],
                symptoms=[
                    "Primary provider returning errors",
                    "Provider status page showing issues",
                    "Timeout errors from provider"
                ],
                prerequisites=[
                    "Backup provider configured",
                    "Access to routing configuration"
                ],
                steps=[
                    PlaybookStep(
                        order=1,
                        title="Confirm Provider Issue",
                        description="Verify the provider is experiencing issues",
                        commands=[
                            "# Check provider error rate",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(provider_requests_total{status=\"error\",provider=\"openai\"}[5m]))/sum(rate(provider_requests_total{provider=\"openai\"}[5m]))'",
                            "",
                            "# Check provider status page",
                            "curl -s https://status.openai.com/api/v2/status.json | jq"
                        ],
                        verification="Provider error rate >50% or status page shows incident"
                    ),
                    PlaybookStep(
                        order=2,
                        title="Check Backup Provider Health",
                        description="Verify backup provider is healthy",
                        commands=[
                            "# Check backup provider status",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(provider_requests_total{status=\"success\",provider=\"anthropic\"}[5m]))/sum(rate(provider_requests_total{provider=\"anthropic\"}[5m]))'",
                            "",
                            "# Test backup provider directly",
                            "curl -X POST https://api.anthropic.com/v1/messages -H 'x-api-key: $ANTHROPIC_API_KEY' -d '{\"model\":\"claude-3-sonnet-20240229\",\"max_tokens\":10,\"messages\":[{\"role\":\"user\",\"content\":\"test\"}]}'"
                        ],
                        verification="Backup provider success rate >95%"
                    ),
                    PlaybookStep(
                        order=3,
                        title="Execute Failover",
                        description="Route traffic to backup provider",
                        commands=[
                            "# Update routing configuration",
                            "kubectl set env deployment/model-router -n production PRIMARY_PROVIDER=anthropic FAILOVER_ENABLED=true",
                            "",
                            "# Restart router pods",
                            "kubectl rollout restart deployment/model-router -n production",
                            "",
                            "# Wait for rollout",
                            "kubectl rollout status deployment/model-router -n production"
                        ],
                        requires_approval=True,
                        rollback="kubectl set env deployment/model-router -n production PRIMARY_PROVIDER=openai FAILOVER_ENABLED=false"
                    ),
                    PlaybookStep(
                        order=4,
                        title="Verify Failover",
                        description="Confirm traffic is flowing through backup",
                        commands=[
                            "# Check traffic distribution",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(provider_requests_total[1m])) by (provider)'",
                            "",
                            "# Check overall success rate",
                            "curl -s 'https://metrics.internal/api/v1/query?query=sum(rate(api_requests_total{status=\"success\"}[1m]))/sum(rate(api_requests_total[1m]))'"
                        ],
                        verification="Success rate >95% via backup provider"
                    ),
                    PlaybookStep(
                        order=5,
                        title="Monitor for Primary Recovery",
                        description="Set up monitoring for primary provider recovery",
                        commands=[
                            "# Set alert for primary recovery",
                            "# This will notify when primary provider is healthy again",
                            "echo 'Monitor primary provider status page and error rates'",
                            "echo 'Plan failback when primary shows stable for 30 minutes'"
                        ]
                    )
                ],
                escalation_criteria=[
                    "Backup provider also experiencing issues",
                    "All configured providers unavailable",
                    "Failover causing unexpected behavior"
                ],
                related_playbooks=[
                    "api-high-error-rate",
                    "rate-limit-exhaustion"
                ]
            ),

            ResponsePlaybook(
                id="database-connection-issues",
                name="Database Connection Issues Response",
                description="Respond to database connection problems",
                category=IncidentCategory.AVAILABILITY,
                applicable_severities=[
                    IncidentSeverity.SEV1,
                    IncidentSeverity.SEV2
                ],
                symptoms=[
                    "Connection pool exhaustion alerts",
                    "Database timeout errors",
                    "Increased query latency"
                ],
                prerequisites=[
                    "Database admin access",
                    "Access to connection pool metrics"
                ],
                steps=[
                    PlaybookStep(
                        order=1,
                        title="Assess Connection Pool Status",
                        description="Check connection pool utilization",
                        commands=[
                            "# Check active connections",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c 'SELECT count(*) FROM pg_stat_activity;'",
                            "",
                            "# Check connection states",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c 'SELECT state, count(*) FROM pg_stat_activity GROUP BY state;'"
                        ],
                        verification="Identify connection count and states"
                    ),
                    PlaybookStep(
                        order=2,
                        title="Identify Long-Running Queries",
                        description="Find queries holding connections",
                        commands=[
                            "# Find long-running queries",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c \"SELECT pid, now() - pg_stat_activity.query_start AS duration, query FROM pg_stat_activity WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes' AND state != 'idle';\"",
                            "",
                            "# Find blocked queries",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c 'SELECT blocked_locks.pid AS blocked_pid, blocked_activity.usename AS blocked_user, blocking_locks.pid AS blocking_pid FROM pg_catalog.pg_locks blocked_locks JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid JOIN pg_catalog.pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype WHERE NOT blocked_locks.granted;'"
                        ],
                        verification="Identify problematic queries"
                    ),
                    PlaybookStep(
                        order=3,
                        title="Terminate Problematic Connections",
                        description="Kill long-running or stuck queries",
                        commands=[
                            "# Terminate specific query (replace PID)",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c 'SELECT pg_terminate_backend(PID);'",
                            "",
                            "# Terminate idle connections older than 10 minutes",
                            "kubectl exec -n production $(kubectl get pod -n production -l app=postgres -o name | head -1) -- psql -U postgres -c \"SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = 'idle' AND query_start < now() - interval '10 minutes';\""
                        ],
                        requires_approval=True
                    ),
                    PlaybookStep(
                        order=4,
                        title="Scale Application Pods",
                        description="Reduce connection pressure by scaling",
                        commands=[
                            "# Scale down non-critical services",
                            "kubectl scale deployment/background-workers -n production --replicas=1",
                            "",
                            "# Restart API pods to reset connection pools",
                            "kubectl rollout restart deployment/api-gateway -n production"
                        ],
                        requires_approval=True,
                        rollback="kubectl scale deployment/background-workers -n production --replicas=5"
                    ),
                    PlaybookStep(
                        order=5,
                        title="Verify Recovery",
                        description="Confirm connections returning to normal",
                        commands=[
                            "# Check connection count",
                            "curl -s 'https://metrics.internal/api/v1/query?query=pg_stat_activity_count'",
                            "",
                            "# Check API latency",
                            "curl -s 'https://metrics.internal/api/v1/query?query=histogram_quantile(0.99,sum(rate(http_request_duration_seconds_bucket[1m])) by (le))'"
                        ],
                        verification="Connection count and latency returning to normal"
                    )
                ],
                escalation_criteria=[
                    "Connection issues persist after killing queries",
                    "Database CPU/memory at capacity",
                    "Replication lag increasing"
                ],
                related_playbooks=[
                    "api-high-error-rate",
                    "capacity-exhaustion"
                ]
            )
        ]

        for playbook in default_playbooks:
            self.playbooks[playbook.id] = playbook

    def get_playbook(self, playbook_id: str) -> Optional[ResponsePlaybook]:
        """Get a playbook by ID."""
        return self.playbooks.get(playbook_id)

    def find_playbooks(
        self,
        category: Optional[IncidentCategory] = None,
        severity: Optional[IncidentSeverity] = None,
        symptoms: Optional[List[str]] = None
    ) -> List[ResponsePlaybook]:
        """Find applicable playbooks based on criteria."""
        results = list(self.playbooks.values())

        if category:
            results = [p for p in results if p.category == category]

        if severity:
            results = [p for p in results if severity in p.applicable_severities]

        if symptoms:
            def matches_symptoms(playbook: ResponsePlaybook) -> bool:
                playbook_symptoms = [s.lower() for s in playbook.symptoms]
                return any(
                    any(query in symptom for symptom in playbook_symptoms)
                    for query in [s.lower() for s in symptoms]
                )

            results = [p for p in results if matches_symptoms(p)]

        return results
```

---

## 4. Communication and Status Updates

### 4.1 Status Page Management

```python
"""
Status page and communication management.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum


class ServiceStatus(Enum):
    """Service health status."""
    OPERATIONAL = "operational"
    DEGRADED = "degraded"
    PARTIAL_OUTAGE = "partial_outage"
    MAJOR_OUTAGE = "major_outage"
    MAINTENANCE = "maintenance"


class IncidentVisibility(Enum):
    """Incident visibility level."""
    PUBLIC = "public"
    CUSTOMERS_ONLY = "customers_only"
    INTERNAL = "internal"


@dataclass
class ServiceComponent:
    """A service component for status page."""
    id: str
    name: str
    description: str
    status: ServiceStatus
    group: str
    display_order: int
    last_updated: datetime = field(default_factory=datetime.utcnow)


@dataclass
class StatusUpdate:
    """A status update for an incident."""
    id: str
    incident_id: str
    status: str
    message: str
    created_at: datetime
    author: str
    visibility: IncidentVisibility


@dataclass
class PublicIncident:
    """Public-facing incident information."""
    id: str
    title: str
    status: str
    impact: str
    affected_components: List[str]
    started_at: datetime
    resolved_at: Optional[datetime]
    updates: List[StatusUpdate]
    visibility: IncidentVisibility


class StatusPageManager:
    """
    Manage public status page and communications.
    """

    def __init__(self):
        self.components: Dict[str, ServiceComponent] = {}
        self.public_incidents: Dict[str, PublicIncident] = {}
        self._initialize_components()

    def _initialize_components(self) -> None:
        """Initialize default service components."""
        default_components = [
            ServiceComponent(
                id="api",
                name="API",
                description="Core API endpoints",
                status=ServiceStatus.OPERATIONAL,
                group="Core Services",
                display_order=1
            ),
            ServiceComponent(
                id="chat-completions",
                name="Chat Completions",
                description="Chat completion endpoints",
                status=ServiceStatus.OPERATIONAL,
                group="Core Services",
                display_order=2
            ),
            ServiceComponent(
                id="embeddings",
                name="Embeddings",
                description="Embedding generation endpoints",
                status=ServiceStatus.OPERATIONAL,
                group="Core Services",
                display_order=3
            ),
            ServiceComponent(
                id="dashboard",
                name="Dashboard",
                description="Web dashboard and console",
                status=ServiceStatus.OPERATIONAL,
                group="Web",
                display_order=4
            ),
            ServiceComponent(
                id="webhooks",
                name="Webhooks",
                description="Webhook delivery",
                status=ServiceStatus.OPERATIONAL,
                group="Integrations",
                display_order=5
            ),
            ServiceComponent(
                id="authentication",
                name="Authentication",
                description="Authentication and authorization",
                status=ServiceStatus.OPERATIONAL,
                group="Core Services",
                display_order=6
            )
        ]

        for component in default_components:
            self.components[component.id] = component

    def update_component_status(
        self,
        component_id: str,
        status: ServiceStatus,
        reason: str = ""
    ) -> None:
        """Update a component's status."""
        if component_id in self.components:
            self.components[component_id].status = status
            self.components[component_id].last_updated = datetime.utcnow()

    def create_public_incident(
        self,
        internal_incident: 'Incident',
        title: str,
        impact: str,
        visibility: IncidentVisibility = IncidentVisibility.PUBLIC
    ) -> PublicIncident:
        """Create a public incident from internal incident."""
        public_incident = PublicIncident(
            id=f"pub-{internal_incident.id}",
            title=title,
            status="investigating",
            impact=impact,
            affected_components=internal_incident.impact.affected_services,
            started_at=internal_incident.detected_at,
            resolved_at=None,
            updates=[],
            visibility=visibility
        )

        # Add initial update
        initial_update = StatusUpdate(
            id=f"update-{datetime.utcnow().timestamp()}",
            incident_id=public_incident.id,
            status="investigating",
            message=f"We are investigating reports of {impact.lower()}.",
            created_at=datetime.utcnow(),
            author="StatusBot",
            visibility=visibility
        )
        public_incident.updates.append(initial_update)

        # Update affected components
        for component_id in internal_incident.impact.affected_services:
            self.update_component_status(
                component_id,
                self._map_severity_to_status(internal_incident.severity)
            )

        self.public_incidents[public_incident.id] = public_incident
        return public_incident

    def add_status_update(
        self,
        incident_id: str,
        status: str,
        message: str,
        author: str
    ) -> StatusUpdate:
        """Add an update to a public incident."""
        incident = self.public_incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Public incident {incident_id} not found")

        update = StatusUpdate(
            id=f"update-{datetime.utcnow().timestamp()}",
            incident_id=incident_id,
            status=status,
            message=message,
            created_at=datetime.utcnow(),
            author=author,
            visibility=incident.visibility
        )

        incident.updates.append(update)
        incident.status = status

        return update

    def resolve_public_incident(
        self,
        incident_id: str,
        resolution_message: str,
        author: str
    ) -> None:
        """Resolve a public incident."""
        incident = self.public_incidents.get(incident_id)
        if not incident:
            raise ValueError(f"Public incident {incident_id} not found")

        # Add resolution update
        self.add_status_update(
            incident_id,
            "resolved",
            resolution_message,
            author
        )

        incident.resolved_at = datetime.utcnow()

        # Restore component status
        for component_id in incident.affected_components:
            self.update_component_status(
                component_id,
                ServiceStatus.OPERATIONAL
            )

    def get_current_status(self) -> Dict[str, Any]:
        """Get current status of all components."""
        groups = {}
        for component in self.components.values():
            if component.group not in groups:
                groups[component.group] = []
            groups[component.group].append({
                "id": component.id,
                "name": component.name,
                "status": component.status.value,
                "description": component.description
            })

        active_incidents = [
            {
                "id": i.id,
                "title": i.title,
                "status": i.status,
                "impact": i.impact,
                "started_at": i.started_at.isoformat()
            }
            for i in self.public_incidents.values()
            if not i.resolved_at
        ]

        overall_status = self._calculate_overall_status()

        return {
            "status": overall_status.value,
            "components": groups,
            "active_incidents": active_incidents,
            "last_updated": datetime.utcnow().isoformat()
        }

    def _map_severity_to_status(
        self,
        severity: IncidentSeverity
    ) -> ServiceStatus:
        """Map incident severity to component status."""
        mapping = {
            IncidentSeverity.SEV1: ServiceStatus.MAJOR_OUTAGE,
            IncidentSeverity.SEV2: ServiceStatus.PARTIAL_OUTAGE,
            IncidentSeverity.SEV3: ServiceStatus.DEGRADED,
            IncidentSeverity.SEV4: ServiceStatus.DEGRADED,
            IncidentSeverity.SEV5: ServiceStatus.OPERATIONAL
        }
        return mapping.get(severity, ServiceStatus.DEGRADED)

    def _calculate_overall_status(self) -> ServiceStatus:
        """Calculate overall system status."""
        statuses = [c.status for c in self.components.values()]

        if ServiceStatus.MAJOR_OUTAGE in statuses:
            return ServiceStatus.MAJOR_OUTAGE
        elif ServiceStatus.PARTIAL_OUTAGE in statuses:
            return ServiceStatus.PARTIAL_OUTAGE
        elif ServiceStatus.DEGRADED in statuses:
            return ServiceStatus.DEGRADED
        elif ServiceStatus.MAINTENANCE in statuses:
            return ServiceStatus.MAINTENANCE
        else:
            return ServiceStatus.OPERATIONAL

    def generate_status_message(
        self,
        incident: PublicIncident,
        update_type: str
    ) -> str:
        """Generate formatted status message."""
        templates = {
            "investigating": (
                f"**{incident.title}**\n\n"
                f"We are currently investigating this issue. "
                f"Affected services: {', '.join(incident.affected_components)}.\n\n"
                f"We will provide updates as we learn more."
            ),
            "identified": (
                f"**{incident.title}**\n\n"
                f"We have identified the cause of this issue and are working on a fix. "
                f"Affected services: {', '.join(incident.affected_components)}.\n\n"
                f"We will provide updates on our progress."
            ),
            "monitoring": (
                f"**{incident.title}**\n\n"
                f"A fix has been implemented and we are monitoring the results. "
                f"Service should be returning to normal.\n\n"
                f"We will provide a final update once we confirm stability."
            ),
            "resolved": (
                f"**{incident.title}** - Resolved\n\n"
                f"This incident has been resolved. All services are operating normally.\n\n"
                f"We apologize for any inconvenience caused."
            )
        }

        return templates.get(update_type, f"Update on {incident.title}")
```

### 4.2 Communication Templates

```python
"""
Incident communication templates.
"""

from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime


@dataclass
class CommunicationTemplate:
    """Template for incident communications."""
    id: str
    name: str
    channel: str
    subject_template: str
    body_template: str
    variables: List[str]


class IncidentCommunications:
    """
    Manage incident communication templates and distribution.
    """

    def __init__(self):
        self.templates = self._load_templates()

    def _load_templates(self) -> Dict[str, CommunicationTemplate]:
        """Load communication templates."""
        return {
            "internal_alert": CommunicationTemplate(
                id="internal_alert",
                name="Internal Alert",
                channel="slack",
                subject_template="[{severity}] {title}",
                body_template="""
:rotating_light: *Incident Alert* :rotating_light:

*Severity:* {severity}
*Title:* {title}
*Status:* {status}

*Description:*
{description}

*Affected Services:* {affected_services}
*Detected At:* {detected_at}

*Incident Commander:* {incident_commander}
*Runbook:* {runbook_url}

---
:point_right: Join incident channel: #{incident_channel}
:point_right: Incident ID: {incident_id}
""",
                variables=[
                    "severity", "title", "status", "description",
                    "affected_services", "detected_at", "incident_commander",
                    "runbook_url", "incident_channel", "incident_id"
                ]
            ),

            "customer_notification_start": CommunicationTemplate(
                id="customer_notification_start",
                name="Customer Notification - Incident Start",
                channel="email",
                subject_template="Service Notification: {title}",
                body_template="""
Dear Customer,

We are currently experiencing an issue affecting {affected_services}.

*Current Status:* {status}

*Impact:* {impact_description}

Our team is actively working to resolve this issue. We will provide updates as we have more information.

You can monitor the current status at: {status_page_url}

We apologize for any inconvenience this may cause.

Best regards,
{company_name} Operations Team
""",
                variables=[
                    "title", "affected_services", "status",
                    "impact_description", "status_page_url", "company_name"
                ]
            ),

            "customer_notification_update": CommunicationTemplate(
                id="customer_notification_update",
                name="Customer Notification - Update",
                channel="email",
                subject_template="Service Update: {title}",
                body_template="""
Dear Customer,

This is an update regarding the ongoing incident affecting {affected_services}.

*Current Status:* {status}

*Update:*
{update_message}

*Next Steps:*
{next_steps}

You can monitor the current status at: {status_page_url}

We will continue to provide updates as we make progress.

Best regards,
{company_name} Operations Team
""",
                variables=[
                    "title", "affected_services", "status",
                    "update_message", "next_steps", "status_page_url", "company_name"
                ]
            ),

            "customer_notification_resolved": CommunicationTemplate(
                id="customer_notification_resolved",
                name="Customer Notification - Resolved",
                channel="email",
                subject_template="Resolved: {title}",
                body_template="""
Dear Customer,

The incident affecting {affected_services} has been resolved.

*Resolution:*
{resolution_summary}

*Timeline:*
- Incident Started: {started_at}
- Incident Resolved: {resolved_at}
- Total Duration: {duration}

*What We're Doing:*
{preventive_measures}

We apologize for any inconvenience this incident may have caused. If you have any questions or concerns, please contact our support team.

Best regards,
{company_name} Operations Team
""",
                variables=[
                    "title", "affected_services", "resolution_summary",
                    "started_at", "resolved_at", "duration",
                    "preventive_measures", "company_name"
                ]
            ),

            "executive_briefing": CommunicationTemplate(
                id="executive_briefing",
                name="Executive Briefing",
                channel="email",
                subject_template="[{severity}] Executive Briefing: {title}",
                body_template="""
*EXECUTIVE INCIDENT BRIEFING*

*Incident:* {title}
*Severity:* {severity}
*Status:* {status}

*Business Impact:*
- Affected Customers: {affected_customers}
- Estimated Revenue Impact: {revenue_impact}
- SLA Breach: {sla_breach}

*Current Actions:*
{current_actions}

*Timeline:*
{timeline_summary}

*Next Update:* {next_update_time}

*Incident Commander:* {incident_commander}
*Incident Channel:* #{incident_channel}

---
This is an automated briefing. For questions, contact the Incident Commander.
""",
                variables=[
                    "title", "severity", "status", "affected_customers",
                    "revenue_impact", "sla_breach", "current_actions",
                    "timeline_summary", "next_update_time",
                    "incident_commander", "incident_channel"
                ]
            )
        }

    def render_template(
        self,
        template_id: str,
        variables: Dict[str, str]
    ) -> Dict[str, str]:
        """Render a communication template with variables."""
        template = self.templates.get(template_id)
        if not template:
            raise ValueError(f"Template {template_id} not found")

        subject = template.subject_template
        body = template.body_template

        for var_name, var_value in variables.items():
            placeholder = "{" + var_name + "}"
            subject = subject.replace(placeholder, str(var_value))
            body = body.replace(placeholder, str(var_value))

        return {
            "subject": subject,
            "body": body,
            "channel": template.channel
        }

    def generate_incident_update(
        self,
        incident: 'Incident',
        update_type: str,
        audience: str = "internal"
    ) -> Dict[str, str]:
        """Generate an incident update communication."""
        # Map audience and type to template
        template_map = {
            ("internal", "alert"): "internal_alert",
            ("customer", "start"): "customer_notification_start",
            ("customer", "update"): "customer_notification_update",
            ("customer", "resolved"): "customer_notification_resolved",
            ("executive", "briefing"): "executive_briefing"
        }

        template_id = template_map.get((audience, update_type))
        if not template_id:
            raise ValueError(f"No template for {audience}/{update_type}")

        # Build variables from incident
        variables = {
            "severity": incident.severity.value.upper(),
            "title": incident.title,
            "status": incident.status.value,
            "description": incident.description,
            "affected_services": ", ".join(incident.impact.affected_services),
            "detected_at": incident.detected_at.strftime("%Y-%m-%d %H:%M UTC"),
            "incident_commander": incident.incident_commander or "Unassigned",
            "incident_id": incident.id,
            "incident_channel": f"incident-{incident.id}",
            "runbook_url": "https://runbooks.internal",
            "company_name": "Platform",
            "status_page_url": "https://status.platform.com"
        }

        if incident.resolved_at:
            variables["resolved_at"] = incident.resolved_at.strftime("%Y-%m-%d %H:%M UTC")
            duration = incident.resolved_at - incident.detected_at
            variables["duration"] = f"{int(duration.total_seconds() / 60)} minutes"

        return self.render_template(template_id, variables)
```

---

## 5. Post-Incident Process

### 5.1 Post-Incident Review

```python
"""
Post-incident review (PIR) management.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any


@dataclass
class ActionItem:
    """Action item from post-incident review."""
    id: str
    title: str
    description: str
    owner: str
    priority: str  # P0, P1, P2, P3
    due_date: datetime
    status: str  # open, in_progress, completed, deferred
    incident_id: str
    category: str  # process, tooling, monitoring, documentation
    created_at: datetime = field(default_factory=datetime.utcnow)
    completed_at: Optional[datetime] = None


@dataclass
class PostIncidentReview:
    """Post-incident review document."""
    id: str
    incident_id: str
    title: str
    date: datetime
    participants: List[str]
    facilitator: str

    # Summary
    summary: str
    impact_summary: str

    # Timeline
    timeline: List[Dict[str, Any]]

    # Analysis
    root_cause: str
    contributing_factors: List[str]
    what_went_well: List[str]
    what_could_improve: List[str]

    # Action items
    action_items: List[ActionItem]

    # Metrics
    detection_time_minutes: float
    response_time_minutes: float
    resolution_time_minutes: float
    customer_impact_duration_minutes: float

    # Status
    status: str = "draft"  # draft, scheduled, completed, published
    scheduled_date: Optional[datetime] = None
    published_at: Optional[datetime] = None


class PostIncidentReviewManager:
    """
    Manage post-incident reviews and action items.
    """

    def __init__(self):
        self.reviews: Dict[str, PostIncidentReview] = {}
        self.action_items: Dict[str, ActionItem] = {}

    def create_review(
        self,
        incident: 'Incident',
        facilitator: str
    ) -> PostIncidentReview:
        """Create a new post-incident review."""
        review = PostIncidentReview(
            id=f"PIR-{incident.id}",
            incident_id=incident.id,
            title=f"Post-Incident Review: {incident.title}",
            date=datetime.utcnow(),
            participants=incident.responders.copy(),
            facilitator=facilitator,
            summary="",
            impact_summary=self._generate_impact_summary(incident),
            timeline=self._extract_timeline(incident),
            root_cause=incident.root_cause or "",
            contributing_factors=incident.contributing_factors.copy(),
            what_went_well=[],
            what_could_improve=[],
            action_items=[],
            detection_time_minutes=incident.calculate_mtta() or 0,
            response_time_minutes=0,
            resolution_time_minutes=incident.calculate_mttr() or 0,
            customer_impact_duration_minutes=0
        )

        self.reviews[review.id] = review
        return review

    def add_action_item(
        self,
        review_id: str,
        title: str,
        description: str,
        owner: str,
        priority: str,
        due_date: datetime,
        category: str
    ) -> ActionItem:
        """Add an action item to a review."""
        review = self.reviews.get(review_id)
        if not review:
            raise ValueError(f"Review {review_id} not found")

        action_item = ActionItem(
            id=f"AI-{review.incident_id}-{len(review.action_items) + 1}",
            title=title,
            description=description,
            owner=owner,
            priority=priority,
            due_date=due_date,
            status="open",
            incident_id=review.incident_id,
            category=category
        )

        review.action_items.append(action_item)
        self.action_items[action_item.id] = action_item

        return action_item

    def update_action_item_status(
        self,
        action_item_id: str,
        status: str
    ) -> None:
        """Update action item status."""
        action_item = self.action_items.get(action_item_id)
        if action_item:
            action_item.status = status
            if status == "completed":
                action_item.completed_at = datetime.utcnow()

    def finalize_review(
        self,
        review_id: str,
        summary: str,
        what_went_well: List[str],
        what_could_improve: List[str]
    ) -> None:
        """Finalize a post-incident review."""
        review = self.reviews.get(review_id)
        if not review:
            raise ValueError(f"Review {review_id} not found")

        review.summary = summary
        review.what_went_well = what_went_well
        review.what_could_improve = what_could_improve
        review.status = "completed"

    def publish_review(self, review_id: str) -> None:
        """Publish a completed review."""
        review = self.reviews.get(review_id)
        if not review:
            raise ValueError(f"Review {review_id} not found")

        if review.status != "completed":
            raise ValueError("Review must be completed before publishing")

        review.status = "published"
        review.published_at = datetime.utcnow()

    def get_open_action_items(
        self,
        owner: Optional[str] = None
    ) -> List[ActionItem]:
        """Get all open action items."""
        items = [
            ai for ai in self.action_items.values()
            if ai.status not in ["completed", "deferred"]
        ]

        if owner:
            items = [ai for ai in items if ai.owner == owner]

        return sorted(items, key=lambda x: (
            {"P0": 0, "P1": 1, "P2": 2, "P3": 3}.get(x.priority, 4),
            x.due_date
        ))

    def get_overdue_action_items(self) -> List[ActionItem]:
        """Get overdue action items."""
        now = datetime.utcnow()
        return [
            ai for ai in self.action_items.values()
            if ai.status in ["open", "in_progress"] and ai.due_date < now
        ]

    def generate_review_document(
        self,
        review_id: str
    ) -> str:
        """Generate markdown document for review."""
        review = self.reviews.get(review_id)
        if not review:
            raise ValueError(f"Review {review_id} not found")

        doc = f"""# {review.title}

**Date:** {review.date.strftime('%Y-%m-%d')}
**Facilitator:** {review.facilitator}
**Participants:** {', '.join(review.participants)}
**Status:** {review.status}

## Summary

{review.summary}

## Impact

{review.impact_summary}

## Timeline

| Time | Event |
|------|-------|
"""

        for entry in review.timeline:
            doc += f"| {entry['time']} | {entry['description']} |\n"

        doc += f"""

## Root Cause

{review.root_cause}

### Contributing Factors

"""
        for factor in review.contributing_factors:
            doc += f"- {factor}\n"

        doc += """

## What Went Well

"""
        for item in review.what_went_well:
            doc += f"- {item}\n"

        doc += """

## What Could Improve

"""
        for item in review.what_could_improve:
            doc += f"- {item}\n"

        doc += """

## Metrics

| Metric | Value |
|--------|-------|
"""
        doc += f"| Time to Detect | {review.detection_time_minutes:.0f} minutes |\n"
        doc += f"| Time to Resolve | {review.resolution_time_minutes:.0f} minutes |\n"
        doc += f"| Customer Impact Duration | {review.customer_impact_duration_minutes:.0f} minutes |\n"

        doc += """

## Action Items

| ID | Title | Owner | Priority | Due Date | Status |
|----|-------|-------|----------|----------|--------|
"""
        for ai in review.action_items:
            doc += f"| {ai.id} | {ai.title} | {ai.owner} | {ai.priority} | {ai.due_date.strftime('%Y-%m-%d')} | {ai.status} |\n"

        return doc

    def _generate_impact_summary(self, incident: 'Incident') -> str:
        """Generate impact summary from incident."""
        impact = incident.impact
        summary = f"Affected services: {', '.join(impact.affected_services)}. "
        summary += f"Affected regions: {', '.join(impact.affected_regions)}. "
        summary += f"Estimated affected users: {impact.affected_users_estimate}."

        if impact.sla_breach:
            summary += " SLA breach occurred."

        return summary

    def _extract_timeline(self, incident: 'Incident') -> List[Dict[str, Any]]:
        """Extract timeline from incident."""
        timeline = []

        for entry in incident.timeline:
            timeline.append({
                "time": entry.timestamp.strftime("%H:%M UTC"),
                "description": entry.description
            })

        return timeline
```

---

## Summary

This Incident Response Guide provides comprehensive frameworks for:

1. **Incident Classification** - Severity levels, categories, and automatic classification

2. **Detection and Alerting** - Alert rules, conditions, escalation policies, and evaluation engine

3. **Response Procedures** - Role definitions, on-call management, and response playbooks

4. **Communication** - Status page management, customer notifications, and executive briefings

5. **Post-Incident Process** - Post-incident reviews, action item tracking, and documentation

Key principles:
- **Clear severity levels**: Well-defined impact thresholds and response expectations
- **Structured roles**: Defined responsibilities for each incident role
- **Playbook-driven**: Documented procedures for common scenarios
- **Communication focus**: Timely updates to all stakeholders
- **Blameless retrospectives**: Learning-focused post-incident reviews
- **Action tracking**: Ensure improvements are implemented

---

> **Navigation**
> [← 12.4 User Feedback](../12_user_developer_experience/12.4_user_feedback_iteration_guide.md) | **[Index](../README.md#15-repository-structure)** | [13.2 Disaster Recovery →](13.2_disaster_recovery_guide.md)
