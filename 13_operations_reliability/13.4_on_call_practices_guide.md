> **Navigation** | [â† 13.3 Capacity Planning](13.3_capacity_planning_guide.md) | [13.5 Operational Runbooks â†’](13.5_operational_runbooks_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | [13.1 Incident Response](13.1_incident_response_guide.md) &#124; Platform architecture &#124; Monitoring |
> | **Related** | [13.5 Runbooks](13.5_operational_runbooks_guide.md) &#124; [13.1 Incident Response](13.1_incident_response_guide.md) |
> | **Next** | [13.5 Operational Runbooks](13.5_operational_runbooks_guide.md) |

# 13.4 On-Call Practices Guide

## Document Information
- **Version**: 1.0
- **Last Updated**: 2024-01-15
- **Owner**: Site Reliability Engineering Team
- **Classification**: Internal

## Purpose and Scope

This guide establishes comprehensive on-call practices for maintaining 24/7 operational reliability of the Multi-Cloud RAG Platform. It covers scheduling, escalation procedures, compensation, tooling, and wellness considerations for on-call engineers.

## Prerequisites

- Understanding of incident response procedures (see 13.1)
- Familiarity with platform architecture and services
- Access to monitoring and alerting systems
- Completion of on-call training program

## 1. On-Call Program Structure

### 1.1 On-Call Tiers and Responsibilities

```python
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
import json


class OnCallTier(Enum):
    """On-call tier definitions."""
    PRIMARY = "primary"           # First responder
    SECONDARY = "secondary"       # Backup/escalation
    SPECIALIST = "specialist"     # Domain expert
    MANAGEMENT = "management"     # Leadership escalation


class ServiceDomain(Enum):
    """Service domain categories."""
    PLATFORM_CORE = "platform_core"
    LLM_INFERENCE = "llm_inference"
    RAG_PIPELINE = "rag_pipeline"
    DATA_INFRASTRUCTURE = "data_infrastructure"
    NETWORKING = "networking"
    SECURITY = "security"


@dataclass
class OnCallRole:
    """Definition of an on-call role."""
    tier: OnCallTier
    domains: List[ServiceDomain]
    response_time_minutes: int
    escalation_time_minutes: int
    responsibilities: List[str]
    required_skills: List[str]
    compensation_multiplier: float


class OnCallRoleRegistry:
    """Registry of on-call roles and responsibilities."""

    def __init__(self):
        self.roles = self._initialize_roles()

    def _initialize_roles(self) -> Dict[str, OnCallRole]:
        return {
            "primary_platform": OnCallRole(
                tier=OnCallTier.PRIMARY,
                domains=[ServiceDomain.PLATFORM_CORE, ServiceDomain.RAG_PIPELINE],
                response_time_minutes=5,
                escalation_time_minutes=15,
                responsibilities=[
                    "Acknowledge all P1/P2 alerts within 5 minutes",
                    "Perform initial triage and assessment",
                    "Execute documented runbooks",
                    "Escalate to specialists when needed",
                    "Communicate status updates",
                    "Document actions in incident timeline"
                ],
                required_skills=[
                    "Kubernetes administration",
                    "Platform service architecture",
                    "Basic LLM troubleshooting",
                    "Database operations"
                ],
                compensation_multiplier=1.5
            ),
            "primary_llm": OnCallRole(
                tier=OnCallTier.PRIMARY,
                domains=[ServiceDomain.LLM_INFERENCE],
                response_time_minutes=5,
                escalation_time_minutes=15,
                responsibilities=[
                    "Monitor LLM provider health",
                    "Manage provider failover",
                    "Handle rate limiting issues",
                    "Optimize inference performance",
                    "Coordinate with provider support"
                ],
                required_skills=[
                    "LLM provider APIs (OpenAI, Anthropic, etc.)",
                    "Token management and optimization",
                    "Model performance tuning",
                    "Cost optimization"
                ],
                compensation_multiplier=1.5
            ),
            "secondary_all": OnCallRole(
                tier=OnCallTier.SECONDARY,
                domains=list(ServiceDomain),
                response_time_minutes=15,
                escalation_time_minutes=30,
                responsibilities=[
                    "Backup for primary on-call",
                    "Assist with complex incidents",
                    "Provide additional context",
                    "Take over if primary unavailable"
                ],
                required_skills=[
                    "Broad platform knowledge",
                    "Incident coordination",
                    "Cross-team communication"
                ],
                compensation_multiplier=1.25
            ),
            "specialist_data": OnCallRole(
                tier=OnCallTier.SPECIALIST,
                domains=[ServiceDomain.DATA_INFRASTRUCTURE],
                response_time_minutes=30,
                escalation_time_minutes=60,
                responsibilities=[
                    "Handle data pipeline incidents",
                    "Database recovery operations",
                    "Vector store troubleshooting",
                    "Data consistency issues"
                ],
                required_skills=[
                    "PostgreSQL administration",
                    "Vector database operations",
                    "Data pipeline debugging",
                    "Backup and recovery"
                ],
                compensation_multiplier=1.75
            ),
            "management_escalation": OnCallRole(
                tier=OnCallTier.MANAGEMENT,
                domains=list(ServiceDomain),
                response_time_minutes=15,
                escalation_time_minutes=30,
                responsibilities=[
                    "Executive communication",
                    "Resource allocation decisions",
                    "Customer escalation handling",
                    "Cross-organization coordination",
                    "Post-incident accountability"
                ],
                required_skills=[
                    "Leadership experience",
                    "Crisis communication",
                    "Stakeholder management"
                ],
                compensation_multiplier=1.0  # Salaried
            )
        }

    def get_role(self, role_name: str) -> Optional[OnCallRole]:
        return self.roles.get(role_name)

    def get_roles_for_domain(self, domain: ServiceDomain) -> List[OnCallRole]:
        return [
            role for role in self.roles.values()
            if domain in role.domains
        ]
```

### 1.2 On-Call Scheduling System

```python
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
import calendar
from enum import Enum


class ShiftType(Enum):
    """Types of on-call shifts."""
    WEEKDAY_BUSINESS = "weekday_business"      # 9am-6pm weekdays
    WEEKDAY_EVENING = "weekday_evening"        # 6pm-9am weekdays
    WEEKEND_DAY = "weekend_day"                # 9am-9pm weekends
    WEEKEND_NIGHT = "weekend_night"            # 9pm-9am weekends
    HOLIDAY = "holiday"                        # Full day holidays


@dataclass
class OnCallShift:
    """Represents a single on-call shift."""
    shift_id: str
    engineer_id: str
    role_name: str
    shift_type: ShiftType
    start_time: datetime
    end_time: datetime
    is_override: bool = False
    override_reason: Optional[str] = None
    swapped_with: Optional[str] = None


@dataclass
class OnCallSchedule:
    """On-call schedule for a team."""
    team_id: str
    rotation_name: str
    shifts: List[OnCallShift] = field(default_factory=list)
    handoff_time: str = "09:00"  # Daily handoff time
    rotation_length_days: int = 7

    def get_current_oncall(self, role_name: str) -> Optional[OnCallShift]:
        now = datetime.utcnow()
        for shift in self.shifts:
            if (shift.role_name == role_name and
                shift.start_time <= now <= shift.end_time):
                return shift
        return None


class OnCallScheduler:
    """Manages on-call scheduling and rotations."""

    def __init__(self, config: Dict):
        self.config = config
        self.schedules: Dict[str, OnCallSchedule] = {}
        self.engineer_availability: Dict[str, List[Tuple[datetime, datetime]]] = {}
        self.holidays: List[datetime] = []

    def create_rotation(
        self,
        team_id: str,
        rotation_name: str,
        engineers: List[str],
        role_name: str,
        start_date: datetime,
        weeks_ahead: int = 12
    ) -> OnCallSchedule:
        """Create a rotating on-call schedule."""
        schedule = OnCallSchedule(
            team_id=team_id,
            rotation_name=rotation_name
        )

        current_date = start_date
        engineer_index = 0

        for week in range(weeks_ahead):
            # Skip unavailable engineers
            attempts = 0
            while attempts < len(engineers):
                engineer = engineers[engineer_index % len(engineers)]
                if self._is_available(engineer, current_date,
                                      current_date + timedelta(days=7)):
                    break
                engineer_index += 1
                attempts += 1

            # Create shift
            shift = OnCallShift(
                shift_id=f"{rotation_name}-{week}",
                engineer_id=engineers[engineer_index % len(engineers)],
                role_name=role_name,
                shift_type=ShiftType.WEEKDAY_BUSINESS,
                start_time=current_date,
                end_time=current_date + timedelta(days=7)
            )
            schedule.shifts.append(shift)

            engineer_index += 1
            current_date += timedelta(days=7)

        self.schedules[f"{team_id}-{rotation_name}"] = schedule
        return schedule

    def _is_available(
        self,
        engineer_id: str,
        start: datetime,
        end: datetime
    ) -> bool:
        """Check if engineer is available for the period."""
        unavailable_periods = self.engineer_availability.get(engineer_id, [])
        for unavail_start, unavail_end in unavailable_periods:
            if not (end <= unavail_start or start >= unavail_end):
                return False
        return True

    def request_time_off(
        self,
        engineer_id: str,
        start: datetime,
        end: datetime,
        reason: str
    ) -> bool:
        """Request time off from on-call duty."""
        if engineer_id not in self.engineer_availability:
            self.engineer_availability[engineer_id] = []

        # Check if they have shifts during this period
        affected_shifts = self._get_affected_shifts(engineer_id, start, end)

        if affected_shifts:
            # Need to find coverage before approving
            coverage_found = self._find_coverage(affected_shifts)
            if not coverage_found:
                return False

        self.engineer_availability[engineer_id].append((start, end))
        return True

    def _get_affected_shifts(
        self,
        engineer_id: str,
        start: datetime,
        end: datetime
    ) -> List[OnCallShift]:
        """Get shifts affected by the time off request."""
        affected = []
        for schedule in self.schedules.values():
            for shift in schedule.shifts:
                if (shift.engineer_id == engineer_id and
                    not (shift.end_time <= start or shift.start_time >= end)):
                    affected.append(shift)
        return affected

    def _find_coverage(self, shifts: List[OnCallShift]) -> bool:
        """Attempt to find coverage for shifts."""
        # Implementation would check team members for availability
        return True

    def swap_shifts(
        self,
        shift1_id: str,
        shift2_id: str,
        reason: str
    ) -> bool:
        """Swap two on-call shifts between engineers."""
        shift1 = self._find_shift(shift1_id)
        shift2 = self._find_shift(shift2_id)

        if not shift1 or not shift2:
            return False

        # Swap engineers
        shift1.engineer_id, shift2.engineer_id = shift2.engineer_id, shift1.engineer_id
        shift1.swapped_with = shift2_id
        shift2.swapped_with = shift1_id
        shift1.is_override = True
        shift2.is_override = True
        shift1.override_reason = reason
        shift2.override_reason = reason

        return True

    def _find_shift(self, shift_id: str) -> Optional[OnCallShift]:
        for schedule in self.schedules.values():
            for shift in schedule.shifts:
                if shift.shift_id == shift_id:
                    return shift
        return None

    def create_override(
        self,
        original_shift_id: str,
        override_engineer_id: str,
        start_time: datetime,
        end_time: datetime,
        reason: str
    ) -> OnCallShift:
        """Create a temporary override for a shift."""
        original = self._find_shift(original_shift_id)
        if not original:
            raise ValueError(f"Shift {original_shift_id} not found")

        override = OnCallShift(
            shift_id=f"{original_shift_id}-override",
            engineer_id=override_engineer_id,
            role_name=original.role_name,
            shift_type=original.shift_type,
            start_time=start_time,
            end_time=end_time,
            is_override=True,
            override_reason=reason
        )

        # Find the schedule and add override
        for schedule in self.schedules.values():
            if original in schedule.shifts:
                schedule.shifts.append(override)
                break

        return override

    def get_upcoming_shifts(
        self,
        engineer_id: str,
        days_ahead: int = 30
    ) -> List[OnCallShift]:
        """Get upcoming shifts for an engineer."""
        now = datetime.utcnow()
        end_date = now + timedelta(days=days_ahead)

        upcoming = []
        for schedule in self.schedules.values():
            for shift in schedule.shifts:
                if (shift.engineer_id == engineer_id and
                    shift.start_time >= now and
                    shift.start_time <= end_date):
                    upcoming.append(shift)

        return sorted(upcoming, key=lambda s: s.start_time)

    def calculate_on_call_load(
        self,
        engineer_id: str,
        period_days: int = 90
    ) -> Dict:
        """Calculate on-call load for fairness tracking."""
        now = datetime.utcnow()
        period_start = now - timedelta(days=period_days)

        total_hours = 0
        weekend_hours = 0
        holiday_hours = 0
        incident_count = 0  # Would be populated from incident system

        for schedule in self.schedules.values():
            for shift in schedule.shifts:
                if (shift.engineer_id == engineer_id and
                    shift.start_time >= period_start and
                    shift.end_time <= now):

                    hours = (shift.end_time - shift.start_time).total_seconds() / 3600
                    total_hours += hours

                    if shift.shift_type in [ShiftType.WEEKEND_DAY, ShiftType.WEEKEND_NIGHT]:
                        weekend_hours += hours
                    if shift.shift_type == ShiftType.HOLIDAY:
                        holiday_hours += hours

        return {
            "engineer_id": engineer_id,
            "period_days": period_days,
            "total_hours": total_hours,
            "weekend_hours": weekend_hours,
            "holiday_hours": holiday_hours,
            "incident_count": incident_count,
            "average_weekly_hours": total_hours / (period_days / 7)
        }


class FairnessBalancer:
    """Ensures fair distribution of on-call burden."""

    def __init__(self, scheduler: OnCallScheduler):
        self.scheduler = scheduler

    def analyze_team_fairness(
        self,
        team_engineers: List[str],
        period_days: int = 90
    ) -> Dict:
        """Analyze on-call fairness across team."""
        loads = {}
        for engineer in team_engineers:
            loads[engineer] = self.scheduler.calculate_on_call_load(
                engineer, period_days
            )

        total_hours = [l["total_hours"] for l in loads.values()]
        avg_hours = sum(total_hours) / len(total_hours) if total_hours else 0

        fairness_scores = {}
        for engineer, load in loads.items():
            deviation = abs(load["total_hours"] - avg_hours) / avg_hours if avg_hours else 0
            fairness_scores[engineer] = {
                "load": load,
                "deviation_from_average": deviation,
                "fairness_score": max(0, 1 - deviation)
            }

        return {
            "team_average_hours": avg_hours,
            "individual_scores": fairness_scores,
            "team_fairness_score": sum(
                s["fairness_score"] for s in fairness_scores.values()
            ) / len(fairness_scores) if fairness_scores else 1.0
        }

    def recommend_rebalancing(
        self,
        team_engineers: List[str]
    ) -> List[Dict]:
        """Recommend shift swaps to improve fairness."""
        fairness = self.analyze_team_fairness(team_engineers)
        recommendations = []

        # Find over-burdened and under-burdened engineers
        scores = fairness["individual_scores"]
        avg = fairness["team_average_hours"]

        over_burdened = [
            e for e, s in scores.items()
            if s["load"]["total_hours"] > avg * 1.2
        ]
        under_burdened = [
            e for e, s in scores.items()
            if s["load"]["total_hours"] < avg * 0.8
        ]

        for over_eng in over_burdened:
            for under_eng in under_burdened:
                # Find upcoming shifts that could be swapped
                over_shifts = self.scheduler.get_upcoming_shifts(over_eng, 30)
                if over_shifts:
                    recommendations.append({
                        "type": "swap",
                        "from_engineer": over_eng,
                        "to_engineer": under_eng,
                        "shift_id": over_shifts[0].shift_id,
                        "reason": "fairness_rebalancing"
                    })
                    break

        return recommendations
```

## 2. Escalation Procedures

### 2.1 Escalation Matrix

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
from datetime import datetime, timedelta


class EscalationTrigger(Enum):
    """Triggers for escalation."""
    NO_ACKNOWLEDGMENT = "no_acknowledgment"
    NO_PROGRESS = "no_progress"
    SEVERITY_INCREASE = "severity_increase"
    CUSTOMER_IMPACT = "customer_impact"
    EXECUTIVE_REQUEST = "executive_request"
    TIME_THRESHOLD = "time_threshold"


@dataclass
class EscalationLevel:
    """Definition of an escalation level."""
    level: int
    name: str
    contacts: List[str]  # Role names, not individuals
    notification_methods: List[str]
    time_to_escalate_minutes: int
    required_actions: List[str]


class EscalationMatrix:
    """Manages escalation paths and procedures."""

    def __init__(self):
        self.levels = self._initialize_levels()
        self.severity_mappings = self._initialize_severity_mappings()

    def _initialize_levels(self) -> Dict[int, EscalationLevel]:
        return {
            1: EscalationLevel(
                level=1,
                name="Primary On-Call",
                contacts=["primary_oncall"],
                notification_methods=["pagerduty", "slack", "sms"],
                time_to_escalate_minutes=15,
                required_actions=[
                    "Acknowledge alert",
                    "Begin initial assessment",
                    "Start incident channel"
                ]
            ),
            2: EscalationLevel(
                level=2,
                name="Secondary On-Call + Lead",
                contacts=["secondary_oncall", "team_lead"],
                notification_methods=["pagerduty", "phone", "slack"],
                time_to_escalate_minutes=30,
                required_actions=[
                    "Join incident response",
                    "Assess need for specialists",
                    "Update status page"
                ]
            ),
            3: EscalationLevel(
                level=3,
                name="Specialist Team",
                contacts=["specialist_oncall", "senior_engineer"],
                notification_methods=["pagerduty", "phone", "slack", "email"],
                time_to_escalate_minutes=45,
                required_actions=[
                    "Deep technical investigation",
                    "Coordinate cross-team response",
                    "Implement complex mitigations"
                ]
            ),
            4: EscalationLevel(
                level=4,
                name="Engineering Management",
                contacts=["engineering_manager", "director_engineering"],
                notification_methods=["phone", "sms", "email"],
                time_to_escalate_minutes=60,
                required_actions=[
                    "Resource allocation decisions",
                    "Customer communication approval",
                    "Executive briefing preparation"
                ]
            ),
            5: EscalationLevel(
                level=5,
                name="Executive Leadership",
                contacts=["vp_engineering", "cto", "ceo"],
                notification_methods=["phone", "sms"],
                time_to_escalate_minutes=90,
                required_actions=[
                    "Crisis management",
                    "External communication approval",
                    "Business continuity decisions"
                ]
            )
        }

    def _initialize_severity_mappings(self) -> Dict[str, int]:
        """Map severity levels to starting escalation level."""
        return {
            "SEV1": 2,  # Start at level 2 for critical
            "SEV2": 1,  # Start at level 1 for high
            "SEV3": 1,  # Start at level 1 for medium
            "SEV4": 1,  # Start at level 1 for low
            "SEV5": 1   # Start at level 1 for minimal
        }

    def get_escalation_path(
        self,
        severity: str,
        current_level: int = 0
    ) -> List[EscalationLevel]:
        """Get the escalation path for a severity level."""
        start_level = max(
            self.severity_mappings.get(severity, 1),
            current_level + 1
        )

        path = []
        for level in range(start_level, len(self.levels) + 1):
            path.append(self.levels[level])

        return path


class EscalationManager:
    """Manages active escalations."""

    def __init__(
        self,
        matrix: EscalationMatrix,
        scheduler: OnCallScheduler,
        notification_service: 'NotificationService'
    ):
        self.matrix = matrix
        self.scheduler = scheduler
        self.notification_service = notification_service
        self.active_escalations: Dict[str, Dict] = {}

    def initiate_escalation(
        self,
        incident_id: str,
        severity: str,
        trigger: EscalationTrigger,
        context: Dict
    ) -> Dict:
        """Initiate escalation for an incident."""
        escalation_path = self.matrix.get_escalation_path(severity)

        if not escalation_path:
            return {"error": "No escalation path available"}

        first_level = escalation_path[0]

        escalation = {
            "incident_id": incident_id,
            "severity": severity,
            "trigger": trigger.value,
            "current_level": first_level.level,
            "started_at": datetime.utcnow().isoformat(),
            "escalation_history": [],
            "status": "active"
        }

        # Notify contacts at first level
        self._notify_level(incident_id, first_level, context)

        escalation["escalation_history"].append({
            "level": first_level.level,
            "notified_at": datetime.utcnow().isoformat(),
            "contacts": first_level.contacts,
            "trigger": trigger.value
        })

        self.active_escalations[incident_id] = escalation
        return escalation

    def escalate(
        self,
        incident_id: str,
        trigger: EscalationTrigger,
        context: Dict
    ) -> Optional[Dict]:
        """Escalate to the next level."""
        if incident_id not in self.active_escalations:
            return None

        escalation = self.active_escalations[incident_id]
        current_level = escalation["current_level"]

        if current_level >= len(self.matrix.levels):
            return {"error": "Already at highest escalation level"}

        next_level = self.matrix.levels[current_level + 1]

        # Notify contacts at next level
        self._notify_level(incident_id, next_level, context)

        escalation["current_level"] = next_level.level
        escalation["escalation_history"].append({
            "level": next_level.level,
            "notified_at": datetime.utcnow().isoformat(),
            "contacts": next_level.contacts,
            "trigger": trigger.value
        })

        return escalation

    def _notify_level(
        self,
        incident_id: str,
        level: EscalationLevel,
        context: Dict
    ):
        """Send notifications for an escalation level."""
        # Resolve contacts to actual engineers
        engineers = []
        for role in level.contacts:
            # Get current on-call for each role
            for schedule in self.scheduler.schedules.values():
                shift = schedule.get_current_oncall(role)
                if shift:
                    engineers.append(shift.engineer_id)

        message = self._build_escalation_message(incident_id, level, context)

        for method in level.notification_methods:
            for engineer in engineers:
                self.notification_service.send(
                    recipient=engineer,
                    method=method,
                    message=message,
                    urgency="high"
                )

    def _build_escalation_message(
        self,
        incident_id: str,
        level: EscalationLevel,
        context: Dict
    ) -> str:
        return f"""
ðŸš¨ ESCALATION - Level {level.level} ({level.name})

Incident: {incident_id}
Severity: {context.get('severity', 'Unknown')}
Description: {context.get('description', 'No description')}

Required Actions:
{chr(10).join(f'â€¢ {action}' for action in level.required_actions)}

Incident Channel: #incident-{incident_id}
Dashboard: https://dashboard.example.com/incidents/{incident_id}
"""

    def check_escalation_timers(self):
        """Check if any escalations need to be triggered by time."""
        now = datetime.utcnow()

        for incident_id, escalation in self.active_escalations.items():
            if escalation["status"] != "active":
                continue

            current_level = self.matrix.levels[escalation["current_level"]]
            last_escalation = escalation["escalation_history"][-1]
            last_time = datetime.fromisoformat(last_escalation["notified_at"])

            threshold = timedelta(minutes=current_level.time_to_escalate_minutes)

            if now - last_time >= threshold:
                # Check if acknowledged
                # If not, auto-escalate
                self.escalate(
                    incident_id,
                    EscalationTrigger.TIME_THRESHOLD,
                    {"reason": "Time threshold exceeded without resolution"}
                )

    def acknowledge_escalation(
        self,
        incident_id: str,
        engineer_id: str
    ) -> bool:
        """Acknowledge an escalation to pause auto-escalation."""
        if incident_id not in self.active_escalations:
            return False

        escalation = self.active_escalations[incident_id]
        escalation["acknowledged_by"] = engineer_id
        escalation["acknowledged_at"] = datetime.utcnow().isoformat()

        return True

    def resolve_escalation(
        self,
        incident_id: str,
        resolution: str
    ) -> bool:
        """Resolve and close an escalation."""
        if incident_id not in self.active_escalations:
            return False

        escalation = self.active_escalations[incident_id]
        escalation["status"] = "resolved"
        escalation["resolved_at"] = datetime.utcnow().isoformat()
        escalation["resolution"] = resolution

        return True
```

## 3. On-Call Tooling

### 3.1 PagerDuty Integration

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime
import aiohttp
import json


@dataclass
class PagerDutyConfig:
    """PagerDuty configuration."""
    api_key: str
    service_ids: Dict[str, str]
    escalation_policy_ids: Dict[str, str]
    webhook_url: str


class PagerDutyIntegration:
    """Integration with PagerDuty for alerting and scheduling."""

    def __init__(self, config: PagerDutyConfig):
        self.config = config
        self.base_url = "https://api.pagerduty.com"
        self.headers = {
            "Authorization": f"Token token={config.api_key}",
            "Content-Type": "application/json"
        }

    async def create_incident(
        self,
        service_key: str,
        title: str,
        details: Dict,
        severity: str,
        dedup_key: Optional[str] = None
    ) -> Dict:
        """Create a PagerDuty incident."""
        service_id = self.config.service_ids.get(service_key)
        if not service_id:
            raise ValueError(f"Unknown service: {service_key}")

        payload = {
            "incident": {
                "type": "incident",
                "title": title,
                "service": {
                    "id": service_id,
                    "type": "service_reference"
                },
                "urgency": self._map_severity_to_urgency(severity),
                "body": {
                    "type": "incident_body",
                    "details": json.dumps(details)
                }
            }
        }

        if dedup_key:
            payload["incident"]["incident_key"] = dedup_key

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/incidents",
                headers=self.headers,
                json=payload
            ) as response:
                return await response.json()

    def _map_severity_to_urgency(self, severity: str) -> str:
        mapping = {
            "SEV1": "high",
            "SEV2": "high",
            "SEV3": "low",
            "SEV4": "low",
            "SEV5": "low"
        }
        return mapping.get(severity, "low")

    async def acknowledge_incident(
        self,
        incident_id: str,
        user_email: str
    ) -> Dict:
        """Acknowledge a PagerDuty incident."""
        user_id = await self._get_user_id(user_email)

        payload = {
            "incident": {
                "type": "incident_reference",
                "status": "acknowledged"
            }
        }

        headers = {
            **self.headers,
            "From": user_email
        }

        async with aiohttp.ClientSession() as session:
            async with session.put(
                f"{self.base_url}/incidents/{incident_id}",
                headers=headers,
                json=payload
            ) as response:
                return await response.json()

    async def resolve_incident(
        self,
        incident_id: str,
        user_email: str,
        resolution_note: str
    ) -> Dict:
        """Resolve a PagerDuty incident."""
        payload = {
            "incident": {
                "type": "incident_reference",
                "status": "resolved"
            }
        }

        headers = {
            **self.headers,
            "From": user_email
        }

        async with aiohttp.ClientSession() as session:
            async with session.put(
                f"{self.base_url}/incidents/{incident_id}",
                headers=headers,
                json=payload
            ) as response:
                result = await response.json()

        # Add resolution note
        await self._add_note(incident_id, user_email, resolution_note)

        return result

    async def _add_note(
        self,
        incident_id: str,
        user_email: str,
        content: str
    ) -> Dict:
        """Add a note to an incident."""
        payload = {
            "note": {
                "content": content
            }
        }

        headers = {
            **self.headers,
            "From": user_email
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/incidents/{incident_id}/notes",
                headers=headers,
                json=payload
            ) as response:
                return await response.json()

    async def get_on_call(
        self,
        escalation_policy_key: str
    ) -> List[Dict]:
        """Get current on-call engineers for an escalation policy."""
        policy_id = self.config.escalation_policy_ids.get(escalation_policy_key)
        if not policy_id:
            raise ValueError(f"Unknown escalation policy: {escalation_policy_key}")

        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.base_url}/oncalls",
                headers=self.headers,
                params={
                    "escalation_policy_ids[]": policy_id,
                    "include[]": ["users"]
                }
            ) as response:
                data = await response.json()

        oncalls = []
        for oncall in data.get("oncalls", []):
            oncalls.append({
                "user": oncall.get("user", {}).get("summary"),
                "email": oncall.get("user", {}).get("email"),
                "escalation_level": oncall.get("escalation_level"),
                "start": oncall.get("start"),
                "end": oncall.get("end")
            })

        return oncalls

    async def create_override(
        self,
        schedule_id: str,
        user_email: str,
        start: datetime,
        end: datetime
    ) -> Dict:
        """Create a schedule override."""
        user_id = await self._get_user_id(user_email)

        payload = {
            "override": {
                "start": start.isoformat(),
                "end": end.isoformat(),
                "user": {
                    "id": user_id,
                    "type": "user_reference"
                }
            }
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/schedules/{schedule_id}/overrides",
                headers=self.headers,
                json=payload
            ) as response:
                return await response.json()

    async def _get_user_id(self, email: str) -> str:
        """Get PagerDuty user ID from email."""
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.base_url}/users",
                headers=self.headers,
                params={"query": email}
            ) as response:
                data = await response.json()

        users = data.get("users", [])
        if not users:
            raise ValueError(f"User not found: {email}")

        return users[0]["id"]


class OpsGenieIntegration:
    """Integration with OpsGenie for alerting."""

    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = "https://api.opsgenie.com/v2"
        self.headers = {
            "Authorization": f"GenieKey {api_key}",
            "Content-Type": "application/json"
        }

    async def create_alert(
        self,
        message: str,
        description: str,
        priority: str,
        tags: List[str],
        details: Dict
    ) -> Dict:
        """Create an OpsGenie alert."""
        payload = {
            "message": message,
            "description": description,
            "priority": priority,
            "tags": tags,
            "details": details
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/alerts",
                headers=self.headers,
                json=payload
            ) as response:
                return await response.json()

    async def acknowledge_alert(
        self,
        alert_id: str,
        user: str,
        note: Optional[str] = None
    ) -> Dict:
        """Acknowledge an alert."""
        payload = {
            "user": user
        }
        if note:
            payload["note"] = note

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/alerts/{alert_id}/acknowledge",
                headers=self.headers,
                json=payload
            ) as response:
                return await response.json()

    async def close_alert(
        self,
        alert_id: str,
        user: str,
        note: str
    ) -> Dict:
        """Close an alert."""
        payload = {
            "user": user,
            "note": note
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/alerts/{alert_id}/close",
                headers=self.headers,
                json=payload
            ) as response:
                return await response.json()
```

### 3.2 On-Call Dashboard

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from enum import Enum


class DashboardMetricType(Enum):
    """Types of on-call metrics."""
    INCIDENTS_HANDLED = "incidents_handled"
    MEAN_TIME_TO_ACK = "mean_time_to_ack"
    MEAN_TIME_TO_RESOLVE = "mean_time_to_resolve"
    ESCALATION_RATE = "escalation_rate"
    PAGES_PER_SHIFT = "pages_per_shift"
    SLEEP_INTERRUPTIONS = "sleep_interruptions"


@dataclass
class OnCallMetrics:
    """Metrics for on-call performance."""
    engineer_id: str
    period_start: datetime
    period_end: datetime
    incidents_handled: int
    mean_time_to_ack_seconds: float
    mean_time_to_resolve_seconds: float
    escalation_count: int
    after_hours_pages: int
    false_positive_count: int


class OnCallDashboard:
    """Dashboard for on-call metrics and visibility."""

    def __init__(
        self,
        scheduler: OnCallScheduler,
        incident_store: 'IncidentStore',
        metrics_store: 'MetricsStore'
    ):
        self.scheduler = scheduler
        self.incident_store = incident_store
        self.metrics_store = metrics_store

    def get_current_on_call_status(self) -> Dict:
        """Get current on-call status across all rotations."""
        status = {
            "timestamp": datetime.utcnow().isoformat(),
            "rotations": []
        }

        for key, schedule in self.scheduler.schedules.items():
            rotation_status = {
                "rotation_name": schedule.rotation_name,
                "team_id": schedule.team_id,
                "current_shifts": []
            }

            now = datetime.utcnow()
            for shift in schedule.shifts:
                if shift.start_time <= now <= shift.end_time:
                    rotation_status["current_shifts"].append({
                        "engineer_id": shift.engineer_id,
                        "role": shift.role_name,
                        "shift_start": shift.start_time.isoformat(),
                        "shift_end": shift.end_time.isoformat(),
                        "is_override": shift.is_override
                    })

            status["rotations"].append(rotation_status)

        return status

    def get_engineer_metrics(
        self,
        engineer_id: str,
        period_days: int = 30
    ) -> OnCallMetrics:
        """Get on-call metrics for an engineer."""
        period_end = datetime.utcnow()
        period_start = period_end - timedelta(days=period_days)

        # Get incidents handled by this engineer
        incidents = self.incident_store.get_incidents_by_responder(
            engineer_id, period_start, period_end
        )

        ack_times = []
        resolve_times = []
        escalations = 0
        after_hours = 0
        false_positives = 0

        for incident in incidents:
            if incident.get("acknowledged_at") and incident.get("created_at"):
                ack_time = (
                    datetime.fromisoformat(incident["acknowledged_at"]) -
                    datetime.fromisoformat(incident["created_at"])
                ).total_seconds()
                ack_times.append(ack_time)

            if incident.get("resolved_at") and incident.get("created_at"):
                resolve_time = (
                    datetime.fromisoformat(incident["resolved_at"]) -
                    datetime.fromisoformat(incident["created_at"])
                ).total_seconds()
                resolve_times.append(resolve_time)

            if incident.get("was_escalated"):
                escalations += 1

            if incident.get("is_after_hours"):
                after_hours += 1

            if incident.get("resolution") == "false_positive":
                false_positives += 1

        return OnCallMetrics(
            engineer_id=engineer_id,
            period_start=period_start,
            period_end=period_end,
            incidents_handled=len(incidents),
            mean_time_to_ack_seconds=sum(ack_times) / len(ack_times) if ack_times else 0,
            mean_time_to_resolve_seconds=sum(resolve_times) / len(resolve_times) if resolve_times else 0,
            escalation_count=escalations,
            after_hours_pages=after_hours,
            false_positive_count=false_positives
        )

    def get_team_health_report(
        self,
        team_engineers: List[str],
        period_days: int = 30
    ) -> Dict:
        """Generate team on-call health report."""
        individual_metrics = {}
        for engineer in team_engineers:
            individual_metrics[engineer] = self.get_engineer_metrics(
                engineer, period_days
            )

        # Calculate team aggregates
        total_incidents = sum(m.incidents_handled for m in individual_metrics.values())
        avg_ack_time = sum(m.mean_time_to_ack_seconds for m in individual_metrics.values()) / len(individual_metrics)
        avg_resolve_time = sum(m.mean_time_to_resolve_seconds for m in individual_metrics.values()) / len(individual_metrics)
        total_escalations = sum(m.escalation_count for m in individual_metrics.values())
        total_after_hours = sum(m.after_hours_pages for m in individual_metrics.values())
        total_false_positives = sum(m.false_positive_count for m in individual_metrics.values())

        # Calculate health score
        health_indicators = {
            "ack_time_healthy": avg_ack_time < 300,  # < 5 minutes
            "resolve_time_healthy": avg_resolve_time < 3600,  # < 1 hour
            "escalation_rate_healthy": (total_escalations / total_incidents if total_incidents else 0) < 0.2,
            "false_positive_rate_healthy": (total_false_positives / total_incidents if total_incidents else 0) < 0.1,
            "load_balanced": self._check_load_balance(individual_metrics)
        }

        health_score = sum(health_indicators.values()) / len(health_indicators) * 100

        return {
            "period_days": period_days,
            "team_size": len(team_engineers),
            "total_incidents": total_incidents,
            "average_ack_time_seconds": avg_ack_time,
            "average_resolve_time_seconds": avg_resolve_time,
            "escalation_rate": total_escalations / total_incidents if total_incidents else 0,
            "false_positive_rate": total_false_positives / total_incidents if total_incidents else 0,
            "after_hours_page_rate": total_after_hours / total_incidents if total_incidents else 0,
            "health_score": health_score,
            "health_indicators": health_indicators,
            "individual_metrics": {
                eng: {
                    "incidents": m.incidents_handled,
                    "mean_ack_time": m.mean_time_to_ack_seconds,
                    "mean_resolve_time": m.mean_time_to_resolve_seconds
                }
                for eng, m in individual_metrics.items()
            }
        }

    def _check_load_balance(
        self,
        metrics: Dict[str, OnCallMetrics]
    ) -> bool:
        """Check if on-call load is balanced across team."""
        if not metrics:
            return True

        incident_counts = [m.incidents_handled for m in metrics.values()]
        avg = sum(incident_counts) / len(incident_counts)

        if avg == 0:
            return True

        # Check if any engineer has more than 50% deviation from average
        for count in incident_counts:
            if abs(count - avg) / avg > 0.5:
                return False

        return True

    def generate_weekly_summary(
        self,
        team_engineers: List[str]
    ) -> str:
        """Generate weekly on-call summary report."""
        report = self.get_team_health_report(team_engineers, period_days=7)

        summary = f"""
# Weekly On-Call Summary Report

**Period**: Last 7 days
**Team Size**: {report['team_size']} engineers
**Health Score**: {report['health_score']:.1f}%

## Key Metrics

| Metric | Value | Status |
|--------|-------|--------|
| Total Incidents | {report['total_incidents']} | - |
| Avg Acknowledgment Time | {report['average_ack_time_seconds']/60:.1f} min | {'âœ…' if report['health_indicators']['ack_time_healthy'] else 'âš ï¸'} |
| Avg Resolution Time | {report['average_resolve_time_seconds']/60:.1f} min | {'âœ…' if report['health_indicators']['resolve_time_healthy'] else 'âš ï¸'} |
| Escalation Rate | {report['escalation_rate']*100:.1f}% | {'âœ…' if report['health_indicators']['escalation_rate_healthy'] else 'âš ï¸'} |
| False Positive Rate | {report['false_positive_rate']*100:.1f}% | {'âœ…' if report['health_indicators']['false_positive_rate_healthy'] else 'âš ï¸'} |
| After-Hours Page Rate | {report['after_hours_page_rate']*100:.1f}% | - |

## Individual Performance

| Engineer | Incidents | Avg Ack (min) | Avg Resolve (min) |
|----------|-----------|---------------|-------------------|
"""

        for eng, metrics in report['individual_metrics'].items():
            summary += f"| {eng} | {metrics['incidents']} | {metrics['mean_ack_time']/60:.1f} | {metrics['mean_resolve_time']/60:.1f} |\n"

        # Add recommendations
        summary += "\n## Recommendations\n\n"

        if not report['health_indicators']['ack_time_healthy']:
            summary += "- âš ï¸ Acknowledgment times are above target. Review paging configurations and on-call response procedures.\n"

        if not report['health_indicators']['resolve_time_healthy']:
            summary += "- âš ï¸ Resolution times are above target. Consider improving runbooks or adding more detailed diagnostic tooling.\n"

        if not report['health_indicators']['false_positive_rate_healthy']:
            summary += "- âš ï¸ High false positive rate. Review alert thresholds and reduce noise.\n"

        if not report['health_indicators']['load_balanced']:
            summary += "- âš ï¸ On-call load is unbalanced. Consider adjusting rotation to distribute incidents more evenly.\n"

        return summary
```

## 4. On-Call Wellness and Best Practices

### 4.1 Wellness Monitoring

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from enum import Enum


class WellnessRisk(Enum):
    """Risk levels for on-call wellness."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


@dataclass
class WellnessMetrics:
    """Wellness metrics for an on-call engineer."""
    engineer_id: str
    consecutive_on_call_days: int
    sleep_interruptions_last_week: int
    pages_during_night_hours: int
    total_on_call_hours_last_month: int
    days_since_last_break: int
    risk_level: WellnessRisk


class OnCallWellnessMonitor:
    """Monitor and protect on-call engineer wellness."""

    def __init__(
        self,
        scheduler: OnCallScheduler,
        incident_store: 'IncidentStore'
    ):
        self.scheduler = scheduler
        self.incident_store = incident_store

        # Wellness thresholds
        self.thresholds = {
            "max_consecutive_days": 7,
            "max_night_pages_per_week": 5,
            "max_on_call_hours_per_month": 168,  # 1 week
            "min_days_between_rotations": 7,
            "max_sleep_interruptions_per_week": 3
        }

    def assess_engineer_wellness(
        self,
        engineer_id: str
    ) -> WellnessMetrics:
        """Assess wellness metrics for an engineer."""
        now = datetime.utcnow()

        # Calculate consecutive on-call days
        consecutive_days = self._count_consecutive_oncall_days(engineer_id)

        # Count sleep interruptions (11pm - 6am pages)
        sleep_interruptions = self._count_sleep_interruptions(
            engineer_id,
            now - timedelta(days=7)
        )

        # Count night pages
        night_pages = self._count_night_pages(
            engineer_id,
            now - timedelta(days=7)
        )

        # Calculate total on-call hours last month
        total_hours = self._calculate_total_oncall_hours(
            engineer_id,
            now - timedelta(days=30)
        )

        # Days since last break from on-call
        days_since_break = self._days_since_last_break(engineer_id)

        # Determine risk level
        risk_level = self._calculate_risk_level(
            consecutive_days,
            sleep_interruptions,
            night_pages,
            total_hours,
            days_since_break
        )

        return WellnessMetrics(
            engineer_id=engineer_id,
            consecutive_on_call_days=consecutive_days,
            sleep_interruptions_last_week=sleep_interruptions,
            pages_during_night_hours=night_pages,
            total_on_call_hours_last_month=total_hours,
            days_since_last_break=days_since_break,
            risk_level=risk_level
        )

    def _count_consecutive_oncall_days(self, engineer_id: str) -> int:
        """Count consecutive days on-call."""
        now = datetime.utcnow()
        consecutive = 0
        check_date = now

        while True:
            is_oncall = False
            for schedule in self.scheduler.schedules.values():
                for shift in schedule.shifts:
                    if (shift.engineer_id == engineer_id and
                        shift.start_time.date() <= check_date.date() <= shift.end_time.date()):
                        is_oncall = True
                        break
                if is_oncall:
                    break

            if is_oncall:
                consecutive += 1
                check_date -= timedelta(days=1)
            else:
                break

        return consecutive

    def _count_sleep_interruptions(
        self,
        engineer_id: str,
        since: datetime
    ) -> int:
        """Count pages during sleep hours (11pm - 6am)."""
        incidents = self.incident_store.get_incidents_by_responder(
            engineer_id, since, datetime.utcnow()
        )

        count = 0
        for incident in incidents:
            created = datetime.fromisoformat(incident["created_at"])
            hour = created.hour
            if hour >= 23 or hour < 6:
                count += 1

        return count

    def _count_night_pages(
        self,
        engineer_id: str,
        since: datetime
    ) -> int:
        """Count all pages during night hours (6pm - 9am)."""
        incidents = self.incident_store.get_incidents_by_responder(
            engineer_id, since, datetime.utcnow()
        )

        count = 0
        for incident in incidents:
            created = datetime.fromisoformat(incident["created_at"])
            hour = created.hour
            if hour >= 18 or hour < 9:
                count += 1

        return count

    def _calculate_total_oncall_hours(
        self,
        engineer_id: str,
        since: datetime
    ) -> int:
        """Calculate total on-call hours in period."""
        now = datetime.utcnow()
        total_hours = 0

        for schedule in self.scheduler.schedules.values():
            for shift in schedule.shifts:
                if shift.engineer_id != engineer_id:
                    continue

                # Calculate overlap with period
                start = max(shift.start_time, since)
                end = min(shift.end_time, now)

                if start < end:
                    total_hours += (end - start).total_seconds() / 3600

        return int(total_hours)

    def _days_since_last_break(self, engineer_id: str) -> int:
        """Calculate days since engineer had a break from on-call."""
        now = datetime.utcnow()
        check_date = now
        days_checked = 0
        max_check = 90  # Check up to 90 days back

        while days_checked < max_check:
            is_oncall = False
            for schedule in self.scheduler.schedules.values():
                for shift in schedule.shifts:
                    if (shift.engineer_id == engineer_id and
                        shift.start_time.date() <= check_date.date() <= shift.end_time.date()):
                        is_oncall = True
                        break

            if not is_oncall:
                # Found a break day, now count consecutive break days
                break_start = check_date
                while not is_oncall and days_checked < max_check:
                    check_date -= timedelta(days=1)
                    days_checked += 1
                    for schedule in self.scheduler.schedules.values():
                        for shift in schedule.shifts:
                            if (shift.engineer_id == engineer_id and
                                shift.start_time.date() <= check_date.date() <= shift.end_time.date()):
                                is_oncall = True
                                break

                # If we found sufficient break, return days since
                break_length = (break_start - check_date).days
                if break_length >= self.thresholds["min_days_between_rotations"]:
                    return (now - break_start).days

            check_date -= timedelta(days=1)
            days_checked += 1

        return max_check

    def _calculate_risk_level(
        self,
        consecutive_days: int,
        sleep_interruptions: int,
        night_pages: int,
        total_hours: int,
        days_since_break: int
    ) -> WellnessRisk:
        """Calculate overall wellness risk level."""
        risk_score = 0

        # Consecutive days factor
        if consecutive_days > self.thresholds["max_consecutive_days"]:
            risk_score += 3
        elif consecutive_days > self.thresholds["max_consecutive_days"] * 0.7:
            risk_score += 2
        elif consecutive_days > self.thresholds["max_consecutive_days"] * 0.5:
            risk_score += 1

        # Sleep interruptions factor
        if sleep_interruptions > self.thresholds["max_sleep_interruptions_per_week"]:
            risk_score += 3
        elif sleep_interruptions > self.thresholds["max_sleep_interruptions_per_week"] * 0.7:
            risk_score += 2

        # Total hours factor
        if total_hours > self.thresholds["max_on_call_hours_per_month"]:
            risk_score += 2
        elif total_hours > self.thresholds["max_on_call_hours_per_month"] * 0.8:
            risk_score += 1

        # Days since break factor
        if days_since_break > self.thresholds["min_days_between_rotations"] * 3:
            risk_score += 2
        elif days_since_break > self.thresholds["min_days_between_rotations"] * 2:
            risk_score += 1

        if risk_score >= 8:
            return WellnessRisk.CRITICAL
        elif risk_score >= 5:
            return WellnessRisk.HIGH
        elif risk_score >= 3:
            return WellnessRisk.MEDIUM
        else:
            return WellnessRisk.LOW

    def get_team_wellness_report(
        self,
        team_engineers: List[str]
    ) -> Dict:
        """Generate team wellness report."""
        wellness_data = {}
        risk_counts = {risk: 0 for risk in WellnessRisk}

        for engineer in team_engineers:
            metrics = self.assess_engineer_wellness(engineer)
            wellness_data[engineer] = metrics
            risk_counts[metrics.risk_level] += 1

        recommendations = []

        # Check for critical cases
        critical_engineers = [
            eng for eng, m in wellness_data.items()
            if m.risk_level == WellnessRisk.CRITICAL
        ]
        if critical_engineers:
            recommendations.append({
                "priority": "immediate",
                "action": "provide_relief",
                "engineers": critical_engineers,
                "message": "Immediate relief needed - critical burnout risk"
            })

        # Check for high risk
        high_risk_engineers = [
            eng for eng, m in wellness_data.items()
            if m.risk_level == WellnessRisk.HIGH
        ]
        if high_risk_engineers:
            recommendations.append({
                "priority": "urgent",
                "action": "reduce_load",
                "engineers": high_risk_engineers,
                "message": "Schedule adjustments needed within this week"
            })

        return {
            "timestamp": datetime.utcnow().isoformat(),
            "team_size": len(team_engineers),
            "risk_distribution": {r.value: c for r, c in risk_counts.items()},
            "individual_wellness": {
                eng: {
                    "consecutive_days": m.consecutive_on_call_days,
                    "sleep_interruptions": m.sleep_interruptions_last_week,
                    "night_pages": m.pages_during_night_hours,
                    "monthly_hours": m.total_on_call_hours_last_month,
                    "days_since_break": m.days_since_last_break,
                    "risk_level": m.risk_level.value
                }
                for eng, m in wellness_data.items()
            },
            "recommendations": recommendations
        }
```

### 4.2 On-Call Best Practices Checklist

```python
from dataclasses import dataclass
from typing import Dict, List
from enum import Enum


class ChecklistCategory(Enum):
    """Categories of on-call best practices."""
    PREPARATION = "preparation"
    RESPONSE = "response"
    COMMUNICATION = "communication"
    DOCUMENTATION = "documentation"
    HANDOFF = "handoff"
    WELLNESS = "wellness"


@dataclass
class BestPractice:
    """A single best practice item."""
    id: str
    category: ChecklistCategory
    title: str
    description: str
    verification_steps: List[str]


class OnCallBestPracticesChecklist:
    """Comprehensive on-call best practices."""

    def __init__(self):
        self.practices = self._initialize_practices()

    def _initialize_practices(self) -> Dict[str, BestPractice]:
        return {
            # Preparation
            "prep_001": BestPractice(
                id="prep_001",
                category=ChecklistCategory.PREPARATION,
                title="Environment Setup",
                description="Ensure all tools and access are configured before shift",
                verification_steps=[
                    "VPN connection tested and working",
                    "PagerDuty/OpsGenie app installed and logged in",
                    "Slack notifications enabled for incident channels",
                    "SSH keys configured for production access",
                    "kubectl contexts configured for all clusters",
                    "Runbook documentation bookmarked and accessible"
                ]
            ),
            "prep_002": BestPractice(
                id="prep_002",
                category=ChecklistCategory.PREPARATION,
                title="Alert Configuration",
                description="Configure alerting for reliable notification",
                verification_steps=[
                    "Primary phone number verified in paging system",
                    "Secondary contact method configured",
                    "Do Not Disturb exceptions set for paging app",
                    "Test page received and acknowledged",
                    "Alert sound distinct and audible",
                    "Phone battery charged or charger accessible"
                ]
            ),
            "prep_003": BestPractice(
                id="prep_003",
                category=ChecklistCategory.PREPARATION,
                title="Knowledge Review",
                description="Review recent changes and known issues",
                verification_steps=[
                    "Read recent deployment logs",
                    "Review open incidents from previous shift",
                    "Check for scheduled maintenance windows",
                    "Review any new or updated runbooks",
                    "Understand current known issues and workarounds"
                ]
            ),

            # Response
            "resp_001": BestPractice(
                id="resp_001",
                category=ChecklistCategory.RESPONSE,
                title="Alert Acknowledgment",
                description="Acknowledge alerts promptly and appropriately",
                verification_steps=[
                    "Acknowledge within SLA (typically 5 minutes)",
                    "Join incident channel immediately",
                    "Start incident timeline documentation",
                    "Assess severity and escalate if needed",
                    "Begin initial triage steps"
                ]
            ),
            "resp_002": BestPractice(
                id="resp_002",
                category=ChecklistCategory.RESPONSE,
                title="Incident Triage",
                description="Systematically assess and prioritize",
                verification_steps=[
                    "Identify affected services and customers",
                    "Determine severity level",
                    "Check for recent changes (deployments, configs)",
                    "Review relevant dashboards and logs",
                    "Identify if issue is recurring"
                ]
            ),
            "resp_003": BestPractice(
                id="resp_003",
                category=ChecklistCategory.RESPONSE,
                title="Runbook Execution",
                description="Follow established procedures",
                verification_steps=[
                    "Locate appropriate runbook for the issue",
                    "Follow steps in order without skipping",
                    "Document any deviations or failures",
                    "Escalate if runbook doesn't resolve issue",
                    "Note improvements needed for runbook"
                ]
            ),

            # Communication
            "comm_001": BestPractice(
                id="comm_001",
                category=ChecklistCategory.COMMUNICATION,
                title="Status Updates",
                description="Provide regular status updates",
                verification_steps=[
                    "Post initial update within 10 minutes",
                    "Update every 30 minutes for active incidents",
                    "Use clear, non-technical language for customers",
                    "Include current status, impact, and next steps",
                    "Update status page for customer-facing issues"
                ]
            ),
            "comm_002": BestPractice(
                id="comm_002",
                category=ChecklistCategory.COMMUNICATION,
                title="Escalation Communication",
                description="Communicate clearly when escalating",
                verification_steps=[
                    "State reason for escalation clearly",
                    "Provide summary of actions taken so far",
                    "Share all relevant context and logs",
                    "Specify what help is needed",
                    "Establish clear ownership transfer"
                ]
            ),

            # Documentation
            "doc_001": BestPractice(
                id="doc_001",
                category=ChecklistCategory.DOCUMENTATION,
                title="Incident Timeline",
                description="Maintain detailed incident timeline",
                verification_steps=[
                    "Record when alert fired",
                    "Document all investigation steps",
                    "Note all commands run and their output",
                    "Record who was contacted and when",
                    "Document what worked and what didn't"
                ]
            ),
            "doc_002": BestPractice(
                id="doc_002",
                category=ChecklistCategory.DOCUMENTATION,
                title="Post-Incident Report",
                description="Complete thorough post-incident documentation",
                verification_steps=[
                    "Write timeline of events",
                    "Document root cause analysis",
                    "List contributing factors",
                    "Define action items with owners",
                    "Share learnings with team"
                ]
            ),

            # Handoff
            "hand_001": BestPractice(
                id="hand_001",
                category=ChecklistCategory.HANDOFF,
                title="Shift Handoff",
                description="Conduct thorough shift handoff",
                verification_steps=[
                    "Schedule handoff meeting with incoming engineer",
                    "Review any ongoing incidents",
                    "Discuss recent alerts and resolutions",
                    "Share any known issues or concerns",
                    "Confirm incoming engineer has all access",
                    "Update on-call status in paging system"
                ]
            ),
            "hand_002": BestPractice(
                id="hand_002",
                category=ChecklistCategory.HANDOFF,
                title="Incident Handoff",
                description="Hand off active incidents properly",
                verification_steps=[
                    "Brief incoming responder on incident status",
                    "Share all relevant context and timeline",
                    "Transfer incident commander role explicitly",
                    "Update incident channel with new owner",
                    "Remain available for questions"
                ]
            ),

            # Wellness
            "well_001": BestPractice(
                id="well_001",
                category=ChecklistCategory.WELLNESS,
                title="Work-Life Balance",
                description="Maintain healthy on-call practices",
                verification_steps=[
                    "Take breaks between shifts",
                    "Avoid consecutive week-long shifts",
                    "Request swap if unable to respond",
                    "Report excessive page volume to manager",
                    "Take time off after heavy incidents"
                ]
            ),
            "well_002": BestPractice(
                id="well_002",
                category=ChecklistCategory.WELLNESS,
                title="After-Hours Pages",
                description="Handle after-hours pages appropriately",
                verification_steps=[
                    "Assess true urgency before acting",
                    "Defer non-critical work to business hours",
                    "Document for morning handoff if deferred",
                    "Report persistent night pages for review",
                    "Request comp time for heavy overnight work"
                ]
            )
        }

    def get_checklist_by_category(
        self,
        category: ChecklistCategory
    ) -> List[BestPractice]:
        """Get all practices for a category."""
        return [
            p for p in self.practices.values()
            if p.category == category
        ]

    def get_shift_start_checklist(self) -> List[BestPractice]:
        """Get checklist for starting a shift."""
        return [
            self.practices["prep_001"],
            self.practices["prep_002"],
            self.practices["prep_003"]
        ]

    def get_incident_response_checklist(self) -> List[BestPractice]:
        """Get checklist for incident response."""
        return [
            self.practices["resp_001"],
            self.practices["resp_002"],
            self.practices["resp_003"],
            self.practices["comm_001"],
            self.practices["doc_001"]
        ]

    def get_shift_end_checklist(self) -> List[BestPractice]:
        """Get checklist for ending a shift."""
        return [
            self.practices["hand_001"],
            self.practices["doc_002"],
            self.practices["well_001"]
        ]

    def generate_checklist_markdown(
        self,
        checklist: List[BestPractice]
    ) -> str:
        """Generate markdown checklist."""
        md = "# On-Call Checklist\n\n"

        current_category = None
        for practice in checklist:
            if practice.category != current_category:
                current_category = practice.category
                md += f"\n## {current_category.value.title()}\n\n"

            md += f"### {practice.title}\n"
            md += f"{practice.description}\n\n"

            for step in practice.verification_steps:
                md += f"- [ ] {step}\n"

            md += "\n"

        return md
```

## 5. On-Call Compensation and Incentives

### 5.1 Compensation Model

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from enum import Enum


class CompensationType(Enum):
    """Types of on-call compensation."""
    HOURLY_STANDBY = "hourly_standby"
    INCIDENT_BONUS = "incident_bonus"
    HOLIDAY_MULTIPLIER = "holiday_multiplier"
    COMP_TIME = "comp_time"


@dataclass
class CompensationRate:
    """Compensation rate definition."""
    compensation_type: CompensationType
    base_rate: float
    multiplier: float
    currency: str
    description: str


class OnCallCompensationCalculator:
    """Calculate on-call compensation."""

    def __init__(self, config: Dict):
        self.config = config
        self.rates = self._initialize_rates()

    def _initialize_rates(self) -> Dict[str, CompensationRate]:
        return {
            "weekday_standby": CompensationRate(
                compensation_type=CompensationType.HOURLY_STANDBY,
                base_rate=5.0,
                multiplier=1.0,
                currency="USD",
                description="Weekday standby rate per hour"
            ),
            "weekend_standby": CompensationRate(
                compensation_type=CompensationType.HOURLY_STANDBY,
                base_rate=5.0,
                multiplier=1.5,
                currency="USD",
                description="Weekend standby rate per hour"
            ),
            "holiday_standby": CompensationRate(
                compensation_type=CompensationType.HOURLY_STANDBY,
                base_rate=5.0,
                multiplier=2.0,
                currency="USD",
                description="Holiday standby rate per hour"
            ),
            "incident_response": CompensationRate(
                compensation_type=CompensationType.INCIDENT_BONUS,
                base_rate=50.0,
                multiplier=1.0,
                currency="USD",
                description="Bonus per incident responded to"
            ),
            "night_incident": CompensationRate(
                compensation_type=CompensationType.INCIDENT_BONUS,
                base_rate=50.0,
                multiplier=2.0,
                currency="USD",
                description="Night-time incident bonus (11pm-6am)"
            ),
            "sev1_bonus": CompensationRate(
                compensation_type=CompensationType.INCIDENT_BONUS,
                base_rate=100.0,
                multiplier=1.0,
                currency="USD",
                description="Additional bonus for SEV1 incidents"
            )
        }

    def calculate_shift_compensation(
        self,
        shift: 'OnCallShift',
        incidents: List[Dict],
        holidays: List[datetime]
    ) -> Dict:
        """Calculate compensation for a shift."""
        compensation = {
            "shift_id": shift.shift_id,
            "engineer_id": shift.engineer_id,
            "period_start": shift.start_time.isoformat(),
            "period_end": shift.end_time.isoformat(),
            "line_items": [],
            "total_amount": 0.0,
            "currency": "USD"
        }

        # Calculate standby hours
        current = shift.start_time
        while current < shift.end_time:
            hour_end = min(current + timedelta(hours=1), shift.end_time)
            hours = (hour_end - current).total_seconds() / 3600

            # Determine rate type
            is_holiday = any(
                h.date() == current.date() for h in holidays
            )
            is_weekend = current.weekday() >= 5

            if is_holiday:
                rate = self.rates["holiday_standby"]
            elif is_weekend:
                rate = self.rates["weekend_standby"]
            else:
                rate = self.rates["weekday_standby"]

            amount = hours * rate.base_rate * rate.multiplier

            compensation["line_items"].append({
                "type": "standby",
                "description": rate.description,
                "hours": hours,
                "rate": rate.base_rate * rate.multiplier,
                "amount": amount
            })

            compensation["total_amount"] += amount
            current = hour_end

        # Calculate incident bonuses
        for incident in incidents:
            incident_time = datetime.fromisoformat(incident["created_at"])

            # Check if incident was during this shift
            if not (shift.start_time <= incident_time <= shift.end_time):
                continue

            # Base incident bonus
            rate = self.rates["incident_response"]
            is_night = incident_time.hour >= 23 or incident_time.hour < 6

            if is_night:
                rate = self.rates["night_incident"]

            amount = rate.base_rate * rate.multiplier

            compensation["line_items"].append({
                "type": "incident_bonus",
                "description": rate.description,
                "incident_id": incident["id"],
                "amount": amount
            })
            compensation["total_amount"] += amount

            # SEV1 bonus
            if incident.get("severity") == "SEV1":
                sev1_rate = self.rates["sev1_bonus"]
                compensation["line_items"].append({
                    "type": "sev1_bonus",
                    "description": sev1_rate.description,
                    "incident_id": incident["id"],
                    "amount": sev1_rate.base_rate
                })
                compensation["total_amount"] += sev1_rate.base_rate

        return compensation

    def calculate_monthly_compensation(
        self,
        engineer_id: str,
        month: int,
        year: int,
        shifts: List['OnCallShift'],
        incidents: List[Dict],
        holidays: List[datetime]
    ) -> Dict:
        """Calculate monthly compensation for an engineer."""
        month_start = datetime(year, month, 1)
        if month == 12:
            month_end = datetime(year + 1, 1, 1)
        else:
            month_end = datetime(year, month + 1, 1)

        monthly = {
            "engineer_id": engineer_id,
            "month": month,
            "year": year,
            "shifts": [],
            "total_standby_hours": 0,
            "total_incidents": 0,
            "total_amount": 0.0,
            "currency": "USD"
        }

        # Filter shifts for this engineer and month
        engineer_shifts = [
            s for s in shifts
            if s.engineer_id == engineer_id and
            s.start_time >= month_start and
            s.end_time <= month_end
        ]

        for shift in engineer_shifts:
            # Get incidents for this shift
            shift_incidents = [
                i for i in incidents
                if shift.start_time <= datetime.fromisoformat(i["created_at"]) <= shift.end_time
            ]

            shift_comp = self.calculate_shift_compensation(
                shift, shift_incidents, holidays
            )

            monthly["shifts"].append(shift_comp)
            monthly["total_amount"] += shift_comp["total_amount"]

            # Count hours and incidents
            for item in shift_comp["line_items"]:
                if item["type"] == "standby":
                    monthly["total_standby_hours"] += item.get("hours", 0)
                elif item["type"] == "incident_bonus":
                    monthly["total_incidents"] += 1

        return monthly


class CompTimeTracker:
    """Track and manage compensatory time off."""

    def __init__(self):
        self.comp_time_balances: Dict[str, float] = {}
        self.comp_time_history: Dict[str, List[Dict]] = {}

    def accrue_comp_time(
        self,
        engineer_id: str,
        hours: float,
        reason: str,
        incident_id: Optional[str] = None
    ):
        """Accrue comp time for an engineer."""
        if engineer_id not in self.comp_time_balances:
            self.comp_time_balances[engineer_id] = 0.0
            self.comp_time_history[engineer_id] = []

        self.comp_time_balances[engineer_id] += hours
        self.comp_time_history[engineer_id].append({
            "timestamp": datetime.utcnow().isoformat(),
            "type": "accrual",
            "hours": hours,
            "reason": reason,
            "incident_id": incident_id,
            "balance_after": self.comp_time_balances[engineer_id]
        })

    def use_comp_time(
        self,
        engineer_id: str,
        hours: float,
        date: datetime
    ) -> bool:
        """Use accrued comp time."""
        if engineer_id not in self.comp_time_balances:
            return False

        if self.comp_time_balances[engineer_id] < hours:
            return False

        self.comp_time_balances[engineer_id] -= hours
        self.comp_time_history[engineer_id].append({
            "timestamp": datetime.utcnow().isoformat(),
            "type": "usage",
            "hours": -hours,
            "date_used": date.isoformat(),
            "balance_after": self.comp_time_balances[engineer_id]
        })

        return True

    def get_balance(self, engineer_id: str) -> float:
        """Get current comp time balance."""
        return self.comp_time_balances.get(engineer_id, 0.0)

    def get_history(
        self,
        engineer_id: str,
        since: Optional[datetime] = None
    ) -> List[Dict]:
        """Get comp time history for an engineer."""
        history = self.comp_time_history.get(engineer_id, [])

        if since:
            history = [
                h for h in history
                if datetime.fromisoformat(h["timestamp"]) >= since
            ]

        return history
```

## 6. Training and Onboarding

### 6.1 On-Call Training Program

```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
from datetime import datetime


class TrainingModuleType(Enum):
    """Types of training modules."""
    CLASSROOM = "classroom"
    SELF_PACED = "self_paced"
    SHADOWING = "shadowing"
    SIMULATION = "simulation"
    ASSESSMENT = "assessment"


@dataclass
class TrainingModule:
    """A training module for on-call preparation."""
    module_id: str
    title: str
    description: str
    module_type: TrainingModuleType
    duration_hours: float
    prerequisites: List[str]
    learning_objectives: List[str]
    materials: List[str]
    assessment_criteria: List[str]


class OnCallTrainingProgram:
    """Comprehensive on-call training program."""

    def __init__(self):
        self.modules = self._initialize_modules()
        self.trainee_progress: Dict[str, Dict] = {}

    def _initialize_modules(self) -> Dict[str, TrainingModule]:
        return {
            "oncall_101": TrainingModule(
                module_id="oncall_101",
                title="On-Call Fundamentals",
                description="Introduction to on-call responsibilities and processes",
                module_type=TrainingModuleType.CLASSROOM,
                duration_hours=2.0,
                prerequisites=[],
                learning_objectives=[
                    "Understand on-call role and responsibilities",
                    "Know escalation procedures",
                    "Understand SLA requirements",
                    "Know how to use paging systems"
                ],
                materials=[
                    "On-call handbook",
                    "Escalation matrix",
                    "SLA documentation"
                ],
                assessment_criteria=[
                    "Can explain on-call responsibilities",
                    "Can navigate paging system",
                    "Understands escalation paths"
                ]
            ),
            "platform_overview": TrainingModule(
                module_id="platform_overview",
                title="Platform Architecture Overview",
                description="Deep dive into platform architecture and dependencies",
                module_type=TrainingModuleType.SELF_PACED,
                duration_hours=4.0,
                prerequisites=["oncall_101"],
                learning_objectives=[
                    "Understand platform components",
                    "Know service dependencies",
                    "Understand data flow",
                    "Know critical paths"
                ],
                materials=[
                    "Architecture documentation",
                    "Service catalog",
                    "Dependency diagrams"
                ],
                assessment_criteria=[
                    "Can explain platform architecture",
                    "Can identify service dependencies",
                    "Understands critical paths"
                ]
            ),
            "monitoring_alerting": TrainingModule(
                module_id="monitoring_alerting",
                title="Monitoring and Alerting Systems",
                description="Hands-on training with monitoring tools",
                module_type=TrainingModuleType.CLASSROOM,
                duration_hours=3.0,
                prerequisites=["platform_overview"],
                learning_objectives=[
                    "Navigate monitoring dashboards",
                    "Understand alert configurations",
                    "Interpret metrics and logs",
                    "Use tracing systems"
                ],
                materials=[
                    "Grafana access",
                    "Prometheus queries",
                    "Alert playbooks"
                ],
                assessment_criteria=[
                    "Can create custom dashboards",
                    "Can write basic Prometheus queries",
                    "Can trace requests through system"
                ]
            ),
            "incident_management": TrainingModule(
                module_id="incident_management",
                title="Incident Management Process",
                description="How to manage incidents from detection to resolution",
                module_type=TrainingModuleType.CLASSROOM,
                duration_hours=2.0,
                prerequisites=["monitoring_alerting"],
                learning_objectives=[
                    "Follow incident lifecycle",
                    "Document incidents properly",
                    "Communicate effectively during incidents",
                    "Conduct post-incident reviews"
                ],
                materials=[
                    "Incident management guide",
                    "Communication templates",
                    "PIR template"
                ],
                assessment_criteria=[
                    "Can manage incident lifecycle",
                    "Produces quality incident documentation",
                    "Communicates clearly during incidents"
                ]
            ),
            "runbook_training": TrainingModule(
                module_id="runbook_training",
                title="Runbook Familiarization",
                description="Detailed review of operational runbooks",
                module_type=TrainingModuleType.SELF_PACED,
                duration_hours=4.0,
                prerequisites=["incident_management"],
                learning_objectives=[
                    "Know where to find runbooks",
                    "Understand runbook structure",
                    "Execute common runbooks",
                    "Identify when to deviate"
                ],
                materials=[
                    "Runbook repository",
                    "Common scenarios guide"
                ],
                assessment_criteria=[
                    "Can locate relevant runbooks",
                    "Can execute runbooks correctly",
                    "Knows when to escalate"
                ]
            ),
            "shadow_shift": TrainingModule(
                module_id="shadow_shift",
                title="Shadow On-Call Shift",
                description="Shadow an experienced on-call engineer",
                module_type=TrainingModuleType.SHADOWING,
                duration_hours=8.0,
                prerequisites=["runbook_training"],
                learning_objectives=[
                    "Observe real incident handling",
                    "Practice alert triage",
                    "Learn from experienced engineer",
                    "Ask questions in real scenarios"
                ],
                materials=[
                    "Shadow checklist",
                    "Observation form"
                ],
                assessment_criteria=[
                    "Completed full shift shadow",
                    "Participated in incident handling",
                    "Received positive feedback from mentor"
                ]
            ),
            "simulation": TrainingModule(
                module_id="simulation",
                title="Incident Simulation Exercise",
                description="Hands-on simulation of common incidents",
                module_type=TrainingModuleType.SIMULATION,
                duration_hours=4.0,
                prerequisites=["shadow_shift"],
                learning_objectives=[
                    "Handle simulated incidents",
                    "Practice under pressure",
                    "Use all tools and processes",
                    "Receive feedback"
                ],
                materials=[
                    "Simulation environment",
                    "Scenario scripts"
                ],
                assessment_criteria=[
                    "Successfully handles simulated SEV2",
                    "Properly escalates when needed",
                    "Documents actions accurately"
                ]
            ),
            "reverse_shadow": TrainingModule(
                module_id="reverse_shadow",
                title="Reverse Shadow Shift",
                description="Handle on-call with experienced engineer backup",
                module_type=TrainingModuleType.SHADOWING,
                duration_hours=8.0,
                prerequisites=["simulation"],
                learning_objectives=[
                    "Handle real incidents with backup",
                    "Build confidence",
                    "Validate readiness",
                    "Get final feedback"
                ],
                materials=[
                    "Reverse shadow checklist"
                ],
                assessment_criteria=[
                    "Handles incidents independently",
                    "Appropriately uses backup",
                    "Demonstrates readiness for solo shifts"
                ]
            ),
            "final_assessment": TrainingModule(
                module_id="final_assessment",
                title="Final Readiness Assessment",
                description="Comprehensive assessment of on-call readiness",
                module_type=TrainingModuleType.ASSESSMENT,
                duration_hours=2.0,
                prerequisites=["reverse_shadow"],
                learning_objectives=[
                    "Demonstrate comprehensive knowledge",
                    "Pass practical assessment",
                    "Receive certification"
                ],
                materials=[
                    "Assessment rubric",
                    "Certification form"
                ],
                assessment_criteria=[
                    "Passes knowledge assessment (>80%)",
                    "Passes practical assessment",
                    "Approved by on-call lead"
                ]
            )
        }

    def get_training_path(self) -> List[TrainingModule]:
        """Get the ordered training path."""
        # Topological sort based on prerequisites
        visited = set()
        path = []

        def visit(module_id: str):
            if module_id in visited:
                return
            visited.add(module_id)
            module = self.modules[module_id]
            for prereq in module.prerequisites:
                visit(prereq)
            path.append(module)

        for module_id in self.modules:
            visit(module_id)

        return path

    def start_training(self, trainee_id: str) -> Dict:
        """Initialize training for a new trainee."""
        self.trainee_progress[trainee_id] = {
            "started_at": datetime.utcnow().isoformat(),
            "completed_modules": [],
            "current_module": "oncall_101",
            "status": "in_progress"
        }
        return self.trainee_progress[trainee_id]

    def complete_module(
        self,
        trainee_id: str,
        module_id: str,
        assessment_results: Dict
    ) -> Dict:
        """Mark a module as completed."""
        if trainee_id not in self.trainee_progress:
            raise ValueError(f"Trainee {trainee_id} not found")

        progress = self.trainee_progress[trainee_id]

        progress["completed_modules"].append({
            "module_id": module_id,
            "completed_at": datetime.utcnow().isoformat(),
            "assessment_results": assessment_results
        })

        # Determine next module
        path = self.get_training_path()
        completed_ids = [m["module_id"] for m in progress["completed_modules"]]

        next_module = None
        for module in path:
            if module.module_id not in completed_ids:
                # Check if prerequisites are met
                prereqs_met = all(
                    p in completed_ids for p in module.prerequisites
                )
                if prereqs_met:
                    next_module = module.module_id
                    break

        if next_module:
            progress["current_module"] = next_module
        else:
            progress["status"] = "completed"
            progress["completed_at"] = datetime.utcnow().isoformat()
            progress["current_module"] = None

        return progress

    def get_trainee_status(self, trainee_id: str) -> Dict:
        """Get current training status for a trainee."""
        if trainee_id not in self.trainee_progress:
            return {"status": "not_started"}

        progress = self.trainee_progress[trainee_id]
        total_modules = len(self.modules)
        completed = len(progress["completed_modules"])

        return {
            **progress,
            "progress_percent": (completed / total_modules) * 100,
            "total_modules": total_modules,
            "modules_completed": completed
        }

    def generate_training_certificate(
        self,
        trainee_id: str
    ) -> Optional[Dict]:
        """Generate training completion certificate."""
        if trainee_id not in self.trainee_progress:
            return None

        progress = self.trainee_progress[trainee_id]

        if progress["status"] != "completed":
            return None

        return {
            "certificate_id": f"ONCALL-CERT-{trainee_id}-{datetime.utcnow().strftime('%Y%m%d')}",
            "trainee_id": trainee_id,
            "program": "On-Call Engineer Certification",
            "completed_at": progress["completed_at"],
            "modules_completed": [
                m["module_id"] for m in progress["completed_modules"]
            ],
            "valid_until": (
                datetime.utcnow() + timedelta(days=365)
            ).isoformat(),
            "certified_for": [
                "Primary On-Call",
                "Incident Response",
                "Escalation Management"
            ]
        }
```

## Troubleshooting

### Common On-Call Issues

| Issue | Symptoms | Resolution |
|-------|----------|------------|
| Missed pages | No response to alerts | Check paging app configuration, phone DND settings |
| Alert fatigue | High false positive rate | Review alert thresholds, implement better filtering |
| Slow response | Long time to acknowledge | Improve alert routing, review on-call readiness |
| Burnout | High stress, errors | Implement better rotation, provide relief |
| Knowledge gaps | Unable to resolve issues | Improve documentation, training |

### Escalation Troubleshooting

```python
def diagnose_escalation_issues(
    escalation_manager: EscalationManager,
    incident_id: str
) -> List[str]:
    """Diagnose issues with an escalation."""
    issues = []

    escalation = escalation_manager.active_escalations.get(incident_id)
    if not escalation:
        issues.append("No active escalation found")
        return issues

    # Check if stuck at a level
    history = escalation.get("escalation_history", [])
    if history:
        last = history[-1]
        time_at_level = (
            datetime.utcnow() -
            datetime.fromisoformat(last["notified_at"])
        ).total_seconds() / 60

        if time_at_level > 60:
            issues.append(f"Stuck at level {last['level']} for {time_at_level:.0f} minutes")

    # Check acknowledgment
    if not escalation.get("acknowledged_by"):
        issues.append("Escalation not acknowledged")

    return issues
```

## Related Documentation

- [13.1 Incident Response Guide](13.1_incident_response_guide.md)
- [13.2 Disaster Recovery Guide](13.2_disaster_recovery_guide.md)
- [13.5 Operational Runbooks Guide](13.5_operational_runbooks_guide.md)

## Version History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2024-01-15 | Platform Team | Initial release |

---

> **Navigation**
> [â† 13.3 Capacity Planning](13.3_capacity_planning_guide.md) | **[Index](../README.md#15-repository-structure)** | [13.5 Operational Runbooks â†’](13.5_operational_runbooks_guide.md)
