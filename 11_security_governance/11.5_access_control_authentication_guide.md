> **Navigation** | [← 11.4 Model Governance](11.4_model_governance_guide.md) | [12.1 Prompt Engineering →](../12_user_developer_experience/12.1_prompt_engineering_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | OAuth 2.0 &#124; OIDC &#124; JWT &#124; [11.1 Security](11.1_llm_security_guide.md) |
> | **Related** | [9.3 API Design](../09_inference_serving/9.3_api_design_llm_services_guide.md) &#124; [11.3 Compliance](11.3_compliance_framework_guide.md) |
> | **Next** | [12.1 Prompt Engineering](../12_user_developer_experience/12.1_prompt_engineering_guide.md) |

# Document 11.5: Access Control & Authentication Guide

## Purpose

Implementing robust access control and authentication mechanisms for LLM systems, ensuring secure access to models, data, and APIs while supporting multi-tenancy and compliance requirements.

## Prerequisites

- Understanding of authentication protocols (OAuth 2.0, OIDC, JWT)
- Familiarity with LLM security concepts (11.1)
- Knowledge of compliance requirements (11.3)
- Experience with API security patterns

## Table of Contents

1. [Authentication Methods](#1-authentication-methods)
2. [Authorization Models](#2-authorization-models)
3. [Access Control Implementation](#3-access-control-implementation)
4. [Identity Management](#4-identity-management)
5. [Audit & Monitoring](#5-audit--monitoring)
6. [Production Implementation](#6-production-implementation)

---

## 1. Authentication Methods

### 1.1 API Key Authentication

```python
"""
API key authentication for LLM services.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from datetime import datetime, timedelta
from enum import Enum
import hashlib
import secrets
import hmac
import time


class APIKeyStatus(Enum):
    """API key status."""
    ACTIVE = "active"
    REVOKED = "revoked"
    EXPIRED = "expired"
    SUSPENDED = "suspended"


@dataclass
class APIKeyMetadata:
    """Metadata for an API key."""
    key_id: str
    name: str
    prefix: str  # First 8 chars of key for identification
    hashed_key: str

    owner_id: str
    organization_id: str

    created_at: datetime
    expires_at: Optional[datetime]
    last_used: Optional[datetime]

    status: APIKeyStatus
    scopes: List[str]
    rate_limit: Optional[int]  # Requests per minute

    allowed_ips: List[str] = field(default_factory=list)
    allowed_models: List[str] = field(default_factory=list)

    usage_count: int = 0
    metadata: Dict = field(default_factory=dict)


class APIKeyManager:
    """
    Manages API keys for LLM service authentication.
    """

    KEY_LENGTH = 48  # bytes
    PREFIX_LENGTH = 8  # characters

    def __init__(self, storage_backend=None):
        self.storage = storage_backend or {}
        self.keys_by_prefix: Dict[str, str] = {}  # prefix -> key_id

    def generate_key(
        self,
        name: str,
        owner_id: str,
        organization_id: str,
        scopes: List[str],
        expires_in_days: Optional[int] = None,
        rate_limit: Optional[int] = None,
        allowed_ips: Optional[List[str]] = None,
        allowed_models: Optional[List[str]] = None
    ) -> tuple[str, APIKeyMetadata]:
        """Generate a new API key."""
        # Generate secure random key
        raw_key = secrets.token_urlsafe(self.KEY_LENGTH)
        prefix = raw_key[:self.PREFIX_LENGTH]
        hashed_key = self._hash_key(raw_key)

        key_id = f"key_{secrets.token_hex(16)}"

        expires_at = None
        if expires_in_days:
            expires_at = datetime.utcnow() + timedelta(days=expires_in_days)

        metadata = APIKeyMetadata(
            key_id=key_id,
            name=name,
            prefix=prefix,
            hashed_key=hashed_key,
            owner_id=owner_id,
            organization_id=organization_id,
            created_at=datetime.utcnow(),
            expires_at=expires_at,
            last_used=None,
            status=APIKeyStatus.ACTIVE,
            scopes=scopes,
            rate_limit=rate_limit,
            allowed_ips=allowed_ips or [],
            allowed_models=allowed_models or []
        )

        self.storage[key_id] = metadata
        self.keys_by_prefix[prefix] = key_id

        # Return the raw key only once - it's never stored
        return f"sk-{raw_key}", metadata

    def _hash_key(self, key: str) -> str:
        """Hash API key for storage."""
        return hashlib.sha256(key.encode()).hexdigest()

    def validate_key(
        self,
        api_key: str,
        required_scopes: Optional[List[str]] = None,
        client_ip: Optional[str] = None,
        model_id: Optional[str] = None
    ) -> tuple[bool, Optional[APIKeyMetadata], Optional[str]]:
        """
        Validate an API key.

        Returns: (is_valid, metadata, error_message)
        """
        if not api_key.startswith("sk-"):
            return False, None, "Invalid key format"

        raw_key = api_key[3:]  # Remove "sk-" prefix
        prefix = raw_key[:self.PREFIX_LENGTH]

        # Find key by prefix
        key_id = self.keys_by_prefix.get(prefix)
        if not key_id:
            return False, None, "Key not found"

        metadata = self.storage.get(key_id)
        if not metadata:
            return False, None, "Key not found"

        # Verify hash using constant-time comparison
        hashed = self._hash_key(raw_key)
        if not hmac.compare_digest(hashed, metadata.hashed_key):
            return False, None, "Invalid key"

        # Check status
        if metadata.status != APIKeyStatus.ACTIVE:
            return False, metadata, f"Key is {metadata.status.value}"

        # Check expiration
        if metadata.expires_at and datetime.utcnow() > metadata.expires_at:
            metadata.status = APIKeyStatus.EXPIRED
            return False, metadata, "Key has expired"

        # Check IP allowlist
        if metadata.allowed_ips and client_ip:
            if client_ip not in metadata.allowed_ips:
                return False, metadata, "IP not in allowlist"

        # Check model allowlist
        if metadata.allowed_models and model_id:
            if model_id not in metadata.allowed_models:
                return False, metadata, "Model not in allowlist"

        # Check scopes
        if required_scopes:
            if not all(s in metadata.scopes for s in required_scopes):
                return False, metadata, "Insufficient scopes"

        # Update usage
        metadata.last_used = datetime.utcnow()
        metadata.usage_count += 1

        return True, metadata, None

    def revoke_key(self, key_id: str, reason: str = "") -> bool:
        """Revoke an API key."""
        metadata = self.storage.get(key_id)
        if not metadata:
            return False

        metadata.status = APIKeyStatus.REVOKED
        metadata.metadata["revocation_reason"] = reason
        metadata.metadata["revoked_at"] = datetime.utcnow().isoformat()

        return True

    def rotate_key(
        self,
        key_id: str,
        grace_period_hours: int = 24
    ) -> tuple[str, APIKeyMetadata]:
        """Rotate an API key, keeping the old key valid for a grace period."""
        old_metadata = self.storage.get(key_id)
        if not old_metadata:
            raise ValueError(f"Key {key_id} not found")

        # Generate new key with same settings
        new_key, new_metadata = self.generate_key(
            name=f"{old_metadata.name} (rotated)",
            owner_id=old_metadata.owner_id,
            organization_id=old_metadata.organization_id,
            scopes=old_metadata.scopes,
            rate_limit=old_metadata.rate_limit,
            allowed_ips=old_metadata.allowed_ips,
            allowed_models=old_metadata.allowed_models
        )

        # Set old key to expire after grace period
        old_metadata.expires_at = datetime.utcnow() + timedelta(hours=grace_period_hours)
        old_metadata.metadata["rotated_to"] = new_metadata.key_id

        return new_key, new_metadata

    def list_keys(
        self,
        owner_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        include_revoked: bool = False
    ) -> List[Dict]:
        """List API keys (without the actual key values)."""
        results = []

        for metadata in self.storage.values():
            if owner_id and metadata.owner_id != owner_id:
                continue
            if organization_id and metadata.organization_id != organization_id:
                continue
            if not include_revoked and metadata.status == APIKeyStatus.REVOKED:
                continue

            results.append({
                "key_id": metadata.key_id,
                "name": metadata.name,
                "prefix": metadata.prefix,
                "status": metadata.status.value,
                "scopes": metadata.scopes,
                "created_at": metadata.created_at.isoformat(),
                "expires_at": metadata.expires_at.isoformat() if metadata.expires_at else None,
                "last_used": metadata.last_used.isoformat() if metadata.last_used else None,
                "usage_count": metadata.usage_count
            })

        return results
```

### 1.2 OAuth 2.0 / OpenID Connect

```python
"""
OAuth 2.0 and OIDC implementation for LLM services.
"""
from dataclasses import dataclass
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from enum import Enum
import jwt
import secrets
import hashlib
import base64
from urllib.parse import urlencode


class OAuth2GrantType(Enum):
    """Supported OAuth 2.0 grant types."""
    AUTHORIZATION_CODE = "authorization_code"
    CLIENT_CREDENTIALS = "client_credentials"
    REFRESH_TOKEN = "refresh_token"
    DEVICE_CODE = "device_code"


@dataclass
class OAuth2Client:
    """OAuth 2.0 client registration."""
    client_id: str
    client_secret_hash: str
    client_name: str

    redirect_uris: List[str]
    allowed_scopes: List[str]
    allowed_grant_types: List[OAuth2GrantType]

    organization_id: str
    is_public: bool = False  # Public clients (SPAs, mobile) don't have secrets

    created_at: datetime = None
    metadata: Dict = None


@dataclass
class TokenResponse:
    """OAuth 2.0 token response."""
    access_token: str
    token_type: str = "Bearer"
    expires_in: int = 3600
    refresh_token: Optional[str] = None
    scope: Optional[str] = None
    id_token: Optional[str] = None  # For OIDC


class OAuth2Server:
    """
    OAuth 2.0 authorization server for LLM APIs.
    """

    def __init__(
        self,
        issuer: str,
        signing_key: str,
        access_token_lifetime: int = 3600,
        refresh_token_lifetime: int = 86400 * 30
    ):
        self.issuer = issuer
        self.signing_key = signing_key
        self.access_token_lifetime = access_token_lifetime
        self.refresh_token_lifetime = refresh_token_lifetime

        self.clients: Dict[str, OAuth2Client] = {}
        self.authorization_codes: Dict[str, Dict] = {}
        self.refresh_tokens: Dict[str, Dict] = {}

    def register_client(
        self,
        client_name: str,
        redirect_uris: List[str],
        allowed_scopes: List[str],
        grant_types: List[OAuth2GrantType],
        organization_id: str,
        is_public: bool = False
    ) -> tuple[str, Optional[str]]:
        """Register a new OAuth 2.0 client."""
        client_id = f"client_{secrets.token_hex(16)}"

        client_secret = None
        client_secret_hash = ""

        if not is_public:
            client_secret = secrets.token_urlsafe(32)
            client_secret_hash = hashlib.sha256(client_secret.encode()).hexdigest()

        client = OAuth2Client(
            client_id=client_id,
            client_secret_hash=client_secret_hash,
            client_name=client_name,
            redirect_uris=redirect_uris,
            allowed_scopes=allowed_scopes,
            allowed_grant_types=grant_types,
            organization_id=organization_id,
            is_public=is_public,
            created_at=datetime.utcnow(),
            metadata={}
        )

        self.clients[client_id] = client

        return client_id, client_secret

    def authorize(
        self,
        client_id: str,
        redirect_uri: str,
        scope: str,
        state: str,
        response_type: str = "code",
        code_challenge: Optional[str] = None,
        code_challenge_method: Optional[str] = None,
        user_id: Optional[str] = None
    ) -> Dict:
        """
        Authorization endpoint - generates authorization code.
        In production, this would be called after user authentication.
        """
        client = self.clients.get(client_id)
        if not client:
            return {"error": "invalid_client", "error_description": "Client not found"}

        if redirect_uri not in client.redirect_uris:
            return {"error": "invalid_request", "error_description": "Invalid redirect URI"}

        requested_scopes = set(scope.split())
        if not requested_scopes.issubset(set(client.allowed_scopes)):
            return {"error": "invalid_scope", "error_description": "Scope not allowed"}

        if OAuth2GrantType.AUTHORIZATION_CODE not in client.allowed_grant_types:
            return {"error": "unauthorized_client", "error_description": "Grant type not allowed"}

        # Generate authorization code
        code = secrets.token_urlsafe(32)

        self.authorization_codes[code] = {
            "client_id": client_id,
            "redirect_uri": redirect_uri,
            "scope": scope,
            "user_id": user_id,
            "code_challenge": code_challenge,
            "code_challenge_method": code_challenge_method,
            "created_at": datetime.utcnow(),
            "expires_at": datetime.utcnow() + timedelta(minutes=10)
        }

        # Build redirect URL
        params = {"code": code, "state": state}
        redirect_url = f"{redirect_uri}?{urlencode(params)}"

        return {"redirect_url": redirect_url, "code": code}

    def token(
        self,
        grant_type: str,
        client_id: str,
        client_secret: Optional[str] = None,
        code: Optional[str] = None,
        redirect_uri: Optional[str] = None,
        refresh_token: Optional[str] = None,
        code_verifier: Optional[str] = None,
        scope: Optional[str] = None
    ) -> TokenResponse | Dict:
        """Token endpoint - exchanges code or credentials for tokens."""
        client = self.clients.get(client_id)
        if not client:
            return {"error": "invalid_client"}

        # Verify client secret for confidential clients
        if not client.is_public:
            if not client_secret:
                return {"error": "invalid_client", "error_description": "Client secret required"}
            secret_hash = hashlib.sha256(client_secret.encode()).hexdigest()
            if secret_hash != client.client_secret_hash:
                return {"error": "invalid_client", "error_description": "Invalid client secret"}

        if grant_type == "authorization_code":
            return self._handle_authorization_code(
                client, code, redirect_uri, code_verifier
            )
        elif grant_type == "client_credentials":
            return self._handle_client_credentials(client, scope)
        elif grant_type == "refresh_token":
            return self._handle_refresh_token(client, refresh_token)
        else:
            return {"error": "unsupported_grant_type"}

    def _handle_authorization_code(
        self,
        client: OAuth2Client,
        code: str,
        redirect_uri: str,
        code_verifier: Optional[str]
    ) -> TokenResponse | Dict:
        """Handle authorization code grant."""
        if OAuth2GrantType.AUTHORIZATION_CODE not in client.allowed_grant_types:
            return {"error": "unauthorized_client"}

        code_data = self.authorization_codes.get(code)
        if not code_data:
            return {"error": "invalid_grant", "error_description": "Invalid authorization code"}

        if code_data["client_id"] != client.client_id:
            return {"error": "invalid_grant"}

        if code_data["redirect_uri"] != redirect_uri:
            return {"error": "invalid_grant"}

        if datetime.utcnow() > code_data["expires_at"]:
            del self.authorization_codes[code]
            return {"error": "invalid_grant", "error_description": "Authorization code expired"}

        # Verify PKCE if used
        if code_data.get("code_challenge"):
            if not code_verifier:
                return {"error": "invalid_grant", "error_description": "Code verifier required"}

            if code_data["code_challenge_method"] == "S256":
                verifier_hash = base64.urlsafe_b64encode(
                    hashlib.sha256(code_verifier.encode()).digest()
                ).decode().rstrip("=")
                if verifier_hash != code_data["code_challenge"]:
                    return {"error": "invalid_grant", "error_description": "Invalid code verifier"}

        # Consume the code
        del self.authorization_codes[code]

        # Generate tokens
        return self._generate_tokens(
            client=client,
            user_id=code_data["user_id"],
            scope=code_data["scope"],
            include_refresh=True
        )

    def _handle_client_credentials(
        self,
        client: OAuth2Client,
        scope: Optional[str]
    ) -> TokenResponse | Dict:
        """Handle client credentials grant."""
        if OAuth2GrantType.CLIENT_CREDENTIALS not in client.allowed_grant_types:
            return {"error": "unauthorized_client"}

        requested_scopes = set(scope.split()) if scope else set()
        allowed_scopes = set(client.allowed_scopes)

        if not requested_scopes.issubset(allowed_scopes):
            return {"error": "invalid_scope"}

        return self._generate_tokens(
            client=client,
            user_id=None,  # No user for client credentials
            scope=scope or " ".join(client.allowed_scopes),
            include_refresh=False  # No refresh token for client credentials
        )

    def _handle_refresh_token(
        self,
        client: OAuth2Client,
        refresh_token: str
    ) -> TokenResponse | Dict:
        """Handle refresh token grant."""
        if OAuth2GrantType.REFRESH_TOKEN not in client.allowed_grant_types:
            return {"error": "unauthorized_client"}

        token_data = self.refresh_tokens.get(refresh_token)
        if not token_data:
            return {"error": "invalid_grant", "error_description": "Invalid refresh token"}

        if token_data["client_id"] != client.client_id:
            return {"error": "invalid_grant"}

        if datetime.utcnow() > token_data["expires_at"]:
            del self.refresh_tokens[refresh_token]
            return {"error": "invalid_grant", "error_description": "Refresh token expired"}

        # Generate new tokens
        return self._generate_tokens(
            client=client,
            user_id=token_data["user_id"],
            scope=token_data["scope"],
            include_refresh=True
        )

    def _generate_tokens(
        self,
        client: OAuth2Client,
        user_id: Optional[str],
        scope: str,
        include_refresh: bool
    ) -> TokenResponse:
        """Generate access and optionally refresh tokens."""
        now = datetime.utcnow()

        # Access token claims
        access_claims = {
            "iss": self.issuer,
            "sub": user_id or client.client_id,
            "aud": self.issuer,
            "client_id": client.client_id,
            "organization_id": client.organization_id,
            "scope": scope,
            "iat": int(now.timestamp()),
            "exp": int((now + timedelta(seconds=self.access_token_lifetime)).timestamp()),
            "jti": secrets.token_hex(16)
        }

        access_token = jwt.encode(access_claims, self.signing_key, algorithm="HS256")

        response = TokenResponse(
            access_token=access_token,
            expires_in=self.access_token_lifetime,
            scope=scope
        )

        # Generate refresh token if requested
        if include_refresh:
            refresh_token = secrets.token_urlsafe(32)
            self.refresh_tokens[refresh_token] = {
                "client_id": client.client_id,
                "user_id": user_id,
                "scope": scope,
                "created_at": now,
                "expires_at": now + timedelta(seconds=self.refresh_token_lifetime)
            }
            response.refresh_token = refresh_token

        return response

    def validate_token(self, access_token: str) -> tuple[bool, Optional[Dict], Optional[str]]:
        """Validate an access token."""
        try:
            claims = jwt.decode(
                access_token,
                self.signing_key,
                algorithms=["HS256"],
                audience=self.issuer
            )
            return True, claims, None
        except jwt.ExpiredSignatureError:
            return False, None, "Token has expired"
        except jwt.InvalidTokenError as e:
            return False, None, f"Invalid token: {str(e)}"

    def revoke_token(self, token: str, token_type_hint: str = "access_token") -> bool:
        """Revoke a token."""
        if token_type_hint == "refresh_token":
            if token in self.refresh_tokens:
                del self.refresh_tokens[token]
                return True
        # For access tokens, add to a blacklist (not shown for brevity)
        return False
```

### 1.3 JWT Token Validation

```python
"""
JWT token validation for LLM API authentication.
"""
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import jwt
from jwt import PyJWKClient
import time


@dataclass
class TokenValidationConfig:
    """Configuration for token validation."""
    issuer: str
    audience: str
    algorithms: List[str] = None
    jwks_uri: Optional[str] = None
    signing_key: Optional[str] = None
    leeway: int = 30  # seconds
    required_claims: List[str] = None

    def __post_init__(self):
        if self.algorithms is None:
            self.algorithms = ["RS256", "HS256"]
        if self.required_claims is None:
            self.required_claims = ["sub", "exp", "iat"]


class JWTValidator:
    """
    Validates JWT tokens for LLM API access.
    """

    def __init__(self, config: TokenValidationConfig):
        self.config = config
        self.jwks_client = None

        if config.jwks_uri:
            self.jwks_client = PyJWKClient(config.jwks_uri)

    def validate(
        self,
        token: str,
        required_scopes: Optional[List[str]] = None,
        required_claims: Optional[Dict[str, Any]] = None
    ) -> tuple[bool, Optional[Dict], Optional[str]]:
        """
        Validate a JWT token.

        Returns: (is_valid, claims, error_message)
        """
        try:
            # Get signing key
            if self.jwks_client:
                signing_key = self.jwks_client.get_signing_key_from_jwt(token)
                key = signing_key.key
            else:
                key = self.config.signing_key

            # Decode and validate
            claims = jwt.decode(
                token,
                key,
                algorithms=self.config.algorithms,
                issuer=self.config.issuer,
                audience=self.config.audience,
                leeway=self.config.leeway,
                options={
                    "require": self.config.required_claims
                }
            )

            # Check required scopes
            if required_scopes:
                token_scopes = claims.get("scope", "").split()
                if not all(s in token_scopes for s in required_scopes):
                    return False, claims, "Insufficient scopes"

            # Check additional required claims
            if required_claims:
                for claim, expected in required_claims.items():
                    if claims.get(claim) != expected:
                        return False, claims, f"Invalid claim: {claim}"

            return True, claims, None

        except jwt.ExpiredSignatureError:
            return False, None, "Token has expired"
        except jwt.InvalidIssuerError:
            return False, None, "Invalid token issuer"
        except jwt.InvalidAudienceError:
            return False, None, "Invalid token audience"
        except jwt.InvalidSignatureError:
            return False, None, "Invalid token signature"
        except jwt.DecodeError as e:
            return False, None, f"Token decode error: {str(e)}"
        except Exception as e:
            return False, None, f"Token validation error: {str(e)}"

    def extract_claims(self, token: str) -> Optional[Dict]:
        """Extract claims without full validation (for debugging)."""
        try:
            return jwt.decode(token, options={"verify_signature": False})
        except Exception:
            return None
```

---

## 2. Authorization Models

### 2.1 Role-Based Access Control (RBAC)

```python
"""
Role-Based Access Control for LLM systems.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional
from enum import Enum
from datetime import datetime


class Permission(Enum):
    """LLM-specific permissions."""
    # Model permissions
    MODEL_READ = "model:read"
    MODEL_INVOKE = "model:invoke"
    MODEL_DEPLOY = "model:deploy"
    MODEL_MANAGE = "model:manage"

    # Data permissions
    DATA_READ = "data:read"
    DATA_WRITE = "data:write"
    DATA_DELETE = "data:delete"

    # RAG permissions
    RAG_QUERY = "rag:query"
    RAG_INDEX = "rag:index"
    RAG_MANAGE = "rag:manage"

    # Admin permissions
    USER_MANAGE = "user:manage"
    ROLE_MANAGE = "role:manage"
    ORG_MANAGE = "org:manage"
    AUDIT_READ = "audit:read"

    # API permissions
    API_KEY_CREATE = "api_key:create"
    API_KEY_REVOKE = "api_key:revoke"


@dataclass
class Role:
    """Role definition."""
    role_id: str
    name: str
    description: str
    permissions: Set[Permission]
    is_system_role: bool = False  # System roles cannot be modified
    created_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict = field(default_factory=dict)


@dataclass
class RoleAssignment:
    """User-role assignment."""
    user_id: str
    role_id: str
    resource_scope: Optional[str] = None  # e.g., "model:gpt-4", "org:acme"
    assigned_by: str = ""
    assigned_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None


class RBACManager:
    """
    Manages role-based access control for LLM systems.
    """

    def __init__(self):
        self.roles: Dict[str, Role] = {}
        self.assignments: List[RoleAssignment] = []
        self._initialize_system_roles()

    def _initialize_system_roles(self):
        """Initialize default system roles."""
        system_roles = [
            Role(
                role_id="admin",
                name="Administrator",
                description="Full system access",
                permissions=set(Permission),
                is_system_role=True
            ),
            Role(
                role_id="developer",
                name="Developer",
                description="Model development and deployment",
                permissions={
                    Permission.MODEL_READ,
                    Permission.MODEL_INVOKE,
                    Permission.MODEL_DEPLOY,
                    Permission.DATA_READ,
                    Permission.DATA_WRITE,
                    Permission.RAG_QUERY,
                    Permission.RAG_INDEX,
                    Permission.API_KEY_CREATE
                },
                is_system_role=True
            ),
            Role(
                role_id="user",
                name="User",
                description="Basic model access",
                permissions={
                    Permission.MODEL_READ,
                    Permission.MODEL_INVOKE,
                    Permission.RAG_QUERY
                },
                is_system_role=True
            ),
            Role(
                role_id="viewer",
                name="Viewer",
                description="Read-only access",
                permissions={
                    Permission.MODEL_READ,
                    Permission.DATA_READ,
                    Permission.AUDIT_READ
                },
                is_system_role=True
            ),
            Role(
                role_id="data_manager",
                name="Data Manager",
                description="Data and RAG management",
                permissions={
                    Permission.DATA_READ,
                    Permission.DATA_WRITE,
                    Permission.DATA_DELETE,
                    Permission.RAG_QUERY,
                    Permission.RAG_INDEX,
                    Permission.RAG_MANAGE
                },
                is_system_role=True
            )
        ]

        for role in system_roles:
            self.roles[role.role_id] = role

    def create_role(
        self,
        role_id: str,
        name: str,
        description: str,
        permissions: List[Permission]
    ) -> Role:
        """Create a custom role."""
        if role_id in self.roles:
            raise ValueError(f"Role {role_id} already exists")

        role = Role(
            role_id=role_id,
            name=name,
            description=description,
            permissions=set(permissions),
            is_system_role=False
        )

        self.roles[role_id] = role
        return role

    def assign_role(
        self,
        user_id: str,
        role_id: str,
        assigned_by: str,
        resource_scope: Optional[str] = None,
        expires_at: Optional[datetime] = None
    ) -> RoleAssignment:
        """Assign a role to a user."""
        if role_id not in self.roles:
            raise ValueError(f"Role {role_id} not found")

        # Check for duplicate assignment
        for assignment in self.assignments:
            if (assignment.user_id == user_id and
                assignment.role_id == role_id and
                assignment.resource_scope == resource_scope):
                raise ValueError("Role already assigned")

        assignment = RoleAssignment(
            user_id=user_id,
            role_id=role_id,
            resource_scope=resource_scope,
            assigned_by=assigned_by,
            expires_at=expires_at
        )

        self.assignments.append(assignment)
        return assignment

    def revoke_role(
        self,
        user_id: str,
        role_id: str,
        resource_scope: Optional[str] = None
    ) -> bool:
        """Revoke a role from a user."""
        for i, assignment in enumerate(self.assignments):
            if (assignment.user_id == user_id and
                assignment.role_id == role_id and
                assignment.resource_scope == resource_scope):
                del self.assignments[i]
                return True
        return False

    def get_user_permissions(
        self,
        user_id: str,
        resource_scope: Optional[str] = None
    ) -> Set[Permission]:
        """Get all permissions for a user."""
        permissions = set()
        now = datetime.utcnow()

        for assignment in self.assignments:
            if assignment.user_id != user_id:
                continue

            # Check expiration
            if assignment.expires_at and now > assignment.expires_at:
                continue

            # Check scope match
            if resource_scope:
                if assignment.resource_scope and assignment.resource_scope != resource_scope:
                    # Check hierarchical scope (e.g., org:acme matches org:acme/model:gpt-4)
                    if not resource_scope.startswith(assignment.resource_scope):
                        continue

            role = self.roles.get(assignment.role_id)
            if role:
                permissions.update(role.permissions)

        return permissions

    def check_permission(
        self,
        user_id: str,
        permission: Permission,
        resource_scope: Optional[str] = None
    ) -> bool:
        """Check if a user has a specific permission."""
        user_permissions = self.get_user_permissions(user_id, resource_scope)
        return permission in user_permissions

    def get_user_roles(self, user_id: str) -> List[Dict]:
        """Get all roles assigned to a user."""
        roles = []
        now = datetime.utcnow()

        for assignment in self.assignments:
            if assignment.user_id != user_id:
                continue

            is_expired = assignment.expires_at and now > assignment.expires_at
            role = self.roles.get(assignment.role_id)

            roles.append({
                "role_id": assignment.role_id,
                "role_name": role.name if role else "Unknown",
                "resource_scope": assignment.resource_scope,
                "assigned_at": assignment.assigned_at.isoformat(),
                "expires_at": assignment.expires_at.isoformat() if assignment.expires_at else None,
                "is_expired": is_expired
            })

        return roles
```

### 2.2 Attribute-Based Access Control (ABAC)

```python
"""
Attribute-Based Access Control for fine-grained LLM access.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Any, Callable, Optional
from enum import Enum
from datetime import datetime
import re


class PolicyEffect(Enum):
    """Policy decision effect."""
    ALLOW = "allow"
    DENY = "deny"


class PolicyConditionOperator(Enum):
    """Operators for policy conditions."""
    EQUALS = "eq"
    NOT_EQUALS = "neq"
    IN = "in"
    NOT_IN = "not_in"
    CONTAINS = "contains"
    STARTS_WITH = "starts_with"
    REGEX = "regex"
    GREATER_THAN = "gt"
    LESS_THAN = "lt"
    GREATER_OR_EQUAL = "gte"
    LESS_OR_EQUAL = "lte"


@dataclass
class PolicyCondition:
    """Single condition in a policy."""
    attribute: str  # e.g., "subject.department", "resource.model_id"
    operator: PolicyConditionOperator
    value: Any


@dataclass
class Policy:
    """ABAC policy definition."""
    policy_id: str
    name: str
    description: str
    effect: PolicyEffect
    priority: int  # Higher priority policies are evaluated first

    # Target - which requests this policy applies to
    resource_type: str  # e.g., "model", "data", "api"
    actions: List[str]  # e.g., ["invoke", "read"]

    # Conditions
    conditions: List[PolicyCondition]

    # Metadata
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class ABACRequest:
    """Access request to evaluate."""
    subject: Dict[str, Any]  # User attributes
    resource: Dict[str, Any]  # Resource attributes
    action: str
    environment: Dict[str, Any] = field(default_factory=dict)  # Context


class ABACEngine:
    """
    Attribute-Based Access Control engine.
    """

    def __init__(self):
        self.policies: Dict[str, Policy] = {}

    def add_policy(self, policy: Policy) -> None:
        """Add a policy to the engine."""
        self.policies[policy.policy_id] = policy

    def remove_policy(self, policy_id: str) -> bool:
        """Remove a policy."""
        if policy_id in self.policies:
            del self.policies[policy_id]
            return True
        return False

    def evaluate(self, request: ABACRequest) -> tuple[bool, str]:
        """
        Evaluate a request against all policies.

        Returns: (is_allowed, reason)
        """
        # Get applicable policies sorted by priority
        applicable = [
            p for p in self.policies.values()
            if p.is_active and self._matches_target(p, request)
        ]
        applicable.sort(key=lambda p: p.priority, reverse=True)

        if not applicable:
            return False, "No applicable policy found"

        # Evaluate policies (first match wins for same priority)
        for policy in applicable:
            if self._evaluate_conditions(policy, request):
                if policy.effect == PolicyEffect.ALLOW:
                    return True, f"Allowed by policy: {policy.name}"
                else:
                    return False, f"Denied by policy: {policy.name}"

        return False, "No policy matched"

    def _matches_target(self, policy: Policy, request: ABACRequest) -> bool:
        """Check if policy target matches request."""
        resource_type = request.resource.get("type", "")
        if policy.resource_type != "*" and policy.resource_type != resource_type:
            return False

        if "*" not in policy.actions and request.action not in policy.actions:
            return False

        return True

    def _evaluate_conditions(self, policy: Policy, request: ABACRequest) -> bool:
        """Evaluate all conditions in a policy."""
        for condition in policy.conditions:
            if not self._evaluate_condition(condition, request):
                return False
        return True

    def _evaluate_condition(self, condition: PolicyCondition, request: ABACRequest) -> bool:
        """Evaluate a single condition."""
        # Get attribute value
        value = self._get_attribute(condition.attribute, request)
        if value is None:
            return False

        expected = condition.value
        op = condition.operator

        if op == PolicyConditionOperator.EQUALS:
            return value == expected
        elif op == PolicyConditionOperator.NOT_EQUALS:
            return value != expected
        elif op == PolicyConditionOperator.IN:
            return value in expected
        elif op == PolicyConditionOperator.NOT_IN:
            return value not in expected
        elif op == PolicyConditionOperator.CONTAINS:
            return expected in value if isinstance(value, (str, list)) else False
        elif op == PolicyConditionOperator.STARTS_WITH:
            return value.startswith(expected) if isinstance(value, str) else False
        elif op == PolicyConditionOperator.REGEX:
            return bool(re.match(expected, str(value)))
        elif op == PolicyConditionOperator.GREATER_THAN:
            return value > expected
        elif op == PolicyConditionOperator.LESS_THAN:
            return value < expected
        elif op == PolicyConditionOperator.GREATER_OR_EQUAL:
            return value >= expected
        elif op == PolicyConditionOperator.LESS_OR_EQUAL:
            return value <= expected

        return False

    def _get_attribute(self, path: str, request: ABACRequest) -> Any:
        """Get attribute value from request using dot notation."""
        parts = path.split(".")
        if not parts:
            return None

        # Determine source
        source_map = {
            "subject": request.subject,
            "resource": request.resource,
            "action": {"name": request.action},
            "environment": request.environment
        }

        source = source_map.get(parts[0])
        if source is None:
            return None

        # Navigate to attribute
        current = source
        for part in parts[1:]:
            if isinstance(current, dict):
                current = current.get(part)
            else:
                return None
            if current is None:
                return None

        return current


def create_llm_access_policies() -> ABACEngine:
    """Create standard ABAC policies for LLM systems."""
    engine = ABACEngine()

    # Policy: Allow production models for production users
    engine.add_policy(Policy(
        policy_id="prod-model-access",
        name="Production Model Access",
        description="Allow access to production models for production-tier users",
        effect=PolicyEffect.ALLOW,
        priority=100,
        resource_type="model",
        actions=["invoke", "read"],
        conditions=[
            PolicyCondition(
                attribute="resource.tier",
                operator=PolicyConditionOperator.EQUALS,
                value="production"
            ),
            PolicyCondition(
                attribute="subject.tier",
                operator=PolicyConditionOperator.IN,
                value=["production", "admin"]
            )
        ]
    ))

    # Policy: Deny access to restricted models
    engine.add_policy(Policy(
        policy_id="restricted-model-deny",
        name="Restricted Model Deny",
        description="Deny access to restricted models without explicit permission",
        effect=PolicyEffect.DENY,
        priority=200,  # Higher priority than allow
        resource_type="model",
        actions=["*"],
        conditions=[
            PolicyCondition(
                attribute="resource.classification",
                operator=PolicyConditionOperator.EQUALS,
                value="restricted"
            ),
            PolicyCondition(
                attribute="subject.restricted_access",
                operator=PolicyConditionOperator.NOT_EQUALS,
                value=True
            )
        ]
    ))

    # Policy: Rate limit based on tier
    engine.add_policy(Policy(
        policy_id="rate-limit-enforcement",
        name="Rate Limit Enforcement",
        description="Enforce rate limits based on user tier",
        effect=PolicyEffect.DENY,
        priority=150,
        resource_type="api",
        actions=["invoke"],
        conditions=[
            PolicyCondition(
                attribute="environment.requests_this_minute",
                operator=PolicyConditionOperator.GREATER_THAN,
                value=100
            ),
            PolicyCondition(
                attribute="subject.tier",
                operator=PolicyConditionOperator.NOT_IN,
                value=["enterprise", "admin"]
            )
        ]
    ))

    # Policy: Allow RAG access for own documents only
    engine.add_policy(Policy(
        policy_id="rag-document-isolation",
        name="RAG Document Isolation",
        description="Users can only query their own organization's documents",
        effect=PolicyEffect.ALLOW,
        priority=100,
        resource_type="rag",
        actions=["query"],
        conditions=[
            PolicyCondition(
                attribute="subject.organization_id",
                operator=PolicyConditionOperator.EQUALS,
                value="${resource.organization_id}"  # Dynamic matching
            )
        ]
    ))

    return engine
```

---

## 3. Access Control Implementation

### 3.1 Multi-Layer Access Control

```python
"""
Multi-layer access control combining authentication and authorization.
"""
from dataclasses import dataclass
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime
from enum import Enum
import functools


@dataclass
class AccessContext:
    """Context for access control decisions."""
    # Identity
    user_id: Optional[str] = None
    client_id: Optional[str] = None
    organization_id: Optional[str] = None

    # Authentication
    auth_method: str = ""  # "api_key", "oauth", "jwt"
    token_claims: Dict = None
    api_key_metadata: Any = None

    # Request
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    request_id: str = ""

    # Extracted attributes
    scopes: List[str] = None
    permissions: List[str] = None
    roles: List[str] = None


class AccessDecision(Enum):
    """Access control decision."""
    ALLOW = "allow"
    DENY = "deny"
    CHALLENGE = "challenge"  # Require additional auth


@dataclass
class AccessResult:
    """Result of access control check."""
    decision: AccessDecision
    reason: str
    context: AccessContext
    checked_at: datetime = None

    def __post_init__(self):
        if self.checked_at is None:
            self.checked_at = datetime.utcnow()


class MultiLayerAccessControl:
    """
    Combines multiple access control mechanisms.
    """

    def __init__(
        self,
        api_key_manager: APIKeyManager,
        jwt_validator: JWTValidator,
        rbac_manager: RBACManager,
        abac_engine: ABACEngine
    ):
        self.api_key_manager = api_key_manager
        self.jwt_validator = jwt_validator
        self.rbac_manager = rbac_manager
        self.abac_engine = abac_engine

    def authenticate(
        self,
        authorization_header: Optional[str],
        api_key_header: Optional[str],
        client_ip: Optional[str] = None
    ) -> tuple[bool, Optional[AccessContext], Optional[str]]:
        """
        Authenticate a request.

        Supports:
        - Bearer tokens (OAuth/JWT)
        - API keys
        """
        context = AccessContext(ip_address=client_ip)

        # Try Bearer token first
        if authorization_header and authorization_header.startswith("Bearer "):
            token = authorization_header[7:]
            valid, claims, error = self.jwt_validator.validate(token)

            if valid:
                context.auth_method = "jwt"
                context.token_claims = claims
                context.user_id = claims.get("sub")
                context.client_id = claims.get("client_id")
                context.organization_id = claims.get("organization_id")
                context.scopes = claims.get("scope", "").split()
                return True, context, None
            else:
                return False, None, f"JWT validation failed: {error}"

        # Try API key
        if api_key_header:
            valid, metadata, error = self.api_key_manager.validate_key(
                api_key_header,
                client_ip=client_ip
            )

            if valid:
                context.auth_method = "api_key"
                context.api_key_metadata = metadata
                context.user_id = metadata.owner_id
                context.organization_id = metadata.organization_id
                context.scopes = metadata.scopes
                return True, context, None
            else:
                return False, None, f"API key validation failed: {error}"

        return False, None, "No valid authentication provided"

    def authorize(
        self,
        context: AccessContext,
        resource_type: str,
        resource_id: str,
        action: str,
        resource_attributes: Optional[Dict] = None
    ) -> AccessResult:
        """
        Authorize an action on a resource.

        Combines RBAC and ABAC checks.
        """
        # Build ABAC request
        subject_attrs = {
            "user_id": context.user_id,
            "organization_id": context.organization_id,
            "scopes": context.scopes,
            "auth_method": context.auth_method
        }

        resource_attrs = {
            "type": resource_type,
            "id": resource_id,
            **(resource_attributes or {})
        }

        abac_request = ABACRequest(
            subject=subject_attrs,
            resource=resource_attrs,
            action=action,
            environment={
                "ip_address": context.ip_address,
                "timestamp": datetime.utcnow().isoformat()
            }
        )

        # Check ABAC policies first (for explicit denies)
        allowed, reason = self.abac_engine.evaluate(abac_request)

        if not allowed:
            return AccessResult(
                decision=AccessDecision.DENY,
                reason=reason,
                context=context
            )

        # Check RBAC permissions
        required_permission = self._map_action_to_permission(resource_type, action)
        if required_permission:
            resource_scope = f"{resource_type}:{resource_id}"
            has_permission = self.rbac_manager.check_permission(
                context.user_id,
                required_permission,
                resource_scope
            )

            if not has_permission:
                return AccessResult(
                    decision=AccessDecision.DENY,
                    reason=f"Missing permission: {required_permission.value}",
                    context=context
                )

        # Check scope-based access (for API keys / OAuth)
        if context.scopes:
            required_scope = f"{resource_type}:{action}"
            if required_scope not in context.scopes and "*" not in context.scopes:
                return AccessResult(
                    decision=AccessDecision.DENY,
                    reason=f"Missing scope: {required_scope}",
                    context=context
                )

        return AccessResult(
            decision=AccessDecision.ALLOW,
            reason="Access granted",
            context=context
        )

    def _map_action_to_permission(self, resource_type: str, action: str) -> Optional[Permission]:
        """Map resource actions to permissions."""
        permission_map = {
            ("model", "read"): Permission.MODEL_READ,
            ("model", "invoke"): Permission.MODEL_INVOKE,
            ("model", "deploy"): Permission.MODEL_DEPLOY,
            ("model", "manage"): Permission.MODEL_MANAGE,
            ("data", "read"): Permission.DATA_READ,
            ("data", "write"): Permission.DATA_WRITE,
            ("data", "delete"): Permission.DATA_DELETE,
            ("rag", "query"): Permission.RAG_QUERY,
            ("rag", "index"): Permission.RAG_INDEX,
            ("rag", "manage"): Permission.RAG_MANAGE
        }
        return permission_map.get((resource_type, action))


def require_access(
    access_control: MultiLayerAccessControl,
    resource_type: str,
    action: str
):
    """Decorator for requiring access control on endpoints."""
    def decorator(func: Callable):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Extract request context (framework-specific)
            # This is a simplified example
            request = kwargs.get("request")
            if not request:
                raise PermissionError("No request context")

            auth_header = request.headers.get("Authorization")
            api_key = request.headers.get("X-API-Key")
            client_ip = request.client.host

            # Authenticate
            authed, context, error = access_control.authenticate(
                auth_header, api_key, client_ip
            )

            if not authed:
                raise PermissionError(f"Authentication failed: {error}")

            # Get resource ID from request
            resource_id = kwargs.get("resource_id", "*")

            # Authorize
            result = access_control.authorize(
                context, resource_type, resource_id, action
            )

            if result.decision != AccessDecision.ALLOW:
                raise PermissionError(f"Authorization failed: {result.reason}")

            # Add context to kwargs for the handler
            kwargs["access_context"] = context

            return func(*args, **kwargs)

        return wrapper
    return decorator
```

### 3.2 Multi-Tenancy Isolation

```python
"""
Multi-tenant isolation for LLM systems.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from datetime import datetime
from enum import Enum


class IsolationLevel(Enum):
    """Levels of tenant isolation."""
    SHARED = "shared"          # Shared infrastructure
    NAMESPACE = "namespace"    # Logical isolation
    DEDICATED = "dedicated"    # Dedicated resources


@dataclass
class Tenant:
    """Tenant definition."""
    tenant_id: str
    name: str
    isolation_level: IsolationLevel

    # Quotas
    max_requests_per_minute: int = 1000
    max_tokens_per_day: int = 1000000
    max_storage_gb: float = 10.0

    # Allowed resources
    allowed_models: List[str] = field(default_factory=list)
    allowed_features: List[str] = field(default_factory=list)

    # Isolation configuration
    namespace: Optional[str] = None  # For namespace isolation
    dedicated_endpoint: Optional[str] = None  # For dedicated isolation

    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict = field(default_factory=dict)


class TenantIsolationManager:
    """
    Manages multi-tenant isolation and resource access.
    """

    def __init__(self):
        self.tenants: Dict[str, Tenant] = {}
        self.user_tenant_map: Dict[str, str] = {}  # user_id -> tenant_id

    def create_tenant(
        self,
        tenant_id: str,
        name: str,
        isolation_level: IsolationLevel,
        **kwargs
    ) -> Tenant:
        """Create a new tenant."""
        if tenant_id in self.tenants:
            raise ValueError(f"Tenant {tenant_id} already exists")

        namespace = None
        if isolation_level in [IsolationLevel.NAMESPACE, IsolationLevel.DEDICATED]:
            namespace = f"tenant-{tenant_id}"

        tenant = Tenant(
            tenant_id=tenant_id,
            name=name,
            isolation_level=isolation_level,
            namespace=namespace,
            **kwargs
        )

        self.tenants[tenant_id] = tenant
        return tenant

    def assign_user_to_tenant(self, user_id: str, tenant_id: str) -> None:
        """Assign a user to a tenant."""
        if tenant_id not in self.tenants:
            raise ValueError(f"Tenant {tenant_id} not found")
        self.user_tenant_map[user_id] = tenant_id

    def get_tenant_for_user(self, user_id: str) -> Optional[Tenant]:
        """Get the tenant for a user."""
        tenant_id = self.user_tenant_map.get(user_id)
        return self.tenants.get(tenant_id) if tenant_id else None

    def check_resource_access(
        self,
        tenant_id: str,
        resource_type: str,
        resource_id: str
    ) -> tuple[bool, Optional[str]]:
        """Check if a tenant can access a resource."""
        tenant = self.tenants.get(tenant_id)
        if not tenant:
            return False, "Tenant not found"

        # Check model access
        if resource_type == "model":
            if tenant.allowed_models and resource_id not in tenant.allowed_models:
                if "*" not in tenant.allowed_models:
                    return False, f"Model {resource_id} not allowed for tenant"

        # Check feature access
        if resource_type == "feature":
            if tenant.allowed_features and resource_id not in tenant.allowed_features:
                return False, f"Feature {resource_id} not allowed for tenant"

        return True, None

    def apply_tenant_context(
        self,
        tenant_id: str,
        request_context: Dict
    ) -> Dict:
        """Apply tenant-specific context to a request."""
        tenant = self.tenants.get(tenant_id)
        if not tenant:
            raise ValueError(f"Tenant {tenant_id} not found")

        context = request_context.copy()

        # Apply namespace
        if tenant.namespace:
            context["namespace"] = tenant.namespace

        # Apply quotas
        context["rate_limit"] = tenant.max_requests_per_minute
        context["token_limit"] = tenant.max_tokens_per_day

        # Apply isolation settings
        context["isolation_level"] = tenant.isolation_level.value

        if tenant.dedicated_endpoint:
            context["endpoint"] = tenant.dedicated_endpoint

        return context

    def get_tenant_metrics_filter(self, tenant_id: str) -> Dict:
        """Get metrics query filter for tenant isolation."""
        tenant = self.tenants.get(tenant_id)
        if not tenant:
            return {}

        return {
            "tenant_id": tenant_id,
            "namespace": tenant.namespace
        }


class TenantAwareRAGFilter:
    """
    Applies tenant isolation to RAG queries.
    """

    def __init__(self, isolation_manager: TenantIsolationManager):
        self.isolation_manager = isolation_manager

    def apply_filter(
        self,
        tenant_id: str,
        base_filter: Optional[Dict] = None
    ) -> Dict:
        """Apply tenant isolation filter to RAG query."""
        tenant = self.isolation_manager.tenants.get(tenant_id)
        if not tenant:
            raise ValueError(f"Tenant {tenant_id} not found")

        filter_dict = base_filter.copy() if base_filter else {}

        # Always filter by tenant
        filter_dict["tenant_id"] = tenant_id

        # Apply namespace if configured
        if tenant.namespace:
            filter_dict["namespace"] = tenant.namespace

        return filter_dict

    def validate_document_access(
        self,
        tenant_id: str,
        document_ids: List[str],
        document_metadata: Dict[str, Dict]
    ) -> List[str]:
        """
        Validate and filter document IDs to only include tenant-accessible docs.
        """
        accessible_docs = []

        for doc_id in document_ids:
            metadata = document_metadata.get(doc_id, {})
            doc_tenant = metadata.get("tenant_id")

            # Only allow access to own documents
            if doc_tenant == tenant_id:
                accessible_docs.append(doc_id)

        return accessible_docs
```

---

## 4. Identity Management

### 4.1 User and Service Account Management

```python
"""
Identity management for LLM systems.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from datetime import datetime
from enum import Enum
import secrets
import hashlib


class IdentityType(Enum):
    """Types of identities."""
    USER = "user"
    SERVICE_ACCOUNT = "service_account"
    API_CLIENT = "api_client"


class IdentityStatus(Enum):
    """Identity status."""
    ACTIVE = "active"
    SUSPENDED = "suspended"
    DEACTIVATED = "deactivated"
    PENDING = "pending"


@dataclass
class Identity:
    """Base identity."""
    identity_id: str
    identity_type: IdentityType
    display_name: str
    email: Optional[str]
    organization_id: str

    status: IdentityStatus = IdentityStatus.ACTIVE
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_active: Optional[datetime] = None

    groups: List[str] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)


@dataclass
class User(Identity):
    """Human user identity."""
    sso_id: Optional[str] = None
    mfa_enabled: bool = False
    password_hash: Optional[str] = None


@dataclass
class ServiceAccount(Identity):
    """Service account for machine-to-machine auth."""
    description: str = ""
    allowed_ips: List[str] = field(default_factory=list)
    api_key_ids: List[str] = field(default_factory=list)


class IdentityManager:
    """
    Manages identities for LLM systems.
    """

    def __init__(self, api_key_manager: APIKeyManager):
        self.identities: Dict[str, Identity] = {}
        self.api_key_manager = api_key_manager
        self.groups: Dict[str, Set[str]] = {}  # group_id -> set of identity_ids

    def create_user(
        self,
        display_name: str,
        email: str,
        organization_id: str,
        sso_id: Optional[str] = None,
        groups: Optional[List[str]] = None
    ) -> User:
        """Create a new user."""
        identity_id = f"user_{secrets.token_hex(16)}"

        user = User(
            identity_id=identity_id,
            identity_type=IdentityType.USER,
            display_name=display_name,
            email=email,
            organization_id=organization_id,
            sso_id=sso_id,
            groups=groups or []
        )

        self.identities[identity_id] = user

        # Add to groups
        for group_id in user.groups:
            if group_id not in self.groups:
                self.groups[group_id] = set()
            self.groups[group_id].add(identity_id)

        return user

    def create_service_account(
        self,
        display_name: str,
        organization_id: str,
        description: str = "",
        allowed_ips: Optional[List[str]] = None,
        scopes: Optional[List[str]] = None
    ) -> tuple[ServiceAccount, str]:
        """
        Create a service account with an API key.

        Returns: (ServiceAccount, api_key)
        """
        identity_id = f"sa_{secrets.token_hex(16)}"

        service_account = ServiceAccount(
            identity_id=identity_id,
            identity_type=IdentityType.SERVICE_ACCOUNT,
            display_name=display_name,
            email=None,
            organization_id=organization_id,
            description=description,
            allowed_ips=allowed_ips or []
        )

        self.identities[identity_id] = service_account

        # Create API key for service account
        api_key, key_metadata = self.api_key_manager.generate_key(
            name=f"Service Account: {display_name}",
            owner_id=identity_id,
            organization_id=organization_id,
            scopes=scopes or ["model:invoke", "rag:query"],
            allowed_ips=allowed_ips
        )

        service_account.api_key_ids.append(key_metadata.key_id)

        return service_account, api_key

    def get_identity(self, identity_id: str) -> Optional[Identity]:
        """Get an identity by ID."""
        return self.identities.get(identity_id)

    def get_identity_by_email(self, email: str) -> Optional[User]:
        """Get a user by email."""
        for identity in self.identities.values():
            if isinstance(identity, User) and identity.email == email:
                return identity
        return None

    def get_identity_by_sso(self, sso_id: str) -> Optional[User]:
        """Get a user by SSO ID."""
        for identity in self.identities.values():
            if isinstance(identity, User) and identity.sso_id == sso_id:
                return identity
        return None

    def update_status(
        self,
        identity_id: str,
        status: IdentityStatus,
        reason: str = ""
    ) -> bool:
        """Update identity status."""
        identity = self.identities.get(identity_id)
        if not identity:
            return False

        identity.status = status
        identity.metadata["status_reason"] = reason
        identity.metadata["status_updated"] = datetime.utcnow().isoformat()

        # Handle cascading actions
        if status in [IdentityStatus.SUSPENDED, IdentityStatus.DEACTIVATED]:
            self._revoke_identity_access(identity)

        return True

    def _revoke_identity_access(self, identity: Identity):
        """Revoke all access for an identity."""
        # Revoke API keys
        if isinstance(identity, ServiceAccount):
            for key_id in identity.api_key_ids:
                self.api_key_manager.revoke_key(key_id, "Identity deactivated")

    def add_to_group(self, identity_id: str, group_id: str) -> bool:
        """Add identity to a group."""
        identity = self.identities.get(identity_id)
        if not identity:
            return False

        if group_id not in self.groups:
            self.groups[group_id] = set()

        self.groups[group_id].add(identity_id)
        if group_id not in identity.groups:
            identity.groups.append(group_id)

        return True

    def remove_from_group(self, identity_id: str, group_id: str) -> bool:
        """Remove identity from a group."""
        identity = self.identities.get(identity_id)
        if not identity:
            return False

        if group_id in self.groups:
            self.groups[group_id].discard(identity_id)

        if group_id in identity.groups:
            identity.groups.remove(group_id)

        return True

    def get_group_members(self, group_id: str) -> List[Identity]:
        """Get all members of a group."""
        member_ids = self.groups.get(group_id, set())
        return [self.identities[m] for m in member_ids if m in self.identities]

    def list_identities(
        self,
        organization_id: Optional[str] = None,
        identity_type: Optional[IdentityType] = None,
        status: Optional[IdentityStatus] = None
    ) -> List[Dict]:
        """List identities with optional filters."""
        results = []

        for identity in self.identities.values():
            if organization_id and identity.organization_id != organization_id:
                continue
            if identity_type and identity.identity_type != identity_type:
                continue
            if status and identity.status != status:
                continue

            results.append({
                "identity_id": identity.identity_id,
                "identity_type": identity.identity_type.value,
                "display_name": identity.display_name,
                "email": identity.email,
                "organization_id": identity.organization_id,
                "status": identity.status.value,
                "groups": identity.groups,
                "created_at": identity.created_at.isoformat(),
                "last_active": identity.last_active.isoformat() if identity.last_active else None
            })

        return results
```

---

## 5. Audit & Monitoring

### 5.1 Access Audit Logging

```python
"""
Access audit logging for security and compliance.
"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum
import json
import hashlib


class AuditAction(Enum):
    """Auditable access actions."""
    AUTHENTICATE = "authenticate"
    AUTHENTICATE_FAILED = "authenticate_failed"
    AUTHORIZE = "authorize"
    AUTHORIZE_DENIED = "authorize_denied"
    API_KEY_CREATED = "api_key_created"
    API_KEY_REVOKED = "api_key_revoked"
    ROLE_ASSIGNED = "role_assigned"
    ROLE_REVOKED = "role_revoked"
    PERMISSION_GRANTED = "permission_granted"
    PERMISSION_DENIED = "permission_denied"
    TOKEN_ISSUED = "token_issued"
    TOKEN_REVOKED = "token_revoked"
    IDENTITY_CREATED = "identity_created"
    IDENTITY_MODIFIED = "identity_modified"
    IDENTITY_DEACTIVATED = "identity_deactivated"


@dataclass
class AccessAuditEntry:
    """Single access audit log entry."""
    entry_id: str
    timestamp: datetime
    action: AuditAction

    # Actor
    actor_id: Optional[str]
    actor_type: str  # "user", "service_account", "system"
    actor_ip: Optional[str]
    actor_user_agent: Optional[str]

    # Target
    target_type: str  # "model", "data", "api_key", "identity", etc.
    target_id: str

    # Action details
    action_details: Dict[str, Any]

    # Result
    success: bool
    error_message: Optional[str] = None

    # Context
    request_id: Optional[str] = None
    session_id: Optional[str] = None
    organization_id: Optional[str] = None

    # Integrity
    entry_hash: Optional[str] = None


class AccessAuditLogger:
    """
    Logs access-related audit events.
    """

    def __init__(self, storage_backend: Any = None):
        self.storage = storage_backend or []
        self.last_hash: Optional[str] = None

    def log(
        self,
        action: AuditAction,
        actor_id: Optional[str],
        actor_type: str,
        target_type: str,
        target_id: str,
        action_details: Dict[str, Any],
        success: bool,
        actor_ip: Optional[str] = None,
        actor_user_agent: Optional[str] = None,
        error_message: Optional[str] = None,
        request_id: Optional[str] = None,
        session_id: Optional[str] = None,
        organization_id: Optional[str] = None
    ) -> AccessAuditEntry:
        """Log an access audit event."""
        entry_id = f"audit_{datetime.utcnow().strftime('%Y%m%d%H%M%S%f')}"

        entry = AccessAuditEntry(
            entry_id=entry_id,
            timestamp=datetime.utcnow(),
            action=action,
            actor_id=actor_id,
            actor_type=actor_type,
            actor_ip=actor_ip,
            actor_user_agent=actor_user_agent,
            target_type=target_type,
            target_id=target_id,
            action_details=action_details,
            success=success,
            error_message=error_message,
            request_id=request_id,
            session_id=session_id,
            organization_id=organization_id
        )

        # Compute hash for integrity
        entry.entry_hash = self._compute_hash(entry, self.last_hash)
        self.last_hash = entry.entry_hash

        # Persist
        self._persist(entry)

        return entry

    def _compute_hash(self, entry: AccessAuditEntry, previous_hash: Optional[str]) -> str:
        """Compute integrity hash for entry."""
        data = {
            "entry_id": entry.entry_id,
            "timestamp": entry.timestamp.isoformat(),
            "action": entry.action.value,
            "actor_id": entry.actor_id,
            "target_id": entry.target_id,
            "success": entry.success,
            "previous_hash": previous_hash
        }
        return hashlib.sha256(json.dumps(data, sort_keys=True).encode()).hexdigest()

    def _persist(self, entry: AccessAuditEntry):
        """Persist audit entry to storage."""
        entry_dict = {
            "entry_id": entry.entry_id,
            "timestamp": entry.timestamp.isoformat(),
            "action": entry.action.value,
            "actor": {
                "id": entry.actor_id,
                "type": entry.actor_type,
                "ip": entry.actor_ip,
                "user_agent": entry.actor_user_agent
            },
            "target": {
                "type": entry.target_type,
                "id": entry.target_id
            },
            "details": entry.action_details,
            "result": {
                "success": entry.success,
                "error": entry.error_message
            },
            "context": {
                "request_id": entry.request_id,
                "session_id": entry.session_id,
                "organization_id": entry.organization_id
            },
            "integrity": {
                "hash": entry.entry_hash
            }
        }
        self.storage.append(entry_dict)

    def query(
        self,
        actor_id: Optional[str] = None,
        target_id: Optional[str] = None,
        action: Optional[AuditAction] = None,
        success: Optional[bool] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        organization_id: Optional[str] = None,
        limit: int = 100
    ) -> List[Dict]:
        """Query audit logs."""
        results = []

        for entry in reversed(self.storage):
            if actor_id and entry.get("actor", {}).get("id") != actor_id:
                continue
            if target_id and entry.get("target", {}).get("id") != target_id:
                continue
            if action and entry.get("action") != action.value:
                continue
            if success is not None and entry.get("result", {}).get("success") != success:
                continue
            if organization_id and entry.get("context", {}).get("organization_id") != organization_id:
                continue

            entry_time = datetime.fromisoformat(entry["timestamp"])
            if start_time and entry_time < start_time:
                continue
            if end_time and entry_time > end_time:
                continue

            results.append(entry)

            if len(results) >= limit:
                break

        return results

    def get_failed_auth_attempts(
        self,
        actor_ip: Optional[str] = None,
        time_window_minutes: int = 15
    ) -> List[Dict]:
        """Get recent failed authentication attempts."""
        start_time = datetime.utcnow() - timedelta(minutes=time_window_minutes)

        results = self.query(
            action=AuditAction.AUTHENTICATE_FAILED,
            success=False,
            start_time=start_time
        )

        if actor_ip:
            results = [r for r in results if r.get("actor", {}).get("ip") == actor_ip]

        return results


class AccessAnomalyDetector:
    """
    Detects anomalous access patterns.
    """

    def __init__(self, audit_logger: AccessAuditLogger):
        self.audit_logger = audit_logger
        self.thresholds = {
            "failed_auth_per_ip": 5,
            "failed_auth_per_user": 3,
            "requests_per_minute": 100,
            "unusual_time_access": True
        }

    def check_for_anomalies(
        self,
        actor_id: Optional[str],
        actor_ip: Optional[str]
    ) -> List[Dict]:
        """Check for access anomalies."""
        anomalies = []

        # Check for brute force attempts
        if actor_ip:
            failed_attempts = self.audit_logger.get_failed_auth_attempts(
                actor_ip=actor_ip,
                time_window_minutes=15
            )

            if len(failed_attempts) >= self.thresholds["failed_auth_per_ip"]:
                anomalies.append({
                    "type": "brute_force_ip",
                    "severity": "high",
                    "details": {
                        "ip": actor_ip,
                        "failed_attempts": len(failed_attempts),
                        "threshold": self.thresholds["failed_auth_per_ip"]
                    }
                })

        if actor_id:
            # Check for account compromise indicators
            recent_failures = self.audit_logger.query(
                actor_id=actor_id,
                action=AuditAction.AUTHENTICATE_FAILED,
                start_time=datetime.utcnow() - timedelta(hours=1)
            )

            if len(recent_failures) >= self.thresholds["failed_auth_per_user"]:
                anomalies.append({
                    "type": "potential_account_compromise",
                    "severity": "medium",
                    "details": {
                        "user_id": actor_id,
                        "failed_attempts": len(recent_failures)
                    }
                })

        return anomalies
```

---

## 6. Production Implementation

### 6.1 Complete Access Control System

```python
"""
Production-ready access control system.
"""

class LLMAccessControlSystem:
    """
    Complete access control system for LLM services.
    """

    def __init__(self, config: Dict):
        self.config = config

        # Initialize components
        self.api_key_manager = APIKeyManager()

        self.jwt_validator = JWTValidator(TokenValidationConfig(
            issuer=config["jwt"]["issuer"],
            audience=config["jwt"]["audience"],
            jwks_uri=config["jwt"].get("jwks_uri"),
            signing_key=config["jwt"].get("signing_key")
        ))

        self.rbac_manager = RBACManager()
        self.abac_engine = create_llm_access_policies()

        self.identity_manager = IdentityManager(self.api_key_manager)
        self.tenant_manager = TenantIsolationManager()

        self.access_control = MultiLayerAccessControl(
            self.api_key_manager,
            self.jwt_validator,
            self.rbac_manager,
            self.abac_engine
        )

        self.audit_logger = AccessAuditLogger()
        self.anomaly_detector = AccessAnomalyDetector(self.audit_logger)

    def authenticate_request(
        self,
        authorization: Optional[str],
        api_key: Optional[str],
        client_ip: Optional[str]
    ) -> tuple[bool, Optional[AccessContext], Optional[str]]:
        """Authenticate an incoming request."""
        success, context, error = self.access_control.authenticate(
            authorization, api_key, client_ip
        )

        # Log authentication attempt
        self.audit_logger.log(
            action=AuditAction.AUTHENTICATE if success else AuditAction.AUTHENTICATE_FAILED,
            actor_id=context.user_id if context else None,
            actor_type="user" if context else "unknown",
            target_type="api",
            target_id="authentication",
            action_details={
                "method": context.auth_method if context else "unknown"
            },
            success=success,
            actor_ip=client_ip,
            error_message=error
        )

        # Check for anomalies
        if not success:
            anomalies = self.anomaly_detector.check_for_anomalies(
                actor_id=None,
                actor_ip=client_ip
            )
            if anomalies:
                # Could trigger alerts or block IP
                pass

        return success, context, error

    def authorize_request(
        self,
        context: AccessContext,
        resource_type: str,
        resource_id: str,
        action: str,
        resource_attributes: Optional[Dict] = None
    ) -> AccessResult:
        """Authorize a request."""
        # Get tenant context
        tenant = self.tenant_manager.get_tenant_for_user(context.user_id)

        if tenant:
            # Check tenant-level access
            allowed, reason = self.tenant_manager.check_resource_access(
                tenant.tenant_id, resource_type, resource_id
            )
            if not allowed:
                return AccessResult(
                    decision=AccessDecision.DENY,
                    reason=reason,
                    context=context
                )

        # Run authorization
        result = self.access_control.authorize(
            context, resource_type, resource_id, action, resource_attributes
        )

        # Log authorization decision
        self.audit_logger.log(
            action=AuditAction.AUTHORIZE if result.decision == AccessDecision.ALLOW
                   else AuditAction.AUTHORIZE_DENIED,
            actor_id=context.user_id,
            actor_type="user",
            target_type=resource_type,
            target_id=resource_id,
            action_details={
                "action": action,
                "tenant_id": tenant.tenant_id if tenant else None
            },
            success=result.decision == AccessDecision.ALLOW,
            actor_ip=context.ip_address,
            error_message=result.reason if result.decision != AccessDecision.ALLOW else None,
            organization_id=context.organization_id
        )

        return result


# Example usage
def create_access_control_system() -> LLMAccessControlSystem:
    """Create a configured access control system."""
    config = {
        "jwt": {
            "issuer": "https://auth.example.com",
            "audience": "llm-api",
            "signing_key": "your-secret-key"
        }
    }

    system = LLMAccessControlSystem(config)

    # Create a tenant
    system.tenant_manager.create_tenant(
        tenant_id="acme-corp",
        name="Acme Corporation",
        isolation_level=IsolationLevel.NAMESPACE,
        max_requests_per_minute=5000,
        allowed_models=["gpt-4", "gpt-3.5-turbo"]
    )

    # Create a user
    user = system.identity_manager.create_user(
        display_name="John Developer",
        email="john@acme.com",
        organization_id="acme-corp",
        groups=["developers"]
    )

    # Assign to tenant
    system.tenant_manager.assign_user_to_tenant(user.identity_id, "acme-corp")

    # Assign roles
    system.rbac_manager.assign_role(
        user_id=user.identity_id,
        role_id="developer",
        assigned_by="admin"
    )

    return system
```

---

## Appendices

### Appendix A: RBAC Implementation Examples

```yaml
# Example RBAC configuration
roles:
  admin:
    permissions:
      - model:*
      - data:*
      - rag:*
      - user:*
      - org:*

  developer:
    permissions:
      - model:read
      - model:invoke
      - model:deploy
      - data:read
      - data:write
      - rag:query
      - rag:index

  user:
    permissions:
      - model:read
      - model:invoke
      - rag:query

  viewer:
    permissions:
      - model:read
      - data:read
      - audit:read
```

### Appendix B: OAuth2 Configuration

```yaml
# OAuth2 server configuration
oauth2:
  issuer: "https://auth.example.com"
  authorization_endpoint: "/oauth/authorize"
  token_endpoint: "/oauth/token"
  revocation_endpoint: "/oauth/revoke"

  supported_grant_types:
    - authorization_code
    - client_credentials
    - refresh_token

  access_token_lifetime: 3600
  refresh_token_lifetime: 2592000  # 30 days

  scopes:
    - model:read
    - model:invoke
    - model:deploy
    - rag:query
    - rag:index
    - data:read
    - data:write

  pkce_required: true
```

### Appendix C: Audit Logging Schema

```json
{
  "entry_id": "audit_20240115123456789",
  "timestamp": "2024-01-15T12:34:56.789Z",
  "action": "authorize",
  "actor": {
    "id": "user_abc123",
    "type": "user",
    "ip": "192.168.1.100",
    "user_agent": "Mozilla/5.0..."
  },
  "target": {
    "type": "model",
    "id": "gpt-4"
  },
  "details": {
    "action": "invoke",
    "tenant_id": "acme-corp",
    "scopes_checked": ["model:invoke"]
  },
  "result": {
    "success": true,
    "error": null
  },
  "context": {
    "request_id": "req_xyz789",
    "session_id": "sess_123",
    "organization_id": "acme-corp"
  },
  "integrity": {
    "hash": "a1b2c3..."
  }
}
```

### Appendix D: Access Review Procedures

```markdown
# Access Review Procedure

## Quarterly Access Review

### 1. Preparation
- [ ] Export current role assignments
- [ ] Export API key inventory
- [ ] Export service account list

### 2. Review Process
- [ ] Review all admin-level access
- [ ] Verify service account necessity
- [ ] Check for unused API keys (>90 days)
- [ ] Review cross-tenant access

### 3. Actions
- [ ] Revoke unnecessary access
- [ ] Rotate aging credentials
- [ ] Update documentation

### 4. Documentation
- [ ] Document review findings
- [ ] Record remediation actions
- [ ] Update access policies
```

---

## References

1. OWASP Authentication Cheat Sheet
2. OAuth 2.0 Security Best Current Practice (RFC 6819)
3. NIST SP 800-63B - Digital Identity Guidelines
4. OpenID Connect Core Specification
5. ABAC Guide (NIST SP 800-162)

---

> **Navigation**
> [← 11.4 Model Governance](11.4_model_governance_guide.md) | **[Index](../README.md#15-repository-structure)** | [12.1 Prompt Engineering →](../12_user_developer_experience/12.1_prompt_engineering_guide.md)
