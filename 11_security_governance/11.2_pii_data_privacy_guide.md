> **Navigation** | [← 11.1 Security](11.1_llm_security_guide.md) | [11.3 Compliance →](11.3_compliance_framework_guide.md)
>
> | | |
> |---|---|
> | **Prerequisites** | [11.1 Security](11.1_llm_security_guide.md) &#124; GDPR/CCPA/HIPAA &#124; NER |
> | **Related** | [11.3 Compliance](11.3_compliance_framework_guide.md) &#124; [1.2 Data Cleaning](../01_data_pipeline/1.2_data_cleaning_preprocessing.md) |
> | **Next** | [11.3 Compliance Framework](11.3_compliance_framework_guide.md) |

# Document 11.2: PII & Data Privacy Guide

## Purpose

This guide provides comprehensive strategies for protecting personally identifiable information (PII) in LLM systems, including detection, handling, regulatory compliance, and user rights management.

## Prerequisites

- Understanding of LLM input/output pipelines
- Familiarity with data privacy regulations (GDPR, CCPA, HIPAA)
- Knowledge of NER and text processing techniques
- Experience with compliance frameworks

## 11.2.1 PII Categories

### PII Classification Framework

```python
"""
PII classification and categorization for LLM systems.
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Set
from enum import Enum


class PIISensitivity(Enum):
    """Sensitivity levels for PII."""
    LOW = "low"           # Public or semi-public info
    MEDIUM = "medium"     # Identifying but not sensitive
    HIGH = "high"         # Sensitive personal data
    CRITICAL = "critical" # Highly sensitive (financial, health)


class PIICategory(Enum):
    """Categories of PII."""
    DIRECT_IDENTIFIER = "direct_identifier"
    QUASI_IDENTIFIER = "quasi_identifier"
    SENSITIVE = "sensitive"
    CONTEXT_DEPENDENT = "context_dependent"


@dataclass
class PIIType:
    """Definition of a PII type."""
    name: str
    category: PIICategory
    sensitivity: PIISensitivity
    description: str
    examples: List[str]
    patterns: List[str] = field(default_factory=list)
    requires_context: bool = False


class PIIRegistry:
    """
    Registry of PII types for detection and handling.
    """

    # Direct Identifiers - uniquely identify individuals
    DIRECT_IDENTIFIERS = [
        PIIType(
            name="ssn",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.CRITICAL,
            description="Social Security Number",
            examples=["123-45-6789", "123456789"],
            patterns=[
                r"\b\d{3}-\d{2}-\d{4}\b",
                r"\b\d{9}\b"  # Need context validation
            ]
        ),
        PIIType(
            name="email",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.MEDIUM,
            description="Email address",
            examples=["john.doe@example.com"],
            patterns=[
                r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"
            ]
        ),
        PIIType(
            name="phone",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.MEDIUM,
            description="Phone number",
            examples=["(555) 123-4567", "+1-555-123-4567"],
            patterns=[
                r"\b\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b",
                r"\b\+\d{1,3}[-.\s]?\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b"
            ]
        ),
        PIIType(
            name="drivers_license",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.HIGH,
            description="Driver's license number",
            examples=["D123-456-78-901"],
            patterns=[
                r"\b[A-Z]\d{3}[-\s]?\d{3}[-\s]?\d{2}[-\s]?\d{3}\b"
            ]
        ),
        PIIType(
            name="passport",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.HIGH,
            description="Passport number",
            examples=["AB1234567"],
            patterns=[
                r"\b[A-Z]{1,2}\d{6,9}\b"
            ]
        ),
        PIIType(
            name="national_id",
            category=PIICategory.DIRECT_IDENTIFIER,
            sensitivity=PIISensitivity.CRITICAL,
            description="National ID number",
            examples=["Various by country"],
            patterns=[]  # Country-specific
        ),
    ]

    # Quasi-Identifiers - can identify when combined
    QUASI_IDENTIFIERS = [
        PIIType(
            name="full_name",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.MEDIUM,
            description="Person's full name",
            examples=["John Smith", "Jane Doe"],
            patterns=[],  # Requires NER
            requires_context=True
        ),
        PIIType(
            name="date_of_birth",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.MEDIUM,
            description="Date of birth",
            examples=["01/15/1990", "January 15, 1990"],
            patterns=[
                r"\b\d{1,2}[/-]\d{1,2}[/-]\d{2,4}\b",
                r"\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},?\s+\d{4}\b"
            ],
            requires_context=True
        ),
        PIIType(
            name="address",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.MEDIUM,
            description="Physical address",
            examples=["123 Main St, Anytown, CA 12345"],
            patterns=[
                r"\b\d+\s+[\w\s]+\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr)\b"
            ],
            requires_context=True
        ),
        PIIType(
            name="zip_code",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.LOW,
            description="ZIP/Postal code",
            examples=["12345", "12345-6789"],
            patterns=[
                r"\b\d{5}(-\d{4})?\b"
            ]
        ),
        PIIType(
            name="gender",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.LOW,
            description="Gender identity",
            examples=["Male", "Female", "Non-binary"],
            patterns=[],
            requires_context=True
        ),
        PIIType(
            name="age",
            category=PIICategory.QUASI_IDENTIFIER,
            sensitivity=PIISensitivity.LOW,
            description="Age or age range",
            examples=["35 years old", "age 35"],
            patterns=[
                r"\b(\d{1,3})\s*(years?\s*old|y/?o)\b",
                r"\bage\s*:?\s*(\d{1,3})\b"
            ]
        ),
    ]

    # Sensitive PII - requires special protection
    SENSITIVE_PII = [
        PIIType(
            name="credit_card",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.CRITICAL,
            description="Credit card number",
            examples=["4111-1111-1111-1111"],
            patterns=[
                r"\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b",
                r"\b\d{16}\b"
            ]
        ),
        PIIType(
            name="bank_account",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.CRITICAL,
            description="Bank account number",
            examples=["1234567890"],
            patterns=[
                r"\b\d{8,17}\b"  # Needs context
            ],
            requires_context=True
        ),
        PIIType(
            name="health_info",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.CRITICAL,
            description="Protected health information (PHI)",
            examples=["Patient diagnosed with...", "Blood type: O+"],
            patterns=[],  # Requires NER/ML
            requires_context=True
        ),
        PIIType(
            name="medical_record",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.CRITICAL,
            description="Medical record number",
            examples=["MRN: 123456789"],
            patterns=[
                r"\bMRN\s*:?\s*\d{6,12}\b"
            ]
        ),
        PIIType(
            name="biometric",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.CRITICAL,
            description="Biometric data references",
            examples=["fingerprint", "facial recognition ID"],
            patterns=[],
            requires_context=True
        ),
        PIIType(
            name="race_ethnicity",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.HIGH,
            description="Race or ethnicity",
            examples=["Caucasian", "African American"],
            patterns=[],
            requires_context=True
        ),
        PIIType(
            name="religion",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.HIGH,
            description="Religious beliefs",
            examples=["Christian", "Muslim", "Jewish"],
            patterns=[],
            requires_context=True
        ),
        PIIType(
            name="sexual_orientation",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.HIGH,
            description="Sexual orientation",
            examples=["gay", "lesbian", "bisexual"],
            patterns=[],
            requires_context=True
        ),
        PIIType(
            name="political_affiliation",
            category=PIICategory.SENSITIVE,
            sensitivity=PIISensitivity.HIGH,
            description="Political opinions or affiliations",
            examples=["Democrat", "Republican"],
            patterns=[],
            requires_context=True
        ),
    ]

    # Context-Dependent PII
    CONTEXT_DEPENDENT = [
        PIIType(
            name="ip_address",
            category=PIICategory.CONTEXT_DEPENDENT,
            sensitivity=PIISensitivity.MEDIUM,
            description="IP address",
            examples=["192.168.1.1", "2001:db8::1"],
            patterns=[
                r"\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b",
                r"\b[0-9a-fA-F:]+:+[0-9a-fA-F:]+\b"
            ]
        ),
        PIIType(
            name="device_id",
            category=PIICategory.CONTEXT_DEPENDENT,
            sensitivity=PIISensitivity.MEDIUM,
            description="Device identifier",
            examples=["IMEI: 123456789012345"],
            patterns=[
                r"\bIMEI\s*:?\s*\d{15}\b"
            ]
        ),
        PIIType(
            name="username",
            category=PIICategory.CONTEXT_DEPENDENT,
            sensitivity=PIISensitivity.LOW,
            description="User account name",
            examples=["@johndoe", "user123"],
            patterns=[
                r"@[A-Za-z0-9_]+"
            ],
            requires_context=True
        ),
        PIIType(
            name="vehicle_id",
            category=PIICategory.CONTEXT_DEPENDENT,
            sensitivity=PIISensitivity.MEDIUM,
            description="Vehicle identification (VIN, plate)",
            examples=["VIN: 1HGBH41JXMN109186"],
            patterns=[
                r"\b[A-HJ-NPR-Z0-9]{17}\b",  # VIN
                r"\b[A-Z]{1,3}[-\s]?\d{1,4}[-\s]?[A-Z]{0,3}\b"  # Plates (varies)
            ]
        ),
    ]

    def __init__(self):
        self.all_types: Dict[str, PIIType] = {}
        self._register_all()

    def _register_all(self):
        """Register all PII types."""
        all_pii = (
            self.DIRECT_IDENTIFIERS +
            self.QUASI_IDENTIFIERS +
            self.SENSITIVE_PII +
            self.CONTEXT_DEPENDENT
        )
        for pii_type in all_pii:
            self.all_types[pii_type.name] = pii_type

    def get_by_sensitivity(self, sensitivity: PIISensitivity) -> List[PIIType]:
        """Get all PII types of a given sensitivity."""
        return [p for p in self.all_types.values() if p.sensitivity == sensitivity]

    def get_by_category(self, category: PIICategory) -> List[PIIType]:
        """Get all PII types in a category."""
        return [p for p in self.all_types.values() if p.category == category]

    def get_patterns_for_detection(self) -> Dict[str, List[str]]:
        """Get all regex patterns for PII detection."""
        return {
            name: pii_type.patterns
            for name, pii_type in self.all_types.items()
            if pii_type.patterns
        }
```

## 11.2.2 PII Detection

### Rule-Based Detection

```python
"""
Rule-based PII detection using regex patterns.
"""

import re
from dataclasses import dataclass
from typing import Dict, Any, List, Tuple, Optional


@dataclass
class PIIMatch:
    """A detected PII match."""
    pii_type: str
    value: str
    start: int
    end: int
    confidence: float
    sensitivity: str


class RuleBasedPIIDetector:
    """
    Rule-based PII detection using regex patterns.
    """

    def __init__(self, registry: PIIRegistry = None):
        self.registry = registry or PIIRegistry()
        self._compile_patterns()

    def _compile_patterns(self):
        """Compile regex patterns for efficiency."""
        self.compiled_patterns: Dict[str, List[re.Pattern]] = {}

        for pii_name, pii_type in self.registry.all_types.items():
            if pii_type.patterns:
                self.compiled_patterns[pii_name] = [
                    re.compile(pattern, re.IGNORECASE)
                    for pattern in pii_type.patterns
                ]

    def detect(self, text: str) -> List[PIIMatch]:
        """Detect PII in text."""
        matches = []

        for pii_name, patterns in self.compiled_patterns.items():
            pii_type = self.registry.all_types[pii_name]

            for pattern in patterns:
                for match in pattern.finditer(text):
                    # Validate match
                    value = match.group()
                    confidence = self._calculate_confidence(pii_name, value, text, match)

                    if confidence > 0.5:  # Threshold
                        matches.append(PIIMatch(
                            pii_type=pii_name,
                            value=value,
                            start=match.start(),
                            end=match.end(),
                            confidence=confidence,
                            sensitivity=pii_type.sensitivity.value
                        ))

        # Remove duplicates and overlapping matches
        return self._deduplicate_matches(matches)

    def _calculate_confidence(
        self,
        pii_name: str,
        value: str,
        context: str,
        match: re.Match
    ) -> float:
        """Calculate confidence score for a match."""
        confidence = 0.8  # Base confidence for pattern match

        # Apply validators
        if pii_name == "ssn":
            confidence *= self._validate_ssn(value)
        elif pii_name == "credit_card":
            confidence *= self._validate_credit_card(value)
        elif pii_name == "email":
            confidence *= self._validate_email(value)
        elif pii_name == "phone":
            confidence *= self._validate_phone(value, context, match)

        # Context-based adjustment
        context_keywords = self._get_context_keywords(pii_name)
        surrounding_text = context[max(0, match.start()-50):min(len(context), match.end()+50)]

        for keyword in context_keywords:
            if keyword.lower() in surrounding_text.lower():
                confidence = min(1.0, confidence + 0.1)

        return confidence

    def _validate_ssn(self, value: str) -> float:
        """Validate SSN format."""
        clean = value.replace("-", "").replace(" ", "")
        if len(clean) != 9:
            return 0.0

        # Invalid SSN patterns
        if clean.startswith("000") or clean.startswith("666"):
            return 0.0
        if clean[3:5] == "00" or clean[5:] == "0000":
            return 0.0

        return 1.0

    def _validate_credit_card(self, value: str) -> float:
        """Validate credit card using Luhn algorithm."""
        clean = value.replace("-", "").replace(" ", "")
        if not clean.isdigit() or len(clean) < 13 or len(clean) > 19:
            return 0.0

        # Luhn algorithm
        total = 0
        for i, digit in enumerate(reversed(clean)):
            d = int(digit)
            if i % 2 == 1:
                d *= 2
                if d > 9:
                    d -= 9
            total += d

        return 1.0 if total % 10 == 0 else 0.0

    def _validate_email(self, value: str) -> float:
        """Validate email format."""
        if "@" not in value or "." not in value.split("@")[-1]:
            return 0.0
        return 1.0

    def _validate_phone(
        self,
        value: str,
        context: str,
        match: re.Match
    ) -> float:
        """Validate phone number."""
        clean = re.sub(r"[^\d]", "", value)

        # Check length
        if len(clean) < 10 or len(clean) > 15:
            return 0.3

        # Check context for phone-related keywords
        phone_keywords = ["phone", "call", "tel", "mobile", "cell", "fax"]
        surrounding = context[max(0, match.start()-30):match.start()].lower()

        if any(kw in surrounding for kw in phone_keywords):
            return 1.0

        return 0.7

    def _get_context_keywords(self, pii_name: str) -> List[str]:
        """Get context keywords for PII type."""
        keywords = {
            "ssn": ["ssn", "social security", "social-security"],
            "email": ["email", "e-mail", "contact"],
            "phone": ["phone", "call", "tel", "mobile", "cell"],
            "credit_card": ["card", "credit", "debit", "payment"],
            "address": ["address", "street", "city", "state", "zip"],
            "date_of_birth": ["dob", "birth", "birthday", "born"],
        }
        return keywords.get(pii_name, [])

    def _deduplicate_matches(self, matches: List[PIIMatch]) -> List[PIIMatch]:
        """Remove duplicate and overlapping matches."""
        if not matches:
            return []

        # Sort by start position and confidence
        matches.sort(key=lambda m: (m.start, -m.confidence))

        result = []
        last_end = -1

        for match in matches:
            if match.start >= last_end:
                result.append(match)
                last_end = match.end
            elif match.confidence > result[-1].confidence:
                # Replace if higher confidence
                result[-1] = match
                last_end = match.end

        return result


class FormatValidator:
    """
    Validate specific PII formats.
    """

    @staticmethod
    def validate_ssn(value: str) -> Tuple[bool, str]:
        """Validate US Social Security Number."""
        clean = re.sub(r"[^0-9]", "", value)

        if len(clean) != 9:
            return False, "Invalid length"

        # Area number validation
        area = int(clean[:3])
        if area == 0 or area == 666 or area >= 900:
            return False, "Invalid area number"

        # Group number validation
        group = int(clean[3:5])
        if group == 0:
            return False, "Invalid group number"

        # Serial number validation
        serial = int(clean[5:])
        if serial == 0:
            return False, "Invalid serial number"

        return True, "Valid"

    @staticmethod
    def validate_credit_card(value: str) -> Tuple[bool, Dict[str, Any]]:
        """Validate credit card number."""
        clean = re.sub(r"[^0-9]", "", value)

        # Identify card type
        card_types = {
            "visa": r"^4[0-9]{12}(?:[0-9]{3})?$",
            "mastercard": r"^5[1-5][0-9]{14}$",
            "amex": r"^3[47][0-9]{13}$",
            "discover": r"^6(?:011|5[0-9]{2})[0-9]{12}$"
        }

        card_type = None
        for name, pattern in card_types.items():
            if re.match(pattern, clean):
                card_type = name
                break

        # Luhn validation
        is_valid_luhn = FormatValidator._luhn_check(clean)

        return is_valid_luhn, {
            "card_type": card_type,
            "length": len(clean),
            "luhn_valid": is_valid_luhn
        }

    @staticmethod
    def _luhn_check(number: str) -> bool:
        """Luhn algorithm check."""
        total = 0
        for i, digit in enumerate(reversed(number)):
            d = int(digit)
            if i % 2 == 1:
                d *= 2
                if d > 9:
                    d -= 9
            total += d
        return total % 10 == 0

    @staticmethod
    def validate_email(value: str) -> Tuple[bool, str]:
        """Validate email format."""
        pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if re.match(pattern, value):
            return True, "Valid format"
        return False, "Invalid format"

    @staticmethod
    def validate_phone(value: str, country: str = "US") -> Tuple[bool, Dict[str, Any]]:
        """Validate phone number."""
        clean = re.sub(r"[^0-9+]", "", value)

        if country == "US":
            # Remove country code if present
            if clean.startswith("+1"):
                clean = clean[2:]
            elif clean.startswith("1") and len(clean) == 11:
                clean = clean[1:]

            if len(clean) == 10:
                return True, {"format": "valid", "type": "US"}

        return False, {"format": "invalid", "provided": value}
```

### ML-Based Detection

```python
"""
ML-based PII detection using NER models.
"""

from dataclasses import dataclass
from typing import Dict, Any, List, Optional, Tuple
from abc import ABC, abstractmethod


@dataclass
class NEREntity:
    """Named entity recognized by NER model."""
    text: str
    label: str
    start: int
    end: int
    confidence: float


class PIIDetectorBase(ABC):
    """Base class for PII detectors."""

    @abstractmethod
    def detect(self, text: str) -> List[PIIMatch]:
        """Detect PII in text."""
        pass


class PresidioPIIDetector(PIIDetectorBase):
    """
    PII detection using Microsoft Presidio.
    """

    # Mapping from Presidio entities to our PII types
    ENTITY_MAPPING = {
        "PERSON": "full_name",
        "EMAIL_ADDRESS": "email",
        "PHONE_NUMBER": "phone",
        "US_SSN": "ssn",
        "CREDIT_CARD": "credit_card",
        "US_DRIVER_LICENSE": "drivers_license",
        "US_PASSPORT": "passport",
        "DATE_TIME": "date_of_birth",
        "LOCATION": "address",
        "IP_ADDRESS": "ip_address",
        "IBAN_CODE": "bank_account",
        "MEDICAL_LICENSE": "medical_record",
        "NRP": "national_id",  # National Registration number
    }

    def __init__(
        self,
        languages: List[str] = None,
        entities_to_detect: List[str] = None,
        score_threshold: float = 0.5
    ):
        self.languages = languages or ["en"]
        self.entities_to_detect = entities_to_detect
        self.score_threshold = score_threshold

        self._setup_presidio()

    def _setup_presidio(self):
        """Set up Presidio analyzer."""
        try:
            from presidio_analyzer import AnalyzerEngine
            from presidio_analyzer.nlp_engine import NlpEngineProvider

            # Create NLP engine
            provider = NlpEngineProvider(nlp_configuration={
                "nlp_engine_name": "spacy",
                "models": [{"lang_code": lang, "model_name": f"{lang}_core_web_lg"}
                          for lang in self.languages]
            })

            self.analyzer = AnalyzerEngine(
                nlp_engine=provider.create_engine(),
                supported_languages=self.languages
            )
        except ImportError:
            raise ImportError("Presidio not installed. Run: pip install presidio-analyzer presidio-anonymizer")

    def detect(self, text: str) -> List[PIIMatch]:
        """Detect PII using Presidio."""
        results = self.analyzer.analyze(
            text=text,
            language=self.languages[0],
            entities=self.entities_to_detect,
            score_threshold=self.score_threshold
        )

        matches = []
        for result in results:
            pii_type = self.ENTITY_MAPPING.get(result.entity_type, result.entity_type.lower())

            matches.append(PIIMatch(
                pii_type=pii_type,
                value=text[result.start:result.end],
                start=result.start,
                end=result.end,
                confidence=result.score,
                sensitivity=self._get_sensitivity(pii_type)
            ))

        return matches

    def _get_sensitivity(self, pii_type: str) -> str:
        """Get sensitivity level for PII type."""
        high_sensitivity = {"ssn", "credit_card", "bank_account", "health_info", "medical_record"}
        medium_sensitivity = {"email", "phone", "address", "drivers_license", "passport"}

        if pii_type in high_sensitivity:
            return "critical"
        elif pii_type in medium_sensitivity:
            return "medium"
        return "low"


class TransformerPIIDetector(PIIDetectorBase):
    """
    PII detection using transformer-based NER models.
    """

    def __init__(
        self,
        model_name: str = "dslim/bert-base-NER",
        device: str = "cpu"
    ):
        self.model_name = model_name
        self.device = device
        self._load_model()

    def _load_model(self):
        """Load transformer NER model."""
        try:
            from transformers import pipeline
            self.ner_pipeline = pipeline(
                "ner",
                model=self.model_name,
                device=0 if self.device == "cuda" else -1,
                aggregation_strategy="simple"
            )
        except ImportError:
            raise ImportError("Transformers not installed. Run: pip install transformers")

    def detect(self, text: str) -> List[PIIMatch]:
        """Detect PII using transformer NER."""
        entities = self.ner_pipeline(text)

        matches = []
        for entity in entities:
            pii_type = self._map_entity_type(entity["entity_group"])

            if pii_type:
                matches.append(PIIMatch(
                    pii_type=pii_type,
                    value=entity["word"],
                    start=entity["start"],
                    end=entity["end"],
                    confidence=entity["score"],
                    sensitivity=self._get_sensitivity(pii_type)
                ))

        return matches

    def _map_entity_type(self, entity_type: str) -> Optional[str]:
        """Map NER entity type to PII type."""
        mapping = {
            "PER": "full_name",
            "PERSON": "full_name",
            "LOC": "address",
            "LOCATION": "address",
            "ORG": None,  # Not PII
            "MISC": None,
        }
        return mapping.get(entity_type.upper())

    def _get_sensitivity(self, pii_type: str) -> str:
        """Get sensitivity level for PII type."""
        return "medium"  # Default for NER-detected entities


class HybridPIIDetector(PIIDetectorBase):
    """
    Hybrid PII detector combining rule-based and ML approaches.
    """

    def __init__(
        self,
        use_rules: bool = True,
        use_presidio: bool = True,
        use_transformer: bool = False,
        confidence_threshold: float = 0.5
    ):
        self.detectors: List[PIIDetectorBase] = []
        self.confidence_threshold = confidence_threshold

        if use_rules:
            self.detectors.append(RuleBasedPIIDetector())

        if use_presidio:
            try:
                self.detectors.append(PresidioPIIDetector())
            except ImportError:
                pass

        if use_transformer:
            try:
                self.detectors.append(TransformerPIIDetector())
            except ImportError:
                pass

    def detect(self, text: str) -> List[PIIMatch]:
        """Detect PII using all configured detectors."""
        all_matches = []

        for detector in self.detectors:
            matches = detector.detect(text)
            all_matches.extend(matches)

        # Merge and deduplicate
        merged = self._merge_matches(all_matches)

        # Filter by threshold
        return [m for m in merged if m.confidence >= self.confidence_threshold]

    def _merge_matches(self, matches: List[PIIMatch]) -> List[PIIMatch]:
        """Merge matches from multiple detectors."""
        if not matches:
            return []

        # Group by position
        position_groups: Dict[Tuple[int, int], List[PIIMatch]] = {}
        for match in matches:
            key = (match.start, match.end)
            if key not in position_groups:
                position_groups[key] = []
            position_groups[key].append(match)

        # Select best match for each position
        result = []
        for position, group in position_groups.items():
            # Choose highest confidence match
            best = max(group, key=lambda m: m.confidence)

            # Boost confidence if multiple detectors agree
            if len(group) > 1:
                best.confidence = min(1.0, best.confidence + 0.1 * (len(group) - 1))

            result.append(best)

        return result
```

## 11.2.3 PII Handling Strategies

### Redaction, Masking, and Anonymization

```python
"""
PII handling strategies: redaction, masking, anonymization, pseudonymization.
"""

from dataclasses import dataclass
from typing import Dict, Any, List, Optional, Callable
from enum import Enum
from abc import ABC, abstractmethod
import hashlib
import secrets
import re


class PIIHandlingStrategy(Enum):
    """Strategies for handling detected PII."""
    REDACT = "redact"           # Complete removal
    MASK = "mask"               # Partial hiding
    ANONYMIZE = "anonymize"     # Irreversible transformation
    PSEUDONYMIZE = "pseudonymize"  # Reversible with key
    BLOCK = "block"             # Prevent processing
    HASH = "hash"               # One-way hash


@dataclass
class PIIHandlingConfig:
    """Configuration for PII handling."""
    default_strategy: PIIHandlingStrategy = PIIHandlingStrategy.REDACT
    type_strategies: Dict[str, PIIHandlingStrategy] = None
    redaction_placeholder: str = "[REDACTED]"
    mask_character: str = "*"
    mask_preserve_length: bool = True
    hash_algorithm: str = "sha256"
    hash_salt: Optional[str] = None


class PIIHandler(ABC):
    """Base class for PII handlers."""

    @abstractmethod
    def handle(self, value: str, pii_type: str) -> str:
        """Handle PII value."""
        pass


class RedactionHandler(PIIHandler):
    """Complete removal of PII."""

    def __init__(self, placeholder: str = "[REDACTED]"):
        self.placeholder = placeholder
        self.type_placeholders = {
            "email": "[EMAIL]",
            "phone": "[PHONE]",
            "ssn": "[SSN]",
            "credit_card": "[CREDIT_CARD]",
            "address": "[ADDRESS]",
            "full_name": "[NAME]",
        }

    def handle(self, value: str, pii_type: str) -> str:
        """Redact PII with placeholder."""
        return self.type_placeholders.get(pii_type, self.placeholder)


class MaskingHandler(PIIHandler):
    """Partial hiding of PII."""

    def __init__(
        self,
        mask_char: str = "*",
        preserve_length: bool = True
    ):
        self.mask_char = mask_char
        self.preserve_length = preserve_length

    def handle(self, value: str, pii_type: str) -> str:
        """Mask PII value."""
        # Type-specific masking
        if pii_type == "email":
            return self._mask_email(value)
        elif pii_type == "credit_card":
            return self._mask_credit_card(value)
        elif pii_type == "ssn":
            return self._mask_ssn(value)
        elif pii_type == "phone":
            return self._mask_phone(value)
        else:
            return self._default_mask(value)

    def _mask_email(self, email: str) -> str:
        """Mask email: j***@e***.com"""
        parts = email.split("@")
        if len(parts) != 2:
            return self._default_mask(email)

        local = parts[0]
        domain = parts[1]

        masked_local = local[0] + self.mask_char * 3 if local else self.mask_char * 4
        domain_parts = domain.split(".")
        masked_domain = domain_parts[0][0] + self.mask_char * 3 + "." + domain_parts[-1]

        return f"{masked_local}@{masked_domain}"

    def _mask_credit_card(self, card: str) -> str:
        """Mask credit card: ****-****-****-1234"""
        clean = re.sub(r"[^0-9]", "", card)
        if len(clean) >= 4:
            return f"{'*' * 4}-{'*' * 4}-{'*' * 4}-{clean[-4:]}"
        return self.mask_char * len(card)

    def _mask_ssn(self, ssn: str) -> str:
        """Mask SSN: ***-**-1234"""
        clean = re.sub(r"[^0-9]", "", ssn)
        if len(clean) == 9:
            return f"***-**-{clean[-4:]}"
        return self.mask_char * len(ssn)

    def _mask_phone(self, phone: str) -> str:
        """Mask phone: (***) ***-1234"""
        digits = re.sub(r"[^0-9]", "", phone)
        if len(digits) >= 4:
            return f"(***) ***-{digits[-4:]}"
        return self.mask_char * len(phone)

    def _default_mask(self, value: str) -> str:
        """Default masking: show first and last character."""
        if len(value) <= 2:
            return self.mask_char * len(value)

        if self.preserve_length:
            return value[0] + self.mask_char * (len(value) - 2) + value[-1]
        else:
            return value[0] + self.mask_char * 3 + value[-1]


class AnonymizationHandler(PIIHandler):
    """Irreversible anonymization of PII."""

    def __init__(self, hash_algorithm: str = "sha256"):
        self.hash_algorithm = hash_algorithm

    def handle(self, value: str, pii_type: str) -> str:
        """Anonymize PII irreversibly."""
        # Type-specific anonymization
        if pii_type == "email":
            return self._anonymize_email(value)
        elif pii_type == "full_name":
            return self._anonymize_name(value)
        elif pii_type == "address":
            return self._generalize_address(value)
        else:
            return self._hash_value(value)

    def _hash_value(self, value: str) -> str:
        """Create irreversible hash."""
        h = hashlib.new(self.hash_algorithm)
        h.update(value.encode())
        return f"ANON_{h.hexdigest()[:16]}"

    def _anonymize_email(self, email: str) -> str:
        """Generate anonymous email identifier."""
        return self._hash_value(email.lower())

    def _anonymize_name(self, name: str) -> str:
        """Generate anonymous name reference."""
        return f"Person_{self._hash_value(name.lower())[:8]}"

    def _generalize_address(self, address: str) -> str:
        """Generalize address (e.g., city/state only)."""
        # Simple implementation - in practice use address parsing
        return "[LOCATION]"


class PseudonymizationHandler(PIIHandler):
    """Reversible pseudonymization of PII."""

    def __init__(self, secret_key: bytes = None):
        self.secret_key = secret_key or secrets.token_bytes(32)
        self.mapping: Dict[str, str] = {}
        self.reverse_mapping: Dict[str, str] = {}

    def handle(self, value: str, pii_type: str) -> str:
        """Pseudonymize PII (reversible with key)."""
        # Check if already pseudonymized
        if value in self.mapping:
            return self.mapping[value]

        # Generate pseudonym
        pseudonym = self._generate_pseudonym(value, pii_type)

        # Store mapping
        self.mapping[value] = pseudonym
        self.reverse_mapping[pseudonym] = value

        return pseudonym

    def reverse(self, pseudonym: str) -> Optional[str]:
        """Reverse pseudonymization to get original value."""
        return self.reverse_mapping.get(pseudonym)

    def _generate_pseudonym(self, value: str, pii_type: str) -> str:
        """Generate deterministic pseudonym."""
        import hmac

        # Create HMAC for deterministic but secure pseudonym
        h = hmac.new(self.secret_key, value.encode(), hashlib.sha256)
        pseudo_id = h.hexdigest()[:12]

        # Type-specific format
        prefixes = {
            "email": "email",
            "full_name": "person",
            "phone": "phone",
            "ssn": "id",
        }
        prefix = prefixes.get(pii_type, "data")

        return f"{prefix}_{pseudo_id}"


class PIIProcessor:
    """
    Process text to handle PII according to configuration.
    """

    def __init__(
        self,
        detector: PIIDetectorBase,
        config: PIIHandlingConfig = None
    ):
        self.detector = detector
        self.config = config or PIIHandlingConfig()

        # Initialize handlers
        self.handlers: Dict[PIIHandlingStrategy, PIIHandler] = {
            PIIHandlingStrategy.REDACT: RedactionHandler(config.redaction_placeholder if config else "[REDACTED]"),
            PIIHandlingStrategy.MASK: MaskingHandler(),
            PIIHandlingStrategy.ANONYMIZE: AnonymizationHandler(),
            PIIHandlingStrategy.PSEUDONYMIZE: PseudonymizationHandler(),
        }

    def process(self, text: str) -> Dict[str, Any]:
        """Process text and handle detected PII."""
        # Detect PII
        matches = self.detector.detect(text)

        if not matches:
            return {
                "original_length": len(text),
                "processed_text": text,
                "pii_found": False,
                "pii_count": 0,
                "modifications": []
            }

        # Sort matches by position (reverse for replacement)
        matches.sort(key=lambda m: m.start, reverse=True)

        # Process each match
        processed_text = text
        modifications = []

        for match in matches:
            # Determine strategy
            strategy = self._get_strategy(match.pii_type)

            if strategy == PIIHandlingStrategy.BLOCK:
                return {
                    "blocked": True,
                    "reason": f"Blocked due to {match.pii_type}",
                    "pii_type": match.pii_type
                }

            # Apply handler
            handler = self.handlers.get(strategy)
            if handler:
                replacement = handler.handle(match.value, match.pii_type)
                processed_text = (
                    processed_text[:match.start] +
                    replacement +
                    processed_text[match.end:]
                )

                modifications.append({
                    "pii_type": match.pii_type,
                    "strategy": strategy.value,
                    "original_length": len(match.value),
                    "replacement_length": len(replacement)
                })

        return {
            "original_length": len(text),
            "processed_text": processed_text,
            "pii_found": True,
            "pii_count": len(matches),
            "modifications": modifications
        }

    def _get_strategy(self, pii_type: str) -> PIIHandlingStrategy:
        """Get handling strategy for PII type."""
        if self.config.type_strategies and pii_type in self.config.type_strategies:
            return self.config.type_strategies[pii_type]
        return self.config.default_strategy
```

## 11.2.4 Implementation Patterns

### Pre-processing and Post-processing Pipelines

```python
"""
PII handling pipeline implementations.
"""

from dataclasses import dataclass
from typing import Dict, Any, List, Optional, Callable
from datetime import datetime
import asyncio


@dataclass
class PipelineResult:
    """Result from PII pipeline processing."""
    original_text: str
    processed_text: str
    pii_detected: List[PIIMatch]
    actions_taken: List[Dict[str, Any]]
    processing_time_ms: float
    blocked: bool = False
    block_reason: Optional[str] = None


class PIIPipeline:
    """
    PII handling pipeline for LLM systems.
    """

    def __init__(
        self,
        detector: PIIDetectorBase,
        processor: PIIProcessor,
        pre_hooks: List[Callable] = None,
        post_hooks: List[Callable] = None
    ):
        self.detector = detector
        self.processor = processor
        self.pre_hooks = pre_hooks or []
        self.post_hooks = post_hooks or []

    async def process_input(self, text: str, context: Dict[str, Any] = None) -> PipelineResult:
        """Process input text for PII before sending to LLM."""
        import time
        start_time = time.perf_counter()

        # Run pre-hooks
        for hook in self.pre_hooks:
            text = await self._run_hook(hook, text, context)

        # Detect PII
        matches = self.detector.detect(text)

        # Process PII
        result = self.processor.process(text)

        # Check for blocking
        if result.get("blocked"):
            return PipelineResult(
                original_text=text,
                processed_text="",
                pii_detected=matches,
                actions_taken=[{"action": "blocked", "reason": result.get("reason")}],
                processing_time_ms=(time.perf_counter() - start_time) * 1000,
                blocked=True,
                block_reason=result.get("reason")
            )

        processed_text = result.get("processed_text", text)

        # Run post-hooks
        for hook in self.post_hooks:
            processed_text = await self._run_hook(hook, processed_text, context)

        return PipelineResult(
            original_text=text,
            processed_text=processed_text,
            pii_detected=matches,
            actions_taken=result.get("modifications", []),
            processing_time_ms=(time.perf_counter() - start_time) * 1000
        )

    async def process_output(self, text: str, context: Dict[str, Any] = None) -> PipelineResult:
        """Process LLM output for PII before returning to user."""
        import time
        start_time = time.perf_counter()

        # Detect PII in output
        matches = self.detector.detect(text)

        # Log if PII found in output (potential leak)
        if matches:
            await self._log_pii_in_output(matches, context)

        # Process to remove any PII
        result = self.processor.process(text)

        return PipelineResult(
            original_text=text,
            processed_text=result.get("processed_text", text),
            pii_detected=matches,
            actions_taken=result.get("modifications", []),
            processing_time_ms=(time.perf_counter() - start_time) * 1000
        )

    async def _run_hook(
        self,
        hook: Callable,
        text: str,
        context: Dict[str, Any]
    ) -> str:
        """Run a pipeline hook."""
        if asyncio.iscoroutinefunction(hook):
            return await hook(text, context)
        return hook(text, context)

    async def _log_pii_in_output(
        self,
        matches: List[PIIMatch],
        context: Dict[str, Any]
    ):
        """Log PII detected in LLM output."""
        # This indicates potential data leakage
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event": "pii_in_output",
            "pii_types": [m.pii_type for m in matches],
            "count": len(matches),
            "context": context
        }
        # Would send to logging/alerting system
        print(f"WARNING: PII in output: {log_entry}")


class RealTimePIIFilter:
    """
    Real-time PII filtering for streaming responses.
    """

    def __init__(
        self,
        detector: PIIDetectorBase,
        buffer_size: int = 100
    ):
        self.detector = detector
        self.buffer_size = buffer_size
        self._buffer = ""

    def process_chunk(self, chunk: str) -> str:
        """Process a streaming chunk for PII."""
        # Add to buffer
        self._buffer += chunk

        # If buffer is large enough, process
        if len(self._buffer) >= self.buffer_size:
            # Process buffer
            matches = self.detector.detect(self._buffer)

            if matches:
                # Redact PII in buffer
                processor = PIIProcessor(
                    self.detector,
                    PIIHandlingConfig(default_strategy=PIIHandlingStrategy.REDACT)
                )
                result = processor.process(self._buffer)
                processed = result.get("processed_text", self._buffer)

                # Return processed content and keep remainder
                output = processed[:-self.buffer_size//2]
                self._buffer = processed[-self.buffer_size//2:]
                return output
            else:
                # No PII, return most of buffer
                output = self._buffer[:-self.buffer_size//2]
                self._buffer = self._buffer[-self.buffer_size//2:]
                return output

        return ""  # Wait for more data

    def flush(self) -> str:
        """Flush remaining buffer."""
        if self._buffer:
            matches = self.detector.detect(self._buffer)
            if matches:
                processor = PIIProcessor(
                    self.detector,
                    PIIHandlingConfig(default_strategy=PIIHandlingStrategy.REDACT)
                )
                result = processor.process(self._buffer)
                output = result.get("processed_text", self._buffer)
            else:
                output = self._buffer

            self._buffer = ""
            return output
        return ""
```

## 11.2.5 Regulatory Compliance

### GDPR, CCPA, and HIPAA Requirements

```python
"""
Regulatory compliance frameworks for PII handling.
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional
from enum import Enum
from datetime import datetime, timedelta


class Regulation(Enum):
    """Supported regulations."""
    GDPR = "gdpr"
    CCPA = "ccpa"
    HIPAA = "hipaa"
    SOC2 = "soc2"


@dataclass
class ComplianceRequirement:
    """A specific compliance requirement."""
    regulation: Regulation
    requirement_id: str
    description: str
    controls: List[str]
    evidence_needed: List[str]


class ComplianceChecker:
    """
    Check and enforce regulatory compliance for PII handling.
    """

    GDPR_REQUIREMENTS = [
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-6",
            description="Lawful basis for processing",
            controls=["consent_tracking", "legitimate_interest_assessment"],
            evidence_needed=["consent_records", "lia_documentation"]
        ),
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-17",
            description="Right to erasure (right to be forgotten)",
            controls=["data_deletion_capability", "deletion_verification"],
            evidence_needed=["deletion_logs", "backup_purge_records"]
        ),
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-20",
            description="Right to data portability",
            controls=["data_export_capability", "machine_readable_format"],
            evidence_needed=["export_logs", "format_specifications"]
        ),
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-25",
            description="Data protection by design and default",
            controls=["privacy_by_design", "data_minimization"],
            evidence_needed=["design_documentation", "pii_inventory"]
        ),
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-32",
            description="Security of processing",
            controls=["encryption", "access_control", "audit_logging"],
            evidence_needed=["security_assessments", "penetration_test_reports"]
        ),
        ComplianceRequirement(
            regulation=Regulation.GDPR,
            requirement_id="GDPR-33",
            description="Notification of breach within 72 hours",
            controls=["breach_detection", "notification_process"],
            evidence_needed=["incident_response_plan", "notification_templates"]
        ),
    ]

    CCPA_REQUIREMENTS = [
        ComplianceRequirement(
            regulation=Regulation.CCPA,
            requirement_id="CCPA-1798.100",
            description="Right to know what personal information is collected",
            controls=["data_inventory", "transparency_notice"],
            evidence_needed=["privacy_policy", "data_catalog"]
        ),
        ComplianceRequirement(
            regulation=Regulation.CCPA,
            requirement_id="CCPA-1798.105",
            description="Right to delete personal information",
            controls=["deletion_capability", "service_provider_deletion"],
            evidence_needed=["deletion_process_docs", "vendor_agreements"]
        ),
        ComplianceRequirement(
            regulation=Regulation.CCPA,
            requirement_id="CCPA-1798.110",
            description="Right to data portability",
            controls=["data_export", "electronic_format"],
            evidence_needed=["export_capability_docs"]
        ),
        ComplianceRequirement(
            regulation=Regulation.CCPA,
            requirement_id="CCPA-1798.120",
            description="Right to opt-out of sale",
            controls=["opt_out_mechanism", "do_not_sell_link"],
            evidence_needed=["opt_out_records", "website_implementation"]
        ),
    ]

    HIPAA_REQUIREMENTS = [
        ComplianceRequirement(
            regulation=Regulation.HIPAA,
            requirement_id="HIPAA-164.312",
            description="Technical safeguards for PHI",
            controls=["access_control", "audit_controls", "transmission_security"],
            evidence_needed=["access_logs", "encryption_records"]
        ),
        ComplianceRequirement(
            regulation=Regulation.HIPAA,
            requirement_id="HIPAA-164.502",
            description="Minimum necessary standard",
            controls=["role_based_access", "data_minimization"],
            evidence_needed=["access_policies", "role_definitions"]
        ),
        ComplianceRequirement(
            regulation=Regulation.HIPAA,
            requirement_id="HIPAA-164.514",
            description="De-identification standards",
            controls=["safe_harbor_method", "expert_determination"],
            evidence_needed=["de_identification_procedures"]
        ),
    ]

    def __init__(self, applicable_regulations: List[Regulation]):
        self.regulations = applicable_regulations
        self.requirements = self._get_applicable_requirements()

    def _get_applicable_requirements(self) -> List[ComplianceRequirement]:
        """Get all applicable requirements."""
        all_requirements = []

        if Regulation.GDPR in self.regulations:
            all_requirements.extend(self.GDPR_REQUIREMENTS)
        if Regulation.CCPA in self.regulations:
            all_requirements.extend(self.CCPA_REQUIREMENTS)
        if Regulation.HIPAA in self.regulations:
            all_requirements.extend(self.HIPAA_REQUIREMENTS)

        return all_requirements

    def check_compliance(
        self,
        implemented_controls: List[str],
        available_evidence: List[str]
    ) -> Dict[str, Any]:
        """Check compliance against requirements."""
        results = []

        for req in self.requirements:
            # Check controls
            missing_controls = [c for c in req.controls if c not in implemented_controls]

            # Check evidence
            missing_evidence = [e for e in req.evidence_needed if e not in available_evidence]

            compliant = len(missing_controls) == 0 and len(missing_evidence) == 0

            results.append({
                "requirement_id": req.requirement_id,
                "regulation": req.regulation.value,
                "description": req.description,
                "compliant": compliant,
                "missing_controls": missing_controls,
                "missing_evidence": missing_evidence
            })

        # Summary
        compliant_count = sum(1 for r in results if r["compliant"])

        return {
            "total_requirements": len(results),
            "compliant": compliant_count,
            "non_compliant": len(results) - compliant_count,
            "compliance_percentage": (compliant_count / len(results) * 100) if results else 100,
            "details": results
        }


class DataRetentionManager:
    """
    Manage data retention according to regulatory requirements.
    """

    def __init__(self, retention_policies: Dict[str, int] = None):
        """
        Initialize with retention policies.

        retention_policies: Dict mapping data type to retention days
        """
        self.policies = retention_policies or {
            "request_logs": 90,
            "pii_data": 30,
            "audit_logs": 365,
            "training_data": 730,
        }

    def get_retention_period(self, data_type: str) -> int:
        """Get retention period in days for data type."""
        return self.policies.get(data_type, 90)  # Default 90 days

    def is_expired(self, data_type: str, created_at: datetime) -> bool:
        """Check if data should be deleted based on retention policy."""
        retention_days = self.get_retention_period(data_type)
        expiry_date = created_at + timedelta(days=retention_days)
        return datetime.utcnow() > expiry_date

    def get_deletion_candidates(
        self,
        data_records: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Get records that should be deleted."""
        candidates = []

        for record in data_records:
            data_type = record.get("type", "default")
            created_at = record.get("created_at")

            if created_at and self.is_expired(data_type, created_at):
                candidates.append(record)

        return candidates
```

## 11.2.6 User Rights

### Data Subject Rights Implementation

```python
"""
Implementation of data subject rights (GDPR/CCPA).
"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from enum import Enum
import uuid
import json


class RightType(Enum):
    """Types of data subject rights."""
    ACCESS = "access"           # Right to access data
    RECTIFICATION = "rectification"  # Right to correct data
    ERASURE = "erasure"         # Right to deletion
    PORTABILITY = "portability"  # Right to data portability
    RESTRICTION = "restriction"  # Right to restrict processing
    OBJECTION = "objection"     # Right to object


@dataclass
class DataSubjectRequest:
    """A data subject rights request."""
    request_id: str
    user_id: str
    right_type: RightType
    submitted_at: datetime
    due_date: datetime
    status: str  # pending, in_progress, completed, rejected
    verification_status: str  # pending, verified, failed
    notes: List[str] = field(default_factory=list)
    completed_at: Optional[datetime] = None


class DataSubjectRightsManager:
    """
    Manage data subject rights requests.
    """

    # Response deadlines by regulation (days)
    DEADLINES = {
        "gdpr": 30,
        "ccpa": 45,
    }

    def __init__(self, regulation: str = "gdpr"):
        self.regulation = regulation
        self.requests: Dict[str, DataSubjectRequest] = {}
        self.deadline_days = self.DEADLINES.get(regulation, 30)

    def submit_request(
        self,
        user_id: str,
        right_type: RightType,
        details: Dict[str, Any] = None
    ) -> DataSubjectRequest:
        """Submit a new data subject request."""
        request_id = str(uuid.uuid4())
        submitted_at = datetime.utcnow()

        request = DataSubjectRequest(
            request_id=request_id,
            user_id=user_id,
            right_type=right_type,
            submitted_at=submitted_at,
            due_date=submitted_at + timedelta(days=self.deadline_days),
            status="pending",
            verification_status="pending"
        )

        self.requests[request_id] = request
        return request

    def verify_identity(
        self,
        request_id: str,
        verification_method: str,
        verified: bool
    ):
        """Verify the identity of the requester."""
        if request_id not in self.requests:
            raise ValueError(f"Request {request_id} not found")

        request = self.requests[request_id]
        request.verification_status = "verified" if verified else "failed"
        request.notes.append(
            f"Identity verification via {verification_method}: {'passed' if verified else 'failed'}"
        )

        if not verified:
            request.status = "rejected"

    async def process_access_request(
        self,
        request_id: str,
        data_sources: List['DataSource']
    ) -> Dict[str, Any]:
        """Process a data access request."""
        request = self.requests.get(request_id)
        if not request or request.right_type != RightType.ACCESS:
            raise ValueError("Invalid access request")

        if request.verification_status != "verified":
            raise ValueError("Identity not verified")

        request.status = "in_progress"

        # Collect data from all sources
        collected_data = {}
        for source in data_sources:
            source_data = await source.get_user_data(request.user_id)
            collected_data[source.name] = source_data

        # Mark complete
        request.status = "completed"
        request.completed_at = datetime.utcnow()

        return {
            "request_id": request_id,
            "user_id": request.user_id,
            "data": collected_data,
            "generated_at": datetime.utcnow().isoformat()
        }

    async def process_erasure_request(
        self,
        request_id: str,
        data_sources: List['DataSource']
    ) -> Dict[str, Any]:
        """Process a data erasure request."""
        request = self.requests.get(request_id)
        if not request or request.right_type != RightType.ERASURE:
            raise ValueError("Invalid erasure request")

        if request.verification_status != "verified":
            raise ValueError("Identity not verified")

        request.status = "in_progress"

        # Delete from all sources
        deletion_results = []
        for source in data_sources:
            result = await source.delete_user_data(request.user_id)
            deletion_results.append({
                "source": source.name,
                "deleted": result.get("deleted", False),
                "records_removed": result.get("count", 0)
            })

        # Mark complete
        request.status = "completed"
        request.completed_at = datetime.utcnow()

        return {
            "request_id": request_id,
            "user_id": request.user_id,
            "deletions": deletion_results,
            "completed_at": datetime.utcnow().isoformat()
        }

    async def process_portability_request(
        self,
        request_id: str,
        data_sources: List['DataSource'],
        export_format: str = "json"
    ) -> Dict[str, Any]:
        """Process a data portability request."""
        request = self.requests.get(request_id)
        if not request or request.right_type != RightType.PORTABILITY:
            raise ValueError("Invalid portability request")

        if request.verification_status != "verified":
            raise ValueError("Identity not verified")

        request.status = "in_progress"

        # Collect and format data
        collected_data = {}
        for source in data_sources:
            source_data = await source.get_user_data(request.user_id)
            collected_data[source.name] = source_data

        # Format for export
        if export_format == "json":
            export_data = json.dumps(collected_data, indent=2, default=str)
        else:
            # Could support CSV, XML, etc.
            export_data = json.dumps(collected_data, default=str)

        request.status = "completed"
        request.completed_at = datetime.utcnow()

        return {
            "request_id": request_id,
            "user_id": request.user_id,
            "format": export_format,
            "data": export_data,
            "generated_at": datetime.utcnow().isoformat()
        }

    def get_overdue_requests(self) -> List[DataSubjectRequest]:
        """Get requests that are past their due date."""
        now = datetime.utcnow()
        return [
            r for r in self.requests.values()
            if r.status in ["pending", "in_progress"] and r.due_date < now
        ]

    def get_audit_log(self, request_id: str) -> Dict[str, Any]:
        """Get audit log for a request."""
        request = self.requests.get(request_id)
        if not request:
            return {}

        return {
            "request_id": request_id,
            "user_id": request.user_id,
            "right_type": request.right_type.value,
            "timeline": {
                "submitted": request.submitted_at.isoformat(),
                "due_date": request.due_date.isoformat(),
                "completed": request.completed_at.isoformat() if request.completed_at else None
            },
            "status": request.status,
            "verification": request.verification_status,
            "notes": request.notes
        }


class ConsentManager:
    """
    Manage user consent for data processing.
    """

    def __init__(self):
        self.consents: Dict[str, Dict[str, Any]] = {}

    def record_consent(
        self,
        user_id: str,
        purpose: str,
        granted: bool,
        source: str,
        version: str
    ):
        """Record user consent."""
        if user_id not in self.consents:
            self.consents[user_id] = {}

        self.consents[user_id][purpose] = {
            "granted": granted,
            "timestamp": datetime.utcnow().isoformat(),
            "source": source,
            "version": version
        }

    def check_consent(self, user_id: str, purpose: str) -> bool:
        """Check if user has granted consent for a purpose."""
        if user_id not in self.consents:
            return False

        consent = self.consents[user_id].get(purpose, {})
        return consent.get("granted", False)

    def withdraw_consent(self, user_id: str, purpose: str):
        """Withdraw consent for a purpose."""
        if user_id in self.consents and purpose in self.consents[user_id]:
            self.consents[user_id][purpose]["granted"] = False
            self.consents[user_id][purpose]["withdrawn_at"] = datetime.utcnow().isoformat()

    def get_consent_record(self, user_id: str) -> Dict[str, Any]:
        """Get all consent records for a user."""
        return self.consents.get(user_id, {})
```

## Summary

This guide covered comprehensive PII handling for LLM systems:

1. **PII Categories**: Direct identifiers, quasi-identifiers, sensitive data, context-dependent PII
2. **PII Detection**: Rule-based patterns, ML-based NER, hybrid approaches
3. **Handling Strategies**: Redaction, masking, anonymization, pseudonymization
4. **Implementation Patterns**: Pre/post processing pipelines, real-time filtering
5. **Regulatory Compliance**: GDPR, CCPA, HIPAA requirements and controls
6. **User Rights**: Access, erasure, portability, consent management

Key takeaways:
- Implement defense in depth with multiple detection methods
- Choose handling strategies appropriate for the use case
- Maintain compliance with applicable regulations
- Automate data subject request processing
- Keep comprehensive audit trails
- Regular testing and validation of PII detection

---

> **Navigation**
> [← 11.1 LLM Security](11.1_llm_security_guide.md) | **[Index](../README.md#15-repository-structure)** | [11.3 Compliance →](11.3_compliance_framework_guide.md)
